use std::collections::{HashMap, HashSet, VecDeque};
use std::env;
use std::path::{Path, PathBuf};
use std::process::Stdio;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use base64::engine::general_purpose::STANDARD as BASE64_STANDARD;
use base64::Engine as _;
use serde::Deserialize;
use serde_json::{json, Value};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use tokio::process::Command as TokioCommand;
use tokio::sync::{mpsc, oneshot, Mutex};
use tokio::task::JoinHandle;
use unicode_normalization::UnicodeNormalization;
use url::Url;

use crate::channels::{
    build_channel_transport_receipt, channel_supports_message_action, chunk_text_with_mode,
    default_chunk_mode, default_text_chunk_limit, normalize_channel_id, ChannelCapabilities,
    ChannelMessageAction, DriverRegistry,
};
use crate::config::{
    GroupActivationMode, SessionQueueMode, ToolRuntimePolicyConfig, ToolRuntimeWasmMode,
};
use crate::persistent_memory::{
    MemoryRecallQuery, MemoryRememberInput, MemoryRuntimeConfig, PersistentMemoryRegistry,
    DEFAULT_GRAPHLITE_STORE_PATH, DEFAULT_ZVEC_STORE_PATH,
};
use crate::protocol::{MethodFamily, RpcRequestFrame};
use crate::session_key::{parse_session_key, SessionKind};
use crate::tool_runtime::{ToolRuntimeHost, ToolRuntimeRequest};
use crate::types::{ActionRequest, Decision, DecisionAction};
use crate::website_bridge::{invoke_openai_compatible, WebsiteBridgeRequest};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct MethodSpec {
    pub name: &'static str,
    pub family: MethodFamily,
    pub requires_auth: bool,
    pub min_role: &'static str,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ResolvedMethod {
    pub requested: String,
    pub canonical: String,
    pub known: bool,
    pub spec: Option<MethodSpec>,
}

pub struct MethodRegistry {
    known: &'static [MethodSpec],
}

impl MethodRegistry {
    pub fn default_registry() -> Self {
        Self {
            known: &[
                MethodSpec {
                    name: "connect",
                    family: MethodFamily::Connect,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "health",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "status",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "usage.status",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "usage.cost",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "last-heartbeat",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "set-heartbeats",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "system-presence",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "system-event",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "wake",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "talk.config",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "talk.mode",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "tts.status",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "tts.enable",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "tts.disable",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "tts.convert",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "tts.setprovider",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "tts.providers",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "voicewake.get",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "voicewake.set",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "models.list",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agents.list",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agents.create",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agents.update",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agents.delete",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agents.files.list",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agents.files.get",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agents.files.set",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agent",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agent.identity.get",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agent.wait",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "skills.status",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "skills.bins",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "skills.install",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "skills.update",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "channels.status",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "channels.logout",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "update.run",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "web.login.start",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "web.login.wait",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "auth.oauth.providers",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "auth.oauth.start",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "auth.oauth.wait",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "auth.oauth.complete",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "auth.oauth.logout",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "auth.oauth.import",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "wizard.start",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "wizard.next",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "wizard.cancel",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "wizard.status",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "device.pair.list",
                    family: MethodFamily::Pairing,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "device.pair.approve",
                    family: MethodFamily::Pairing,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "device.pair.reject",
                    family: MethodFamily::Pairing,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "device.pair.remove",
                    family: MethodFamily::Pairing,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "device.token.rotate",
                    family: MethodFamily::Pairing,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "device.token.revoke",
                    family: MethodFamily::Pairing,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "config.get",
                    family: MethodFamily::Config,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "config.set",
                    family: MethodFamily::Config,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "config.patch",
                    family: MethodFamily::Config,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "config.apply",
                    family: MethodFamily::Config,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "config.schema",
                    family: MethodFamily::Config,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "logs.tail",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "agent.exec",
                    family: MethodFamily::Agent,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.patch",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.resolve",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.list",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.preview",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.reset",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.delete",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.compact",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.usage",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.usage.timeseries",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.usage.logs",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.history",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "sessions.send",
                    family: MethodFamily::Sessions,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "session.status",
                    family: MethodFamily::Session,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.pair.request",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.pair.list",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.pair.approve",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.pair.reject",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.pair.verify",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.rename",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.list",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.describe",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.invoke",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.invoke.result",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "node.event",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "push.test",
                    family: MethodFamily::Node,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "cron.add",
                    family: MethodFamily::Cron,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "cron.list",
                    family: MethodFamily::Cron,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "cron.status",
                    family: MethodFamily::Cron,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "cron.update",
                    family: MethodFamily::Cron,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "cron.remove",
                    family: MethodFamily::Cron,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "cron.run",
                    family: MethodFamily::Cron,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "cron.runs",
                    family: MethodFamily::Cron,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "chat.history",
                    family: MethodFamily::Message,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "send",
                    family: MethodFamily::Message,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "poll",
                    family: MethodFamily::Message,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "chat.send",
                    family: MethodFamily::Message,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "chat.abort",
                    family: MethodFamily::Message,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "chat.inject",
                    family: MethodFamily::Message,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "browser.request",
                    family: MethodFamily::Browser,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "exec.approvals.get",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "exec.approvals.set",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "exec.approvals.node.get",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "exec.approvals.node.set",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "owner",
                },
                MethodSpec {
                    name: "exec.approval.request",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "exec.approval.waitdecision",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "exec.approval.resolve",
                    family: MethodFamily::Gateway,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "browser.open",
                    family: MethodFamily::Browser,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "canvas.present",
                    family: MethodFamily::Canvas,
                    requires_auth: true,
                    min_role: "client",
                },
                MethodSpec {
                    name: "pairing.approve",
                    family: MethodFamily::Pairing,
                    requires_auth: true,
                    min_role: "owner",
                },
            ],
        }
    }

    pub fn resolve(&self, method: &str) -> ResolvedMethod {
        let canonical = normalize(method);
        let spec = self.known.iter().find(|s| s.name == canonical).copied();
        ResolvedMethod {
            requested: method.to_owned(),
            canonical,
            known: spec.is_some(),
            spec,
        }
    }
}

pub struct RpcDispatcher {
    sessions: SessionRegistry,
    system: SystemRegistry,
    talk: TalkRegistry,
    tts: TtsRegistry,
    voicewake: VoiceWakeRegistry,
    voice_io: VoiceIoRegistry,
    models: ModelRegistry,
    auth_profiles: AuthProfileRegistry,
    agents: AgentRegistry,
    agent_runs: AgentRunRegistry,
    nodes: NodePairRegistry,
    node_runtime: NodeRuntimeRegistry,
    apns: ApnsRegistrationRegistry,
    node_host_runtime: NodeHostRuntimeRegistry,
    exec_approvals: ExecApprovalsRegistry,
    exec_approval: ExecApprovalRegistry,
    chat: ChatRegistry,
    send: SendRegistry,
    skills: SkillsRegistry,
    cron: CronRegistry,
    legacy_cron_notify_warned: Mutex<HashSet<String>>,
    config: ConfigRegistry,
    memory: PersistentMemoryRegistry,
    web_login: WebLoginRegistry,
    oauth: OAuthRegistry,
    wizard: WizardRegistry,
    devices: DeviceRegistry,
    channel_capabilities: Vec<ChannelCapabilities>,
    channel_runtime: ChannelRuntimeRegistry,
    started_at_ms: u64,
}

const MAX_SESSION_HISTORY_PER_SESSION: usize = 400;
const MAX_SYSTEM_LOG_LINES: usize = 20_000;
const RUNTIME_NAME: &str = "openclaw-agent-rs";
const RUNTIME_VERSION: &str = env!("CARGO_PKG_VERSION");
const SESSION_STORE_PATH: &str = "memory://session-registry";
const SYSTEM_LOG_PATH: &str = "memory://gateway.log";
const DEFAULT_AGENT_ID: &str = "main";
const DEFAULT_AGENT_SCOPE: &str = "per-sender";
const DEFAULT_AGENT_WORKSPACE: &str = "memory://agents/main";
const DEFAULT_MAIN_KEY: &str = "main";
const DEFAULT_AGENT_NAME: &str = "Main";
const DEFAULT_AGENT_IDENTITY_NAME: &str = "OpenClaw";
const DEFAULT_AGENT_IDENTITY_THEME: &str = "default";
const DEFAULT_AGENT_IDENTITY_EMOJI: &str = "claw";
const DEFAULT_AGENT_IDENTITY_AVATAR: &str = "openclaw";
const DEFAULT_AGENT_IDENTITY_AVATAR_URL: &str = "memory://agents/main/avatar";
const DEFAULT_MODEL_PROVIDER: &str = "openai";
const DEFAULT_MODEL_ID: &str = "gpt-5.3";
const AGENT_BOOTSTRAP_FILE_NAMES: &[&str] = &[
    "AGENTS.md",
    "SOUL.md",
    "TOOLS.md",
    "IDENTITY.md",
    "USER.md",
    "HEARTBEAT.md",
    "BOOTSTRAP.md",
];
const AGENT_PRIMARY_MEMORY_FILE_NAME: &str = "MEMORY.md";
const AGENT_ALT_MEMORY_FILE_NAME: &str = "memory.md";
const CRON_STORE_PATH: &str = "memory://cron/jobs.json";
const MAX_CRON_RUN_LOGS_PER_JOB: usize = 500;
const EXEC_APPROVALS_GLOBAL_PATH: &str = "memory://exec-approvals.json";
const EXEC_APPROVALS_SOCKET_PATH: &str = "memory://exec-approvals.sock";
const MAX_EXEC_APPROVALS_NODE_SNAPSHOTS: usize = 512;
const DEFAULT_EXEC_APPROVAL_TIMEOUT_MS: u64 = 120_000;
const MAX_EXEC_APPROVAL_PENDING: usize = 4_096;
const EXEC_APPROVAL_RESOLVED_GRACE_MS: u64 = 15_000;
const AGENT_RUN_COMPLETE_DELAY_MS: u64 = 25;
const AGENT_LLM_TURN_MAX_HISTORY: usize = 64;
const AGENT_LLM_TOOL_LOOP_MAX_STEPS: usize = 8;
const AGENT_TOOL_OUTPUT_MAX_CHARS: usize = 8_192;
const AGENT_PROVIDER_HTTP_TIMEOUT_MS: u64 = 60_000;
const AGENT_SELF_HEAL_MAX_ATTEMPTS_CAP: usize = 6;
const AGENT_SELF_HEAL_DEFAULT_MAX_ATTEMPTS_CORE: usize = 1;
const AGENT_SELF_HEAL_DEFAULT_MAX_ATTEMPTS_EDGE: usize = 2;
const AGENT_SELF_HEAL_DEFAULT_BACKOFF_MS_CORE: u64 = 250;
const AGENT_SELF_HEAL_DEFAULT_BACKOFF_MS_EDGE: u64 = 80;
const AGENT_SELF_HEAL_MAX_BACKOFF_MS: u64 = 5_000;
const MAX_CHAT_RUNS: usize = 4_096;
const CHAT_RUN_COMPLETE_DELAY_MS: u64 = 25;
const MAX_SEND_CACHE_ENTRIES: usize = 4_096;
const SEND_CACHE_STORE_PATH: &str = "memory://idempotency/send-cache.json";
const DEFAULT_SEND_CACHE_TTL_MS: u64 = 300_000;
const CHANNEL_RUNTIME_STORE_PATH: &str = "memory://channels/runtime.json";
const DEVICE_PAIR_STORE_PATH: &str = "memory://devices/pairs.json";
const NODE_PAIR_STORE_PATH: &str = "memory://nodes/pairs.json";
const CONFIG_STORE_PATH: &str = "memory://config.json";
const WEB_LOGIN_STORE_PATH: &str = "memory://web-login/sessions.json";
const OAUTH_STORE_PATH: &str = "memory://auth/oauth/sessions.json";
const WIZARD_STORE_PATH: &str = "memory://wizard/sessions.json";
const DEFAULT_SEND_CHANNEL: &str = "whatsapp";
const TTS_PREFS_PATH: &str = "memory://tts/prefs.json";
const DEFAULT_APNS_PUSH_TIMEOUT_MS: u64 = 10_000;
const LOCAL_NODE_CAP_HINTS: &[&str] = &[
    "host.local",
    "local-host",
    "runtime.local",
    "loopback",
    "self-hosted",
];
const LOCAL_NODE_HOST_SYSTEM_RUN_TIMEOUT_MS: u64 = 10_000;
const LOCAL_NODE_HOST_SYSTEM_RUN_OUTPUT_MAX_CHARS: usize = 16_000;
const LOCAL_NODE_HOST_CAMERA_CLIP_DEFAULT_DURATION_MS: u64 = 3_000;
const LOCAL_NODE_HOST_CAMERA_CLIP_MAX_DURATION_MS: u64 = 60_000;
const LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ARGV_ITEMS: usize = 64;
const LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ARG_LEN: usize = 2_048;
const LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ENV_ITEMS: usize = 64;
const LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ENV_KEY_LEN: usize = 128;
const LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ENV_VALUE_LEN: usize = 4_096;
const LOCAL_NODE_HOST_SYSTEM_WHICH_MAX_BINS: usize = 64;
const LOCAL_NODE_HOST_SYSTEM_WHICH_MAX_BIN_LEN: usize = 128;
const LOCAL_NODE_HOST_SYSTEM_NOTIFY_TITLE_MAX_CHARS: usize = 256;
const LOCAL_NODE_HOST_SYSTEM_NOTIFY_BODY_MAX_CHARS: usize = 2_048;
const LOCAL_NODE_HOST_SYSTEM_NOTIFY_LEVEL_MAX_CHARS: usize = 32;
const LOCAL_NODE_HOST_SYSTEM_NOTIFY_PRIORITY_MAX_CHARS: usize = 32;
const LOCAL_NODE_HOST_SYSTEM_NOTIFY_DELIVERY_MAX_CHARS: usize = 32;
const LOCAL_NODE_HOST_EXTERNAL_QUEUE_CAPACITY: usize = 32;
const LOCAL_NODE_HOST_EXTERNAL_IDLE_TIMEOUT_MS: u64 = 30_000;
const LOCAL_NODE_HOST_EXTERNAL_MAX_SESSIONS: usize = 64;
const LOCAL_NODE_HOST_EXTERNAL_RESPONSE_LINE_MAX_CHARS: usize = 262_144;
const LOCAL_NODE_HOST_SYSTEM_RUN_ALLOWLIST: &[&str] = &[
    "echo", "whoami", "pwd", "uname", "id", "date", "hostname", "ls", "dir",
];
const NODE_CANVAS_COMMANDS: &[&str] = &[
    "canvas.present",
    "canvas.hide",
    "canvas.navigate",
    "canvas.eval",
    "canvas.snapshot",
    "canvas.a2ui.push",
    "canvas.a2ui.pushJSONL",
    "canvas.a2ui.reset",
];
const NODE_CAMERA_COMMANDS: &[&str] = &["camera.list"];
const NODE_LOCATION_COMMANDS: &[&str] = &["location.get"];
const NODE_DEVICE_COMMANDS: &[&str] = &["device.info", "device.status"];
const NODE_CONTACTS_COMMANDS: &[&str] = &["contacts.search"];
const NODE_CALENDAR_COMMANDS: &[&str] = &["calendar.events"];
const NODE_REMINDERS_COMMANDS: &[&str] = &["reminders.list"];
const NODE_PHOTOS_COMMANDS: &[&str] = &["photos.latest"];
const NODE_MOTION_COMMANDS: &[&str] = &["motion.activity", "motion.pedometer"];
const NODE_IOS_SYSTEM_COMMANDS: &[&str] = &["system.notify"];
const NODE_SYSTEM_COMMANDS: &[&str] = &[
    "system.run",
    "system.which",
    "system.notify",
    "browser.proxy",
];
const NODE_DEFAULT_DANGEROUS_COMMANDS: &[&str] = &[
    "camera.snap",
    "camera.clip",
    "screen.record",
    "contacts.add",
    "calendar.add",
    "reminders.add",
    "sms.send",
];
const TTS_OPENAI_MODELS: &[&str] = &["gpt-4o-mini-tts", "tts-1", "tts-1-hd"];
const TTS_OPENAI_VOICES: &[&str] = &[
    "alloy", "ash", "ballad", "cedar", "coral", "echo", "fable", "juniper", "marin", "onyx",
    "nova", "sage", "shimmer", "verse",
];
const TTS_OPENAI_DEFAULT_MODEL: &str = "gpt-4o-mini-tts";
const TTS_OPENAI_DEFAULT_VOICE: &str = "alloy";
const TTS_OPENAI_API_KEY_ENV: &str = "OPENAI_API_KEY";
const RUNTIME_PROFILE_ENV: &str = "OPENCLAW_RS_RUNTIME_PROFILE";
const AGENT_SELF_HEAL_ENABLED_ENV: &str = "OPENCLAW_RS_AGENT_SELF_HEAL_ENABLED";
const AGENT_SELF_HEAL_MAX_ATTEMPTS_ENV: &str = "OPENCLAW_RS_AGENT_SELF_HEAL_MAX_ATTEMPTS";
const AGENT_SELF_HEAL_BACKOFF_MS_ENV: &str = "OPENCLAW_RS_AGENT_SELF_HEAL_BACKOFF_MS";
const TTS_KITTENTTS_BIN_ENV: &str = "OPENCLAW_RS_KITTENTTS_BIN";
const TTS_KITTENTTS_ARGS_ENV: &str = "OPENCLAW_RS_KITTENTTS_ARGS";
const TTS_ELEVENLABS_MODELS: &[&str] = &[
    "eleven_multilingual_v2",
    "eleven_turbo_v2_5",
    "eleven_monolingual_v1",
];
const TTS_ELEVENLABS_DEFAULT_MODEL: &str = "eleven_turbo_v2_5";
const TTS_ELEVENLABS_API_KEY_ENV: &str = "ELEVENLABS_API_KEY";
const TTS_ELEVENLABS_VOICE_ID_ENV: &str = "ELEVENLABS_VOICE_ID";
const TTS_ELEVENLABS_DEFAULT_VOICE_ID: &str = "EXAVITQu4vr4xnSDxMaL";
const TTS_PROVIDER_HTTP_TIMEOUT_SECS: u64 = 15;
const DEFAULT_VOICEWAKE_TRIGGERS: &[&str] = &["openclaw", "claude", "computer"];
const VOICE_INPUT_DEVICE_DEFAULT: &str = "default-microphone";
const VOICE_OUTPUT_DEVICE_DEFAULT: &str = "default-speaker";
static SESSION_ID_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static CRON_ID_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static WEB_LOGIN_ID_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static OAUTH_SESSION_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static WIZARD_ID_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static DEVICE_TOKEN_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static NODE_PAIR_REQUEST_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static NODE_TOKEN_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static NODE_INVOKE_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static NODE_NOTIFY_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static BROWSER_PROXY_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static CANVAS_PRESENT_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static EXEC_APPROVAL_TOKEN_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static EXEC_APPROVAL_ID_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static CHAT_INJECT_ID_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static SEND_MESSAGE_ID_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static POLL_ID_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static TTS_AUDIO_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static VOICE_CAPTURE_SEQUENCE: AtomicU64 = AtomicU64::new(1);
static VOICE_PLAYBACK_SEQUENCE: AtomicU64 = AtomicU64::new(1);
const SUPPORTED_RPC_METHODS: &[&str] = &[
    "connect",
    "health",
    "status",
    "usage.status",
    "usage.cost",
    "last-heartbeat",
    "set-heartbeats",
    "system-presence",
    "system-event",
    "wake",
    "talk.config",
    "talk.mode",
    "tts.status",
    "tts.enable",
    "tts.disable",
    "tts.convert",
    "tts.setProvider",
    "tts.providers",
    "voicewake.get",
    "voicewake.set",
    "models.list",
    "agents.list",
    "agents.create",
    "agents.update",
    "agents.delete",
    "agents.files.list",
    "agents.files.get",
    "agents.files.set",
    "agent",
    "agent.identity.get",
    "agent.wait",
    "skills.status",
    "skills.bins",
    "skills.install",
    "skills.update",
    "cron.list",
    "cron.status",
    "cron.add",
    "cron.update",
    "cron.remove",
    "cron.run",
    "cron.runs",
    "channels.status",
    "channels.logout",
    "update.run",
    "web.login.start",
    "web.login.wait",
    "auth.oauth.providers",
    "auth.oauth.start",
    "auth.oauth.wait",
    "auth.oauth.complete",
    "auth.oauth.logout",
    "auth.oauth.import",
    "wizard.start",
    "wizard.next",
    "wizard.cancel",
    "wizard.status",
    "device.pair.list",
    "device.pair.approve",
    "device.pair.reject",
    "device.pair.remove",
    "device.token.rotate",
    "device.token.revoke",
    "node.pair.request",
    "node.pair.list",
    "node.pair.approve",
    "node.pair.reject",
    "node.pair.verify",
    "node.rename",
    "node.list",
    "node.describe",
    "node.invoke",
    "node.invoke.result",
    "node.event",
    "push.test",
    "browser.request",
    "browser.open",
    "canvas.present",
    "exec.approvals.get",
    "exec.approvals.set",
    "exec.approvals.node.get",
    "exec.approvals.node.set",
    "exec.approval.request",
    "exec.approval.waitDecision",
    "exec.approval.resolve",
    "chat.history",
    "send",
    "poll",
    "chat.send",
    "chat.abort",
    "chat.inject",
    "config.get",
    "config.set",
    "config.patch",
    "config.apply",
    "config.schema",
    "logs.tail",
    "sessions.list",
    "sessions.preview",
    "sessions.patch",
    "sessions.resolve",
    "sessions.reset",
    "sessions.delete",
    "sessions.compact",
    "sessions.usage",
    "sessions.usage.timeseries",
    "sessions.usage.logs",
    "sessions.history",
    "sessions.send",
    "session.status",
];

pub fn supported_rpc_methods() -> &'static [&'static str] {
    SUPPORTED_RPC_METHODS
}

impl RpcDispatcher {
    pub fn new() -> Self {
        let channel_capabilities = DriverRegistry::default_registry()
            .capabilities()
            .into_iter()
            .filter(|cap| cap.name != "generic")
            .collect::<Vec<_>>();
        Self {
            sessions: SessionRegistry::new(),
            system: SystemRegistry::new(),
            talk: TalkRegistry::new(),
            tts: TtsRegistry::new(),
            voicewake: VoiceWakeRegistry::new(),
            voice_io: VoiceIoRegistry::new(),
            models: ModelRegistry::new(),
            auth_profiles: AuthProfileRegistry::new(),
            agents: AgentRegistry::new(),
            agent_runs: AgentRunRegistry::new(),
            nodes: NodePairRegistry::new(),
            node_runtime: NodeRuntimeRegistry::new(),
            apns: ApnsRegistrationRegistry::new(),
            node_host_runtime: NodeHostRuntimeRegistry::new(),
            exec_approvals: ExecApprovalsRegistry::new(),
            exec_approval: ExecApprovalRegistry::new(),
            chat: ChatRegistry::new(),
            send: SendRegistry::new(),
            skills: SkillsRegistry::new(),
            cron: CronRegistry::new(),
            legacy_cron_notify_warned: Mutex::new(HashSet::new()),
            config: ConfigRegistry::new(),
            memory: PersistentMemoryRegistry::new(),
            web_login: WebLoginRegistry::new(),
            oauth: OAuthRegistry::new(),
            wizard: WizardRegistry::new(),
            devices: DeviceRegistry::new(),
            channel_capabilities,
            channel_runtime: ChannelRuntimeRegistry::new(),
            started_at_ms: now_ms(),
        }
    }

    pub async fn run_due_cron_jobs(&self, max_jobs: usize) -> usize {
        if let Err(err) = self.sync_cron_runtime_from_config().await {
            self.system
                .log_line(format!("cron.runtime sync failed: {err}"))
                .await;
            return 0;
        }
        let executions = self.cron.run_due_batch(max_jobs).await;
        let mut executed = 0usize;
        for execution in executions {
            executed = executed.saturating_add(1);
            self.apply_cron_execution_side_effects(&execution, CronRunMode::Due)
                .await;
        }
        executed
    }

    pub async fn resolve_session_for_delivery_hints(&self, raw: &Value) -> Option<String> {
        let hints = extract_delivery_context_hints(raw);
        if hints.is_empty() {
            return None;
        }
        self.sessions
            .resolve_query(SessionResolveQuery {
                label: None,
                agent_id: None,
                spawned_by: None,
                channel: hints.channel,
                to: hints.to,
                account_id: hints.account_id,
                thread_id: hints.thread_id,
                include_global: true,
                include_unknown: true,
            })
            .await
    }

    async fn sync_cron_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.cron_runtime_config().await;
        self.cron
            .apply_runtime_config(runtime)
            .await
            .map_err(|err| match err {
                CronRegistryError::NotFound(message) | CronRegistryError::Invalid(message) => {
                    message
                }
            })
    }

    async fn sync_send_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.send_runtime_config().await;
        self.send
            .apply_runtime_config(runtime)
            .await
            .map_err(|err| match err {
                SendRegistryError::Invalid(message) => message,
            })
    }

    async fn sync_session_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.session_runtime_config().await;
        self.sessions
            .apply_runtime_config(runtime)
            .await
            .map_err(|err| match err {
                SessionRegistryError::Invalid(message) => message,
            })
    }

    async fn sync_channel_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.channel_runtime_config().await;
        self.channel_runtime.apply_runtime_config(runtime).await
    }

    async fn sync_device_pair_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.device_pair_runtime_config().await;
        self.devices.apply_runtime_config(runtime).await
    }

    async fn sync_node_pair_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.node_pair_runtime_config().await;
        self.nodes.apply_runtime_config(runtime).await
    }

    async fn sync_config_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.config_runtime_config().await;
        self.config.apply_runtime_config(runtime).await
    }

    async fn sync_memory_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.memory_runtime_config().await;
        self.memory.apply_runtime_config(runtime).await
    }

    async fn sync_agents_runtime_from_config(&self) -> Result<(), String> {
        let snapshot = self.config.get_snapshot().await;
        self.agents.sync_from_config(&snapshot.config).await
    }

    async fn persist_agent_config_mutation<F>(&self, mut mutate: F) -> Result<(), String>
    where
        F: FnMut(&mut Value) -> Result<(), String>,
    {
        if let Err(err) = self.sync_config_runtime_from_config().await {
            return Err(format!("config runtime unavailable: {err}"));
        }
        for _ in 0..3 {
            let snapshot = self.config.get_snapshot().await;
            let mut config = snapshot.config.clone();
            mutate(&mut config)?;
            let raw = serde_json::to_string_pretty(&config)
                .map_err(|err| format!("failed serializing agent config: {err}"))?;
            match self.config.set(raw, Some(snapshot.hash.clone())).await {
                Ok(_) => {
                    return Ok(());
                }
                Err(err) => {
                    if err.contains("config changed since last load") {
                        continue;
                    }
                    return Err(err);
                }
            }
        }
        Err("config changed since last load; retry agent mutation".to_owned())
    }

    async fn persist_agent_create_to_config(
        &self,
        created: &AgentCreatedResult,
        emoji: Option<&str>,
        avatar: Option<&str>,
    ) -> Result<(), String> {
        self.persist_agent_config_mutation(|config| {
            apply_agent_create_to_config(config, created, emoji, avatar);
            Ok(())
        })
        .await
    }

    async fn persist_agent_update_to_config(
        &self,
        params: &AgentsUpdateParams,
    ) -> Result<(), String> {
        self.persist_agent_config_mutation(|config| apply_agent_update_to_config(config, params))
            .await
    }

    async fn persist_agent_delete_to_config(&self, agent_id: &str) -> Result<u64, String> {
        let mut removed_bindings = 0u64;
        self.persist_agent_config_mutation(|config| {
            removed_bindings = apply_agent_delete_to_config(config, agent_id);
            Ok(())
        })
        .await?;
        Ok(removed_bindings)
    }

    async fn sync_web_login_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.web_login_runtime_config().await;
        self.web_login.apply_runtime_config(runtime).await
    }

    async fn sync_oauth_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.oauth_runtime_config().await;
        self.oauth.apply_runtime_config(runtime).await
    }

    async fn sync_wizard_runtime_from_config(&self) -> Result<(), String> {
        let runtime = self.config.wizard_runtime_config().await;
        self.wizard.apply_runtime_config(runtime).await
    }

    pub async fn handle_request(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        match normalize(&req.method).as_str() {
            "connect" => self.handle_connect().await,
            "health" => self.handle_health().await,
            "status" => self.handle_status().await,
            "usage.status" => self.handle_usage_status().await,
            "usage.cost" => self.handle_usage_cost(req).await,
            "last-heartbeat" | "heartbeat" => self.handle_last_heartbeat().await,
            "set-heartbeats" => self.handle_set_heartbeats(req).await,
            "system-presence" | "presence" => self.handle_system_presence().await,
            "system-event" => self.handle_system_event(req).await,
            "wake" => self.handle_wake(req).await,
            "talk.config" => self.handle_talk_config(req).await,
            "talk.mode" => self.handle_talk_mode(req).await,
            "tts.status" => self.handle_tts_status(req).await,
            "tts.enable" => self.handle_tts_enable(req).await,
            "tts.disable" => self.handle_tts_disable(req).await,
            "tts.convert" => self.handle_tts_convert(req).await,
            "tts.setprovider" => self.handle_tts_set_provider(req).await,
            "tts.providers" => self.handle_tts_providers(req).await,
            "voicewake.get" => self.handle_voicewake_get(req).await,
            "voicewake.set" => self.handle_voicewake_set(req).await,
            "models.list" => self.handle_models_list(req).await,
            "agents.list" => self.handle_agents_list(req).await,
            "agents.create" => self.handle_agents_create(req).await,
            "agents.update" => self.handle_agents_update(req).await,
            "agents.delete" => self.handle_agents_delete(req).await,
            "agents.files.list" => self.handle_agents_files_list(req).await,
            "agents.files.get" => self.handle_agents_files_get(req).await,
            "agents.files.set" => self.handle_agents_files_set(req).await,
            "agent" => self.handle_agent(req).await,
            "agent.identity.get" => self.handle_agent_identity_get(req).await,
            "agent.wait" => self.handle_agent_wait(req).await,
            "skills.status" => self.handle_skills_status(req).await,
            "skills.bins" => self.handle_skills_bins(req).await,
            "skills.install" => self.handle_skills_install(req).await,
            "skills.update" => self.handle_skills_update(req).await,
            "cron.list" => self.handle_cron_list(req).await,
            "cron.status" => self.handle_cron_status(req).await,
            "cron.add" => self.handle_cron_add(req).await,
            "cron.update" => self.handle_cron_update(req).await,
            "cron.remove" => self.handle_cron_remove(req).await,
            "cron.run" => self.handle_cron_run(req).await,
            "cron.runs" => self.handle_cron_runs(req).await,
            "channels.status" => self.handle_channels_status(req).await,
            "channels.logout" => self.handle_channels_logout(req).await,
            "update.run" => self.handle_update_run(req).await,
            "web.login.start" => self.handle_web_login_start(req).await,
            "web.login.wait" => self.handle_web_login_wait(req).await,
            "auth.oauth.providers" => self.handle_auth_oauth_providers(req).await,
            "auth.oauth.start" => self.handle_auth_oauth_start(req).await,
            "auth.oauth.wait" => self.handle_auth_oauth_wait(req).await,
            "auth.oauth.complete" => self.handle_auth_oauth_complete(req).await,
            "auth.oauth.logout" => self.handle_auth_oauth_logout(req).await,
            "auth.oauth.import" => self.handle_auth_oauth_import(req).await,
            "wizard.start" => self.handle_wizard_start(req).await,
            "wizard.next" => self.handle_wizard_next(req).await,
            "wizard.cancel" => self.handle_wizard_cancel(req).await,
            "wizard.status" => self.handle_wizard_status(req).await,
            "device.pair.list" => self.handle_device_pair_list(req).await,
            "device.pair.approve" => self.handle_device_pair_approve(req).await,
            "device.pair.reject" => self.handle_device_pair_reject(req).await,
            "device.pair.remove" => self.handle_device_pair_remove(req).await,
            "device.token.rotate" => self.handle_device_token_rotate(req).await,
            "device.token.revoke" => self.handle_device_token_revoke(req).await,
            "node.pair.request" => self.handle_node_pair_request(req).await,
            "node.pair.list" => self.handle_node_pair_list(req).await,
            "node.pair.approve" => self.handle_node_pair_approve(req).await,
            "node.pair.reject" => self.handle_node_pair_reject(req).await,
            "node.pair.verify" => self.handle_node_pair_verify(req).await,
            "node.rename" => self.handle_node_rename(req).await,
            "node.list" => self.handle_node_list(req).await,
            "node.describe" => self.handle_node_describe(req).await,
            "node.invoke" => self.handle_node_invoke(req).await,
            "node.invoke.result" => self.handle_node_invoke_result(req).await,
            "node.event" => self.handle_node_event(req).await,
            "push.test" => self.handle_push_test(req).await,
            "browser.request" => self.handle_browser_request(req).await,
            "browser.open" => self.handle_browser_open(req).await,
            "canvas.present" => self.handle_canvas_present(req).await,
            "exec.approvals.get" => self.handle_exec_approvals_get(req).await,
            "exec.approvals.set" => self.handle_exec_approvals_set(req).await,
            "exec.approvals.node.get" => self.handle_exec_approvals_node_get(req).await,
            "exec.approvals.node.set" => self.handle_exec_approvals_node_set(req).await,
            "exec.approval.request" => self.handle_exec_approval_request(req).await,
            "exec.approval.waitdecision" => self.handle_exec_approval_wait_decision(req).await,
            "exec.approval.resolve" => self.handle_exec_approval_resolve(req).await,
            "chat.history" => self.handle_chat_history(req).await,
            "send" => self.handle_send(req).await,
            "poll" => self.handle_poll(req).await,
            "chat.send" => self.handle_chat_send(req).await,
            "chat.abort" => self.handle_chat_abort(req).await,
            "chat.inject" => self.handle_chat_inject(req).await,
            "config.get" => self.handle_config_get(req).await,
            "config.set" => self.handle_config_set(req).await,
            "config.patch" => self.handle_config_patch(req).await,
            "config.apply" => self.handle_config_apply(req).await,
            "config.schema" => self.handle_config_schema(req).await,
            "logs.tail" => self.handle_logs_tail(req).await,
            "sessions.list" => self.handle_sessions_list(req).await,
            "sessions.preview" => self.handle_sessions_preview(req).await,
            "sessions.patch" => self.handle_sessions_patch(req).await,
            "sessions.resolve" => self.handle_sessions_resolve(req).await,
            "sessions.reset" => self.handle_sessions_reset(req).await,
            "sessions.delete" => self.handle_sessions_delete(req).await,
            "sessions.compact" => self.handle_sessions_compact(req).await,
            "sessions.usage" => self.handle_sessions_usage(req).await,
            "sessions.usage.timeseries" => self.handle_sessions_usage_timeseries(req).await,
            "sessions.usage.logs" => self.handle_sessions_usage_logs(req).await,
            "sessions.history" => self.handle_sessions_history(req).await,
            "sessions.send" => self.handle_sessions_send(req).await,
            "session.status" | "sessions.status" => self.handle_session_status(req).await,
            _ => RpcDispatchOutcome::NotHandled,
        }
    }

    async fn apply_cron_execution_side_effects(
        &self,
        execution: &CronRunExecution,
        mode: CronRunMode,
    ) {
        if let Some(text) = execution.system_event_text.clone() {
            self.system
                .upsert_presence(SystemPresenceUpdate {
                    text,
                    device_id: None,
                    instance_id: None,
                    host: None,
                    ip: None,
                    mode: None,
                    version: None,
                    platform: None,
                    device_family: None,
                    model_identifier: None,
                    last_input_seconds: None,
                    reason: Some("cron".to_owned()),
                    roles: Vec::new(),
                    scopes: Vec::new(),
                    tags: vec!["cron".to_owned()],
                })
                .await;
        }
        let webhook_defaults = self.config.cron_webhook_defaults().await;
        if let Some(webhook_dispatch) =
            build_cron_webhook_dispatch(&execution.job, &execution.entry, &webhook_defaults)
        {
            if matches!(
                webhook_dispatch.source,
                CronWebhookSource::LegacyNotifyFallback
            ) {
                let should_warn = {
                    let mut warned = self.legacy_cron_notify_warned.lock().await;
                    warned.insert(execution.entry.job_id.clone())
                };
                if should_warn {
                    self.system
                        .log_line(format!(
                            "cron.webhook id={} source=legacy_notify_fallback deprecation=notify+cron.webhook",
                            execution.entry.job_id
                        ))
                        .await;
                }
            }
            match dispatch_cron_webhook(&webhook_dispatch).await {
                Ok(()) => {
                    self.system
                        .log_line(format!(
                            "cron.webhook id={} target={} status=ok",
                            execution.entry.job_id, webhook_dispatch.target
                        ))
                        .await;
                }
                Err(err) => {
                    self.system
                        .log_line(format!(
                            "cron.webhook id={} target={} status=error bestEffort={} error={}",
                            execution.entry.job_id,
                            webhook_dispatch.target.as_str(),
                            webhook_dispatch.best_effort,
                            err
                        ))
                        .await;
                }
            }
        }
        self.system
            .log_line(format!(
                "cron.run id={} mode={}",
                execution.entry.job_id,
                mode.as_str()
            ))
            .await;
    }

    pub async fn record_decision(&self, request: &ActionRequest, decision: &Decision) {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
        }
        self.sessions.record_decision(request, decision).await;
    }

    pub async fn ingest_event_frame(&self, frame: &Value) {
        let Some(event) = frame.get("event").and_then(Value::as_str) else {
            return;
        };
        let payload = frame.get("payload").cloned().unwrap_or(Value::Null);
        let normalized_event = normalize(event);
        match normalized_event.as_str() {
            "heartbeat" => {
                self.system.update_last_heartbeat(payload.clone()).await;
            }
            "presence" => {
                self.system.replace_presence(payload.clone()).await;
            }
            "device.pair.requested" => {
                if let Err(err) = self.sync_device_pair_runtime_from_config().await {
                    self.system
                        .log_line(format!("device_pair.runtime sync failed: {err}"))
                        .await;
                    return;
                }
                self.devices.ingest_pair_requested(payload.clone()).await;
            }
            "device.pair.resolved" => {
                if let Err(err) = self.sync_device_pair_runtime_from_config().await {
                    self.system
                        .log_line(format!("device_pair.runtime sync failed: {err}"))
                        .await;
                    return;
                }
                self.devices.ingest_pair_resolved(payload.clone()).await;
            }
            "node.pair.requested" => {
                if let Err(err) = self.sync_node_pair_runtime_from_config().await {
                    self.system
                        .log_line(format!("node_pair.runtime sync failed: {err}"))
                        .await;
                    return;
                }
                self.nodes.ingest_pair_requested(payload.clone()).await;
            }
            "node.pair.resolved" => {
                if let Err(err) = self.sync_node_pair_runtime_from_config().await {
                    self.system
                        .log_line(format!("node_pair.runtime sync failed: {err}"))
                        .await;
                    return;
                }
                self.nodes.ingest_pair_resolved(payload.clone()).await;
            }
            _ => {}
        }
        if let Err(err) = self.sync_channel_runtime_from_config().await {
            self.system
                .log_line(format!("channel.runtime sync failed: {err}"))
                .await;
            return;
        }
        self.channel_runtime
            .ingest_event(
                normalized_event.as_str(),
                &payload,
                &self.channel_capabilities,
            )
            .await;
    }

    async fn handle_connect(&self) -> RpcDispatchOutcome {
        RpcDispatchOutcome::bad_request("connect is only valid as the first request")
    }

    async fn handle_health(&self) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        if let Err(err) = self.sync_memory_runtime_from_config().await {
            self.system
                .log_line(format!("memory.runtime sync failed: {err}"))
                .await;
        }
        let now = now_ms();
        let summary = self.sessions.summary().await;
        let memory = self.memory.stats().await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "service": RUNTIME_NAME,
            "version": RUNTIME_VERSION,
            "ts": now,
            "uptimeMs": now.saturating_sub(self.started_at_ms),
            "sessions": summary,
            "memory": memory
        }))
    }

    async fn handle_status(&self) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        if let Err(err) = self.sync_memory_runtime_from_config().await {
            self.system
                .log_line(format!("memory.runtime sync failed: {err}"))
                .await;
        }
        let now = now_ms();
        let summary = self.sessions.summary().await;
        let memory = self.memory.stats().await;
        RpcDispatchOutcome::Handled(json!({
            "runtime": {
                "name": RUNTIME_NAME,
                "version": RUNTIME_VERSION,
                "startedAtMs": self.started_at_ms,
                "uptimeMs": now.saturating_sub(self.started_at_ms),
            },
            "sessions": summary,
            "memory": memory,
            "rpc": {
                "supportedMethods": SUPPORTED_RPC_METHODS,
                "count": SUPPORTED_RPC_METHODS.len()
            }
        }))
    }

    async fn handle_usage_status(&self) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let totals = self.sessions.usage_totals().await;
        RpcDispatchOutcome::Handled(json!({
            "enabled": true,
            "source": "rust-parity",
            "updatedAtMs": now_ms(),
            "totals": totals
        }))
    }

    async fn handle_usage_cost(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<UsageCostParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let totals = self.sessions.usage_totals().await;
        let range = normalize_usage_range(params.start_date, params.end_date, params.days);
        RpcDispatchOutcome::Handled(json!({
            "updatedAtMs": now_ms(),
            "range": range,
            "summary": {
                "totalCost": 0.0,
                "inputCost": 0.0,
                "outputCost": 0.0,
                "cacheReadCost": 0.0,
                "cacheWriteCost": 0.0,
                "missingCostEntries": 0
            },
            "tokens": {
                "total": totals.total_requests,
                "input": 0,
                "output": 0,
                "cacheRead": 0,
                "cacheWrite": 0
            },
            "actions": {
                "allow": totals.allowed_count,
                "review": totals.review_count,
                "block": totals.blocked_count
            }
        }))
    }

    async fn handle_last_heartbeat(&self) -> RpcDispatchOutcome {
        let heartbeat = self.system.last_heartbeat().await;
        RpcDispatchOutcome::Handled(json!(heartbeat))
    }

    async fn handle_set_heartbeats(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<SetHeartbeatsParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let Some(enabled) = params.enabled else {
            return RpcDispatchOutcome::bad_request(
                "invalid set-heartbeats params: enabled (boolean) required",
            );
        };
        self.system.set_heartbeats_enabled(enabled).await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "enabled": enabled
        }))
    }

    async fn handle_system_presence(&self) -> RpcDispatchOutcome {
        let presence = self.system.presence().await;
        RpcDispatchOutcome::Handled(json!(presence))
    }

    async fn handle_system_event(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<SystemEventParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let Some(text) = normalize_optional_text(params.text, 2_048) else {
            return RpcDispatchOutcome::bad_request("text required");
        };
        self.system
            .upsert_presence(SystemPresenceUpdate {
                text,
                device_id: normalize_optional_text(params.device_id, 128),
                instance_id: normalize_optional_text(params.instance_id, 128),
                host: normalize_optional_text(params.host, 256),
                ip: normalize_optional_text(params.ip, 64),
                mode: normalize_optional_text(params.mode, 64),
                version: normalize_optional_text(params.version, 64),
                platform: normalize_optional_text(params.platform, 64),
                device_family: normalize_optional_text(params.device_family, 64),
                model_identifier: normalize_optional_text(params.model_identifier, 64),
                last_input_seconds: normalize_optional_seconds(params.last_input_seconds),
                reason: normalize_optional_text(params.reason, 128),
                roles: normalize_string_list(params.roles, 64, 32),
                scopes: normalize_string_list(params.scopes, 64, 64),
                tags: normalize_string_list(params.tags, 64, 64),
            })
            .await;
        RpcDispatchOutcome::Handled(json!({ "ok": true }))
    }

    async fn handle_wake(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<WakeParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let mode = match parse_wake_mode(params.mode) {
            Ok(mode) => mode,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let Some(text) = normalize_optional_text(params.text, 2_048) else {
            return RpcDispatchOutcome::bad_request("invalid wake params: text required");
        };

        self.system
            .upsert_presence(SystemPresenceUpdate {
                text: text.clone(),
                device_id: None,
                instance_id: None,
                host: Some("gateway".to_owned()),
                ip: None,
                mode: Some(mode.to_owned()),
                version: Some(RUNTIME_VERSION.to_owned()),
                platform: None,
                device_family: None,
                model_identifier: None,
                last_input_seconds: None,
                reason: Some("wake".to_owned()),
                roles: Vec::new(),
                scopes: Vec::new(),
                tags: vec!["wake".to_owned()],
            })
            .await;
        if mode == "now" {
            self.system
                .update_last_heartbeat(json!({
                    "status": "wake-requested",
                    "reason": "wake",
                    "mode": mode,
                    "preview": text
                }))
                .await;
        }

        RpcDispatchOutcome::Handled(json!({ "ok": true }))
    }

    async fn handle_talk_config(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<TalkConfigParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let io_state = self.voice_io.snapshot().await;
        let mut talk = serde_json::Map::new();
        talk.insert("outputFormat".to_owned(), Value::String("pcm16".to_owned()));
        talk.insert("interruptOnSpeech".to_owned(), Value::Bool(true));
        talk.insert(
            "inputDevice".to_owned(),
            Value::String(io_state.input_device.clone()),
        );
        talk.insert(
            "outputDevice".to_owned(),
            Value::String(io_state.output_device.clone()),
        );
        talk.insert(
            "captureActive".to_owned(),
            Value::Bool(io_state.capture_active),
        );
        talk.insert(
            "playbackActive".to_owned(),
            Value::Bool(io_state.playback_active),
        );
        if params.include_secrets.unwrap_or(false) {
            talk.insert("apiKey".to_owned(), Value::String("redacted".to_owned()));
        }
        RpcDispatchOutcome::Handled(json!({
            "config": {
                "talk": Value::Object(talk),
                "session": { "mainKey": "main" },
                "ui": { "seamColor": "#4b5563" }
            },
            "audio": {
                "capture": {
                    "active": io_state.capture_active,
                    "sessionId": io_state.capture_session_id,
                    "startedAtMs": io_state.capture_started_at_ms,
                    "lastFrameAtMs": io_state.capture_last_frame_at_ms,
                    "frames": io_state.capture_frames
                },
                "playback": {
                    "active": io_state.playback_active,
                    "sessionId": io_state.playback_session_id,
                    "queueDepth": io_state.playback_queue_depth,
                    "outputDevice": io_state.output_device,
                    "lastAudioPath": io_state.playback_last_audio_path,
                    "lastProvider": io_state.playback_last_provider,
                    "lastStartedAtMs": io_state.playback_last_started_at_ms,
                    "lastCompletedAtMs": io_state.playback_last_completed_at_ms,
                    "lastDurationMs": io_state.playback_last_duration_ms
                }
            }
        }))
    }

    async fn handle_talk_mode(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<TalkModeParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let Some(enabled) = params.enabled else {
            return RpcDispatchOutcome::bad_request(
                "invalid talk.mode params: enabled (boolean) required",
            );
        };
        let phase = normalize_optional_text(params.phase, 64);
        let state = self.talk.set_mode(enabled, phase).await;
        let input_device = normalize_optional_text(params.input_device, 128);
        let output_device = normalize_optional_text(params.output_device, 128);
        let io_state = self
            .voice_io
            .set_capture_mode_and_devices(
                enabled,
                input_device.as_deref(),
                output_device.as_deref(),
            )
            .await;
        self.system
            .log_line(format!(
                "talk.mode enabled={} phase={} captureActive={} inputDevice={} outputDevice={}",
                state.enabled,
                state.phase.clone().unwrap_or_else(|| "null".to_owned()),
                io_state.capture_active,
                io_state.input_device,
                io_state.output_device
            ))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "enabled": state.enabled,
            "phase": state.phase,
            "ts": state.updated_at_ms,
            "inputDevice": io_state.input_device,
            "outputDevice": io_state.output_device,
            "capture": {
                "active": io_state.capture_active,
                "sessionId": io_state.capture_session_id,
                "startedAtMs": io_state.capture_started_at_ms,
                "lastFrameAtMs": io_state.capture_last_frame_at_ms,
                "frames": io_state.capture_frames
            }
        }))
    }

    async fn handle_tts_status(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = decode_params::<TtsStatusParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid tts.status params: {err}"));
        }
        let state = self.tts.snapshot().await;
        let config_snapshot = self.config.get_snapshot().await;
        let runtime_profile = runtime_feature_profile_from_config(&config_snapshot.config);
        let io_state = self.voice_io.snapshot().await;
        let has_openai_key = tts_provider_api_key("openai").is_some();
        let has_elevenlabs_key = tts_provider_api_key("elevenlabs").is_some();
        let has_kittentts_bin = kittentts_binary_available();
        let fallback_providers = tts_fallback_providers(&state.provider, runtime_profile);
        let fallback_provider = fallback_providers.first().cloned();
        RpcDispatchOutcome::Handled(json!({
            "enabled": state.enabled,
            "auto": state.auto_mode,
            "provider": state.provider,
            "runtimeProfile": runtime_profile.as_str(),
            "fallbackProvider": fallback_provider,
            "fallbackProviders": fallback_providers,
            "prefsPath": TTS_PREFS_PATH,
            "hasOpenAIKey": has_openai_key,
            "hasElevenLabsKey": has_elevenlabs_key,
            "hasKittenTtsBinary": has_kittentts_bin,
            "edgeEnabled": true,
            "offlineVoice": {
                "enabled": true,
                "lazyLoaded": true,
                "providers": ["kittentts", "edge"],
                "profile": runtime_profile.as_str(),
                "recommendedProvider": if matches!(runtime_profile, RuntimeFeatureProfile::Edge) { "kittentts" } else { "edge" },
                "kittenttsDefaultEnabled": matches!(runtime_profile, RuntimeFeatureProfile::Edge),
                "kittenttsAvailable": has_kittentts_bin
            },
            "capture": {
                "active": io_state.capture_active,
                "sessionId": io_state.capture_session_id,
                "startedAtMs": io_state.capture_started_at_ms,
                "lastFrameAtMs": io_state.capture_last_frame_at_ms,
                "frames": io_state.capture_frames
            },
            "playback": {
                "active": io_state.playback_active,
                "sessionId": io_state.playback_session_id,
                "queueDepth": io_state.playback_queue_depth,
                "outputDevice": io_state.output_device,
                "lastAudioPath": io_state.playback_last_audio_path,
                "lastProvider": io_state.playback_last_provider,
                "lastStartedAtMs": io_state.playback_last_started_at_ms,
                "lastCompletedAtMs": io_state.playback_last_completed_at_ms,
                "lastDurationMs": io_state.playback_last_duration_ms
            }
        }))
    }

    async fn handle_tts_enable(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = decode_params::<TtsToggleParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid tts.enable params: {err}"));
        }
        let state = self.tts.set_enabled(true).await;
        RpcDispatchOutcome::Handled(json!({
            "enabled": state.enabled
        }))
    }

    async fn handle_tts_disable(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = decode_params::<TtsToggleParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid tts.disable params: {err}"));
        }
        let state = self.tts.set_enabled(false).await;
        RpcDispatchOutcome::Handled(json!({
            "enabled": state.enabled
        }))
    }

    async fn handle_tts_convert(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<TtsConvertParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid tts.convert params: {err}"
                ));
            }
        };
        let Some(text) = normalize_optional_text(params.text, 16_000) else {
            return RpcDispatchOutcome::bad_request("tts.convert requires text");
        };
        let channel = normalize_optional_text(params.channel, 64).map(|value| normalize(&value));
        let output_device = normalize_optional_text(params.output_device, 128);
        let state = self.tts.snapshot().await;
        let config_snapshot = self.config.get_snapshot().await;
        let runtime_profile = runtime_feature_profile_from_config(&config_snapshot.config);
        let (output_format, extension, voice_compatible) = if channel.as_deref() == Some("telegram")
        {
            ("opus", ".opus", true)
        } else {
            ("mp3", ".mp3", false)
        };
        let text_chars = text.chars().count();
        let audio_path = next_tts_audio_path(extension);
        let audio_blob = synthesize_tts_audio_blob_with_provider(
            &text,
            output_format,
            &state.provider,
            runtime_profile,
        )
        .await;
        let audio_bytes = audio_blob.bytes;
        let audio_base64 = BASE64_STANDARD.encode(&audio_bytes);
        let io_state = self
            .voice_io
            .record_playback_with_output(
                &audio_path,
                &audio_blob.provider_used,
                audio_blob.duration_ms,
                output_device.as_deref(),
            )
            .await;
        self.system
            .log_line(format!(
                "tts.convert provider={} providerUsed={} source={} channel={} chars={} outputDevice={}",
                state.provider,
                audio_blob.provider_used,
                audio_blob.source,
                channel.unwrap_or_else(|| "default".to_owned()),
                text_chars,
                io_state.output_device
            ))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "audioPath": audio_path,
            "provider": state.provider,
            "runtimeProfile": runtime_profile.as_str(),
            "providerUsed": audio_blob.provider_used,
            "synthSource": audio_blob.source,
            "outputFormat": output_format,
            "voiceCompatible": voice_compatible,
            "audioBytes": audio_bytes.len(),
            "audioBase64": audio_base64,
            "durationMs": audio_blob.duration_ms,
            "sampleRateHz": audio_blob.sample_rate_hz,
            "channels": 1,
            "textChars": text_chars,
            "outputDevice": io_state.output_device,
            "playback": {
                "active": io_state.playback_active,
                "sessionId": io_state.playback_session_id,
                "queueDepth": io_state.playback_queue_depth,
                "lastAudioPath": io_state.playback_last_audio_path,
                "lastProvider": io_state.playback_last_provider,
                "lastStartedAtMs": io_state.playback_last_started_at_ms,
                "lastCompletedAtMs": io_state.playback_last_completed_at_ms,
                "lastDurationMs": io_state.playback_last_duration_ms,
                "outputDevice": io_state.output_device
            }
        }))
    }

    async fn handle_tts_set_provider(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<TtsSetProviderParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid tts.setProvider params: {err}"
                ));
            }
        };
        let provider = normalize_optional_text(params.provider, 32)
            .map(|value| normalize(&value))
            .unwrap_or_default();
        if !is_supported_tts_provider(&provider) {
            return RpcDispatchOutcome::bad_request(
                "Invalid provider. Use openai, elevenlabs, kittentts, or edge.",
            );
        }
        let state = self.tts.set_provider(provider.clone()).await;
        RpcDispatchOutcome::Handled(json!({
            "provider": state.provider
        }))
    }

    async fn handle_tts_providers(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = decode_params::<TtsProvidersParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid tts.providers params: {err}"));
        }
        let active = self.tts.snapshot().await.provider;
        let openai_configured = tts_provider_api_key("openai").is_some();
        let elevenlabs_configured = tts_provider_api_key("elevenlabs").is_some();
        let kittentts_configured = kittentts_binary_available();
        RpcDispatchOutcome::Handled(json!({
            "providers": [
                {
                    "id": "openai",
                    "name": "OpenAI",
                    "configured": openai_configured,
                    "models": TTS_OPENAI_MODELS,
                    "voices": TTS_OPENAI_VOICES
                },
                {
                    "id": "elevenlabs",
                    "name": "ElevenLabs",
                    "configured": elevenlabs_configured,
                    "models": TTS_ELEVENLABS_MODELS
                },
                {
                    "id": "kittentts",
                    "name": "KittenTTS (Offline)",
                    "configured": kittentts_configured,
                    "models": ["kitten-small", "kitten-base"],
                    "lazyLoaded": true
                },
                {
                    "id": "edge",
                    "name": "Edge TTS",
                    "configured": true,
                    "models": []
                }
            ],
            "active": active
        }))
    }

    async fn handle_voicewake_get(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = decode_params::<VoiceWakeGetParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid voicewake.get params: {err}"));
        }
        let state = self.voicewake.snapshot().await;
        let io_state = self.voice_io.snapshot().await;
        RpcDispatchOutcome::Handled(json!({
            "triggers": state.triggers,
            "capture": {
                "active": io_state.capture_active,
                "sessionId": io_state.capture_session_id,
                "startedAtMs": io_state.capture_started_at_ms,
                "lastFrameAtMs": io_state.capture_last_frame_at_ms,
                "frames": io_state.capture_frames
            }
        }))
    }

    async fn handle_voicewake_set(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<VoiceWakeSetParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid voicewake.set params: {err}"
                ));
            }
        };
        let Some(triggers_raw) = params.triggers else {
            return RpcDispatchOutcome::bad_request("voicewake.set requires triggers: string[]");
        };
        let Some(values) = triggers_raw.as_array() else {
            return RpcDispatchOutcome::bad_request("voicewake.set requires triggers: string[]");
        };
        let normalized = normalize_voicewake_triggers(values);
        let state = self.voicewake.set_triggers(normalized.clone()).await;
        let io_state = self.voice_io.touch_capture_frame().await;
        let payload_json = serde_json::to_string(&json!({ "triggers": normalized }))
            .ok()
            .filter(|value| !value.is_empty());
        self.node_runtime
            .record_event("voicewake.changed".to_owned(), payload_json)
            .await;
        self.system
            .log_line(format!(
                "voicewake.set triggers={} captureFrames={}",
                state.triggers.len(),
                io_state.capture_frames
            ))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "triggers": state.triggers,
            "capture": {
                "active": io_state.capture_active,
                "sessionId": io_state.capture_session_id,
                "startedAtMs": io_state.capture_started_at_ms,
                "lastFrameAtMs": io_state.capture_last_frame_at_ms,
                "frames": io_state.capture_frames
            }
        }))
    }

    async fn handle_models_list(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = decode_params::<ModelsListParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid models.list params: {err}"));
        }
        let snapshot = self.config.get_snapshot().await;
        RpcDispatchOutcome::Handled(json!({
            "models": self.models.resolve_catalog(Some(&snapshot.config))
        }))
    }

    async fn handle_agents_list(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = decode_params::<AgentsListParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid agents.list params: {err}"));
        }
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        let snapshot = self.agents.list().await;
        RpcDispatchOutcome::Handled(json!({
            "defaultId": snapshot.default_id,
            "mainKey": snapshot.main_key,
            "scope": snapshot.scope,
            "agents": snapshot.agents
        }))
    }

    async fn handle_agents_create(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<AgentsCreateParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid agents.create params: {err}"
                ));
            }
        };
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        let created = match self.agents.create(params.clone()).await {
            Ok(created) => created,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        if let Err(err) = self
            .persist_agent_create_to_config(
                &created,
                params.emoji.as_deref(),
                params.avatar.as_deref(),
            )
            .await
        {
            return RpcDispatchOutcome::internal_error(format!(
                "failed persisting agent config: {err}"
            ));
        }
        self.system
            .log_line(format!("agents.create id={}", created.agent_id))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "agentId": created.agent_id,
            "name": created.name,
            "workspace": created.workspace
        }))
    }

    async fn handle_agents_update(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<AgentsUpdateParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid agents.update params: {err}"
                ));
            }
        };
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        let agent_id = match self.agents.update(params.clone()).await {
            Ok(agent_id) => agent_id,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        if let Err(err) = self.persist_agent_update_to_config(&params).await {
            return RpcDispatchOutcome::internal_error(format!(
                "failed persisting agent config: {err}"
            ));
        }
        self.system
            .log_line(format!("agents.update id={agent_id}"))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "agentId": agent_id
        }))
    }

    async fn handle_agents_delete(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<AgentsDeleteParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid agents.delete params: {err}"
                ));
            }
        };
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        let mut removed = match self.agents.delete(params).await {
            Ok(removed) => removed,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let removed_bindings = match self.persist_agent_delete_to_config(&removed.agent_id).await {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::internal_error(format!(
                    "failed persisting agent config: {err}"
                ));
            }
        };
        removed.removed_bindings = removed_bindings;
        self.system
            .log_line(format!("agents.delete id={}", removed.agent_id))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "agentId": removed.agent_id,
            "removedBindings": removed.removed_bindings
        }))
    }

    async fn handle_agents_files_list(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<AgentsFilesListParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid agents.files.list params: {err}"
                ));
            }
        };
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        let (agent_id, workspace, files) = match self.agents.list_files(params).await {
            Ok(result) => result,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        RpcDispatchOutcome::Handled(json!({
            "agentId": agent_id,
            "workspace": workspace,
            "files": files
        }))
    }

    async fn handle_agents_files_get(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<AgentsFilesGetParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid agents.files.get params: {err}"
                ));
            }
        };
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        let (agent_id, workspace, file) = match self.agents.get_file(params).await {
            Ok(result) => result,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        RpcDispatchOutcome::Handled(json!({
            "agentId": agent_id,
            "workspace": workspace,
            "file": file
        }))
    }

    async fn handle_agents_files_set(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<AgentsFilesSetParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid agents.files.set params: {err}"
                ));
            }
        };
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        let (agent_id, workspace, file) = match self.agents.set_file(params).await {
            Ok(result) => result,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        self.system
            .log_line(format!("agents.files.set id={agent_id} name={}", file.name))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "agentId": agent_id,
            "workspace": workspace,
            "file": file
        }))
    }

    async fn handle_agent(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        if let Err(err) = self.sync_memory_runtime_from_config().await {
            self.system
                .log_line(format!("memory.runtime sync failed: {err}"))
                .await;
        }
        let params = match decode_params::<AgentParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!("invalid agent params: {err}"))
            }
        };
        let _ = (
            params.agent_id.as_deref(),
            params.session_id.as_deref(),
            params.thinking.as_deref(),
            params.deliver,
            params.thread_id.as_deref(),
            params.group_id.as_deref(),
            params.group_channel.as_deref(),
            params.group_space.as_deref(),
            params.timeout,
            params.lane.as_deref(),
            params.extra_system_prompt.as_deref(),
            params.input_provenance.as_ref(),
            params.label.as_deref(),
            params.spawned_by.as_deref(),
        );
        let Some(run_id) = normalize_optional_text(Some(params.idempotency_key), 256) else {
            return RpcDispatchOutcome::bad_request(
                "invalid agent params: idempotencyKey is required",
            );
        };
        match self.agent_runs.start_run(&run_id).await {
            AgentRunStartOutcome::InFlight => {
                return RpcDispatchOutcome::Handled(json!({
                    "runId": run_id,
                    "status": "in_flight"
                }));
            }
            AgentRunStartOutcome::Completed => {
                return RpcDispatchOutcome::Handled(json!({
                    "runId": run_id,
                    "status": "ok"
                }));
            }
            AgentRunStartOutcome::Started => {}
        }
        let session_key = normalize_optional_text(params.session_key, 512)
            .map(|value| canonicalize_session_key(&value))
            .filter(|value| !value.is_empty())
            .unwrap_or_else(|| canonicalize_session_key(DEFAULT_MAIN_KEY));
        if session_key.is_empty() {
            return RpcDispatchOutcome::bad_request("invalid agent params: sessionKey is required");
        }
        let sanitized_message = match sanitize_chat_send_message_input(&params.message) {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let has_attachments = params
            .attachments
            .as_ref()
            .map(|value| !value.is_empty())
            .unwrap_or(false);
        let message = normalize_optional_text(Some(sanitized_message.clone()), 12_000);
        if message.is_none() && !has_attachments {
            return RpcDispatchOutcome::bad_request("invalid agent params: message is required");
        }
        let reset_command = if has_attachments {
            None
        } else {
            parse_agent_reset_command(&sanitized_message)
        };
        let channel = normalize_optional_text(params.reply_channel.or(params.channel), 128);
        let to = normalize_optional_text(params.reply_to.or(params.to), 256);
        let account_id =
            normalize_optional_text(params.reply_account_id.or(params.account_id), 128);
        let thread_id = normalize_optional_text(params.thread_id, 128);
        let mut reset_payload = None;
        let stored_message = if let Some((reason, followup_message)) = reset_command {
            let reset = self.sessions.reset(&session_key, reason.to_owned()).await;
            reset_payload = Some(json!({
                "key": session_key.clone(),
                "reason": reason,
                "sessionId": reset.session.session_id
            }));
            followup_message.and_then(|value| normalize_optional_text(Some(value), 12_000))
        } else {
            message
        }
        .or_else(|| has_attachments.then(|| "[attachment]".to_owned()));
        let memory_query_text = stored_message.clone();
        let resolved_session_key = session_key.clone();
        let _ = self
            .refresh_session_auth_profile(&resolved_session_key)
            .await;
        if stored_message.is_some() {
            let _ = self
                .sessions
                .record_send(SessionSend {
                    session_key: session_key.clone(),
                    request_id: Some(run_id.clone()),
                    message: stored_message,
                    command: None,
                    source: "agent".to_owned(),
                    channel,
                    to,
                    account_id,
                    thread_id,
                    reply_back: None,
                })
                .await;
        }
        if let Some(memory_text) = memory_query_text.clone() {
            if !memory_text.eq_ignore_ascii_case("[attachment]") {
                let _ = self
                    .memory
                    .remember(MemoryRememberInput {
                        session_key: resolved_session_key.clone(),
                        source: "agent.user".to_owned(),
                        text: memory_text,
                        request_id: Some(run_id.clone()),
                        at_ms: None,
                    })
                    .await;
            }
        }
        let resolved = self
            .resolve_session_model_failover(&resolved_session_key)
            .await;
        let mut runtime_payload = AgentRuntimeExecutionView {
            executed: false,
            provider: resolved.model_provider.clone(),
            model: resolved.model.clone(),
            api_mode: None,
            tool_calls: None,
            loop_steps: None,
            memory_hits: None,
            memory_graph_facts: None,
            self_healing: None,
            reason: Some("provider credentials not configured".to_owned()),
        };
        let mut run_completed = false;

        let config_snapshot = self.config.get_snapshot().await;
        let provider_runtime =
            resolve_provider_runtime_config(&config_snapshot.config, &resolved.model_provider);
        if let Some(provider_runtime) = provider_runtime {
            runtime_payload.api_mode = Some(provider_runtime.api_mode.clone());
            runtime_payload.reason = None;
            if provider_runtime.api_key.is_none() && !provider_runtime.allow_missing_api_key {
                runtime_payload.reason = Some("provider credentials not configured".to_owned());
            } else if !provider_api_mode_supported(&provider_runtime.api_mode) {
                runtime_payload.reason = Some(format!(
                    "provider api mode {} is not supported",
                    provider_runtime.api_mode
                ));
            } else {
                let agent_id_for_runtime = params
                    .agent_id
                    .as_deref()
                    .and_then(|value| normalize_optional_text(Some(value.to_owned()), 64))
                    .map(|value| normalize_agent_id(&value))
                    .or_else(|| resolve_agent_id_from_session_key_input(&resolved_session_key).ok())
                    .unwrap_or_else(|| DEFAULT_AGENT_ID.to_owned());
                let workspace_root = self
                    .agents
                    .workspace_for(&agent_id_for_runtime)
                    .await
                    .map(|workspace| {
                        resolve_tool_workspace_root_path(&workspace, &agent_id_for_runtime)
                    })
                    .unwrap_or_else(|| {
                        resolve_tool_workspace_root_path(
                            DEFAULT_AGENT_WORKSPACE,
                            &agent_id_for_runtime,
                        )
                    });
                match self
                    .execute_agent_runtime_turn(AgentRuntimeTurnRequest {
                        session_key: resolved_session_key.clone(),
                        run_id: run_id.clone(),
                        resolved: resolved.clone(),
                        provider_runtime: provider_runtime.clone(),
                        extra_system_prompt: params.extra_system_prompt.clone(),
                        memory_query_text: memory_query_text.clone(),
                        workspace_root: workspace_root.clone(),
                        config: config_snapshot.config.clone(),
                    })
                    .await
                {
                    Ok(outcome) => {
                        runtime_payload = outcome.execution;
                        if let Some(assistant_text) = outcome.assistant_text {
                            let assistant_memory_text = assistant_text.clone();
                            let _ = self
                                .sessions
                                .record_send(SessionSend {
                                    session_key: resolved_session_key.clone(),
                                    request_id: Some(run_id.clone()),
                                    message: Some(assistant_text),
                                    command: None,
                                    source: "agent.assistant".to_owned(),
                                    channel: Some("webchat".to_owned()),
                                    to: None,
                                    account_id: None,
                                    thread_id: None,
                                    reply_back: None,
                                })
                                .await;
                            let _ = self
                                .memory
                                .remember(MemoryRememberInput {
                                    session_key: resolved_session_key.clone(),
                                    source: "agent.assistant".to_owned(),
                                    text: assistant_memory_text,
                                    request_id: Some(run_id.clone()),
                                    at_ms: None,
                                })
                                .await;
                        }
                        self.agent_runs.complete_ok(run_id.clone()).await;
                        run_completed = true;
                    }
                    Err(err) => {
                        let catalog = self.models.resolve_catalog(Some(&config_snapshot.config));
                        let self_healing_runtime =
                            agent_self_healing_runtime_config_from_config(&config_snapshot.config);
                        let self_heal_profile = self_healing_runtime.profile.as_str().to_owned();
                        let mut final_error = err.clone();
                        let mut healing_attempts: Vec<AgentRuntimeSelfHealingAttemptView> =
                            Vec::new();
                        let mut recovered = false;
                        let mut attempted_providers: Vec<String> = Vec::new();
                        let mut tried_count = 0usize;

                        if self_healing_runtime.enabled && self_healing_runtime.max_attempts > 0 {
                            for fallback_provider_raw in &resolved.fallback_providers {
                                if tried_count >= self_healing_runtime.max_attempts {
                                    break;
                                }
                                let fallback_provider =
                                    normalize_provider_id(fallback_provider_raw);
                                if fallback_provider.eq_ignore_ascii_case(&resolved.model_provider)
                                {
                                    continue;
                                }
                                if attempted_providers.iter().any(|existing| {
                                    existing.eq_ignore_ascii_case(&fallback_provider)
                                }) {
                                    continue;
                                }

                                if tried_count > 0 && self_healing_runtime.backoff_ms > 0 {
                                    tokio::time::sleep(Duration::from_millis(
                                        self_healing_runtime.backoff_ms,
                                    ))
                                    .await;
                                }
                                attempted_providers.push(fallback_provider.clone());
                                tried_count = tried_count.saturating_add(1);

                                let fallback_model =
                                    ModelRegistry::default_model_for_provider_in_catalog(
                                        &catalog,
                                        &fallback_provider,
                                    )
                                    .map(|entry| entry.id)
                                    .unwrap_or_else(|| resolved.model.clone());

                                let Some(fallback_runtime) = resolve_provider_runtime_config(
                                    &config_snapshot.config,
                                    &fallback_provider,
                                ) else {
                                    healing_attempts.push(AgentRuntimeSelfHealingAttemptView {
                                        provider: fallback_provider.clone(),
                                        model: fallback_model,
                                        status: "skipped".to_owned(),
                                        reason: Some("provider_not_configured".to_owned()),
                                    });
                                    continue;
                                };

                                if fallback_runtime.api_key.is_none()
                                    && !fallback_runtime.allow_missing_api_key
                                {
                                    healing_attempts.push(AgentRuntimeSelfHealingAttemptView {
                                        provider: fallback_provider.clone(),
                                        model: fallback_model,
                                        status: "skipped".to_owned(),
                                        reason: Some("credentials_missing".to_owned()),
                                    });
                                    continue;
                                }
                                if !provider_api_mode_supported(&fallback_runtime.api_mode) {
                                    healing_attempts.push(AgentRuntimeSelfHealingAttemptView {
                                        provider: fallback_provider.clone(),
                                        model: fallback_model,
                                        status: "skipped".to_owned(),
                                        reason: Some(format!(
                                            "unsupported_api_mode:{}",
                                            fallback_runtime.api_mode
                                        )),
                                    });
                                    continue;
                                }

                                let fallback_resolved = ModelFailoverResolutionView {
                                    model_provider: fallback_provider.clone(),
                                    model: fallback_model.clone(),
                                    auth_profile: resolved.auth_profile.clone(),
                                    fallback_providers: model_provider_failover_chain(
                                        &fallback_provider,
                                    ),
                                    attempts: vec![ModelFailoverAttemptView {
                                        provider: fallback_provider.clone(),
                                        model: fallback_model.clone(),
                                        auth_profile: resolved.auth_profile.clone(),
                                        status: "ok".to_owned(),
                                        reason: Some("self_heal_retry".to_owned()),
                                    }],
                                };

                                match self
                                    .execute_agent_runtime_turn(AgentRuntimeTurnRequest {
                                        session_key: resolved_session_key.clone(),
                                        run_id: run_id.clone(),
                                        resolved: fallback_resolved,
                                        provider_runtime: fallback_runtime,
                                        extra_system_prompt: params.extra_system_prompt.clone(),
                                        memory_query_text: memory_query_text.clone(),
                                        workspace_root: workspace_root.clone(),
                                        config: config_snapshot.config.clone(),
                                    })
                                    .await
                                {
                                    Ok(outcome) => {
                                        healing_attempts.push(AgentRuntimeSelfHealingAttemptView {
                                            provider: fallback_provider.clone(),
                                            model: fallback_model,
                                            status: "recovered".to_owned(),
                                            reason: Some("runtime_retry_succeeded".to_owned()),
                                        });
                                        recovered = true;
                                        runtime_payload = outcome.execution;
                                        runtime_payload.self_healing =
                                            Some(AgentRuntimeSelfHealingView {
                                                enabled: true,
                                                recovered: true,
                                                profile: Some(self_heal_profile.clone()),
                                                max_attempts: Some(
                                                    self_healing_runtime.max_attempts,
                                                ),
                                                backoff_ms: Some(self_healing_runtime.backoff_ms),
                                                attempts: healing_attempts.clone(),
                                            });
                                        runtime_payload.reason = None;

                                        if let Some(assistant_text) = outcome.assistant_text {
                                            let assistant_memory_text = assistant_text.clone();
                                            let _ = self
                                                .sessions
                                                .record_send(SessionSend {
                                                    session_key: resolved_session_key.clone(),
                                                    request_id: Some(run_id.clone()),
                                                    message: Some(assistant_text),
                                                    command: None,
                                                    source: "agent.assistant".to_owned(),
                                                    channel: Some("webchat".to_owned()),
                                                    to: None,
                                                    account_id: None,
                                                    thread_id: None,
                                                    reply_back: None,
                                                })
                                                .await;
                                            let _ = self
                                                .memory
                                                .remember(MemoryRememberInput {
                                                    session_key: resolved_session_key.clone(),
                                                    source: "agent.assistant".to_owned(),
                                                    text: assistant_memory_text,
                                                    request_id: Some(run_id.clone()),
                                                    at_ms: None,
                                                })
                                                .await;
                                        }
                                        self.system
                                            .log_line(format!(
                                                "agent.self_heal recovered runId={} provider={} model={} profile={} maxAttempts={} backoffMs={}",
                                                run_id,
                                                runtime_payload.provider,
                                                runtime_payload.model,
                                                self_heal_profile.as_str(),
                                                self_healing_runtime.max_attempts,
                                                self_healing_runtime.backoff_ms
                                            ))
                                            .await;
                                        self.agent_runs.complete_ok(run_id.clone()).await;
                                        run_completed = true;
                                        break;
                                    }
                                    Err(retry_err) => {
                                        final_error = retry_err.clone();
                                        healing_attempts.push(AgentRuntimeSelfHealingAttemptView {
                                            provider: fallback_provider.clone(),
                                            model: fallback_model,
                                            status: "failed".to_owned(),
                                            reason: Some(truncate_text(&retry_err, 160)),
                                        });
                                    }
                                }
                            }
                        }

                        if !recovered {
                            runtime_payload.reason = Some(final_error.clone());
                            runtime_payload.self_healing = Some(AgentRuntimeSelfHealingView {
                                enabled: self_healing_runtime.enabled,
                                recovered: false,
                                profile: Some(self_heal_profile),
                                max_attempts: Some(self_healing_runtime.max_attempts),
                                backoff_ms: Some(self_healing_runtime.backoff_ms),
                                attempts: healing_attempts,
                            });
                            self.agent_runs
                                .complete_error(run_id.clone(), final_error)
                                .await;
                            run_completed = true;
                        }
                    }
                }
            }
        } else {
            runtime_payload.reason = Some("provider is not configured".to_owned());
        }

        if !run_completed {
            let agent_runs = self.agent_runs.clone();
            let complete_run_id = run_id.clone();
            tokio::spawn(async move {
                tokio::time::sleep(Duration::from_millis(AGENT_RUN_COMPLETE_DELAY_MS)).await;
                agent_runs.complete_ok(complete_run_id).await;
            });
        }
        let mut payload = json!({
            "runId": run_id,
            "status": "started",
            "resolved": resolved,
            "runtime": runtime_payload
        });
        if let Some(reset) = reset_payload {
            payload["reset"] = reset;
        }
        RpcDispatchOutcome::Handled(payload)
    }

    async fn handle_agent_identity_get(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        let params = match decode_params::<AgentIdentityParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid agent.identity.get params: {err}"
                ));
            }
        };
        let explicit_agent_id = params
            .agent_id
            .and_then(|value| normalize_optional_text(Some(value), 64))
            .map(|value| normalize_agent_id(&value));
        let session_agent_id = match params
            .session_key
            .and_then(|value| normalize_optional_text(Some(value), 512))
        {
            Some(session_key) => match resolve_agent_id_from_session_key_input(&session_key) {
                Ok(agent_id) => Some(agent_id),
                Err(err) => return RpcDispatchOutcome::bad_request(err),
            },
            None => None,
        };
        if let (Some(explicit), Some(from_session)) = (&explicit_agent_id, &session_agent_id) {
            if !explicit.eq_ignore_ascii_case(from_session) {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid agent.identity.get params: agent \"{explicit}\" does not match session key agent \"{from_session}\""
                ));
            }
        }
        let identity = match self
            .agents
            .identity(explicit_agent_id.or(session_agent_id))
            .await
        {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        RpcDispatchOutcome::Handled(json!(identity))
    }

    async fn handle_agent_wait(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<AgentWaitParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid agent.wait params: {err}"
                ));
            }
        };
        let run_id = match normalize_optional_text(Some(params.run_id), 256) {
            Some(value) => value,
            None => {
                return RpcDispatchOutcome::bad_request(
                    "invalid agent.wait params: runId is required",
                );
            }
        };
        let timeout_ms = params.timeout_ms.unwrap_or(30_000);
        let snapshot = self.agent_runs.wait(&run_id, timeout_ms).await;
        if let Some(snapshot) = snapshot {
            return RpcDispatchOutcome::Handled(json!({
                "runId": run_id,
                "status": snapshot.status,
                "startedAt": snapshot.started_at,
                "endedAt": snapshot.ended_at,
                "error": snapshot.error
            }));
        }
        RpcDispatchOutcome::Handled(json!({
            "runId": run_id,
            "status": "timeout"
        }))
    }

    async fn handle_skills_status(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("agents runtime unavailable");
        }
        let params = match decode_params::<SkillsStatusParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid skills.status params: {err}"
                ));
            }
        };
        let requested_agent = normalize_optional_text(params.agent_id, 64);
        let agent_id = match requested_agent {
            Some(raw) => {
                if !self.agents.contains(&raw).await {
                    return RpcDispatchOutcome::bad_request(format!("unknown agent id \"{raw}\""));
                }
                normalize_agent_id(&raw)
            }
            None => DEFAULT_AGENT_ID.to_owned(),
        };
        let workspace = self
            .agents
            .workspace_for(&agent_id)
            .await
            .unwrap_or_else(|| DEFAULT_AGENT_WORKSPACE.to_owned());
        let report = self.skills.status(&workspace, &agent_id).await;
        RpcDispatchOutcome::Handled(json!(report))
    }

    async fn handle_skills_bins(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = decode_params::<SkillsBinsParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid skills.bins params: {err}"));
        }
        let bins = self.skills.bins().await;
        RpcDispatchOutcome::Handled(json!({
            "bins": bins
        }))
    }

    async fn handle_skills_install(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<SkillsInstallParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid skills.install params: {err}"
                ));
            }
        };
        if matches!(params.timeout_ms, Some(timeout_ms) if timeout_ms < 1_000) {
            return RpcDispatchOutcome::bad_request(
                "invalid skills.install params: timeoutMs must be >= 1000",
            );
        }
        let result = self.skills.install(params).await;
        self.system
            .log_line(format!(
                "skills.install skillKey={} installId={}",
                result.skill_key, result.install_id
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(result))
    }

    async fn handle_skills_update(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<SkillsUpdateParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid skills.update params: {err}"
                ));
            }
        };
        let result = match self.skills.update(params).await {
            Ok(result) => result,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        self.system
            .log_line(format!("skills.update skillKey={}", result.skill_key))
            .await;
        RpcDispatchOutcome::Handled(json!(result))
    }

    async fn handle_cron_list(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_cron_runtime_from_config().await {
            return RpcDispatchOutcome::bad_request(err);
        }
        let params = match decode_params::<CronListParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!("invalid cron.list params: {err}"));
            }
        };
        let jobs = self
            .cron
            .list(params.include_disabled.unwrap_or(false))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "jobs": jobs
        }))
    }

    async fn handle_cron_status(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_cron_runtime_from_config().await {
            return RpcDispatchOutcome::bad_request(err);
        }
        if let Err(err) = decode_params::<CronStatusParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid cron.status params: {err}"));
        }
        let status = self.cron.status().await;
        RpcDispatchOutcome::Handled(json!(status))
    }

    async fn handle_cron_add(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_cron_runtime_from_config().await {
            return RpcDispatchOutcome::bad_request(err);
        }
        let params = match decode_params::<CronAddParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!("invalid cron.add params: {err}"));
            }
        };
        let job = match self.cron.add(params).await {
            Ok(job) => job,
            Err(CronRegistryError::NotFound(message)) => {
                return RpcDispatchOutcome::not_found(message)
            }
            Err(CronRegistryError::Invalid(message)) => {
                return RpcDispatchOutcome::bad_request(message);
            }
        };
        self.system
            .log_line(format!("cron.add id={} name={}", job.id, job.name))
            .await;
        RpcDispatchOutcome::Handled(json!(job))
    }

    async fn handle_cron_update(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_cron_runtime_from_config().await {
            return RpcDispatchOutcome::bad_request(err);
        }
        let params = match decode_params::<CronUpdateParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid cron.update params: {err}"
                ));
            }
        };
        let job_id = match resolve_cron_job_id(params.id, params.job_id, "cron.update") {
            Ok(id) => id,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let job = match self.cron.update(&job_id, params.patch).await {
            Ok(job) => job,
            Err(CronRegistryError::NotFound(message)) => {
                return RpcDispatchOutcome::not_found(message)
            }
            Err(CronRegistryError::Invalid(message)) => {
                return RpcDispatchOutcome::bad_request(message);
            }
        };
        self.system
            .log_line(format!("cron.update id={job_id}"))
            .await;
        RpcDispatchOutcome::Handled(json!(job))
    }

    async fn handle_cron_remove(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_cron_runtime_from_config().await {
            return RpcDispatchOutcome::bad_request(err);
        }
        let params = match decode_params::<CronRemoveParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid cron.remove params: {err}"
                ));
            }
        };
        let job_id = match resolve_cron_job_id(params.id, params.job_id, "cron.remove") {
            Ok(id) => id,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let removed = match self.cron.remove(&job_id).await {
            Ok(removed) => removed,
            Err(CronRegistryError::NotFound(message)) => {
                return RpcDispatchOutcome::not_found(message)
            }
            Err(CronRegistryError::Invalid(message)) => {
                return RpcDispatchOutcome::bad_request(message);
            }
        };
        self.system
            .log_line(format!("cron.remove id={job_id}"))
            .await;
        RpcDispatchOutcome::Handled(json!(removed))
    }

    async fn handle_cron_run(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_cron_runtime_from_config().await {
            return RpcDispatchOutcome::bad_request(err);
        }
        let params = match decode_params::<CronRunParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!("invalid cron.run params: {err}"));
            }
        };
        let job_id = match resolve_cron_job_id(params.id, params.job_id, "cron.run") {
            Ok(id) => id,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let mode = match parse_cron_run_mode(params.mode) {
            Ok(mode) => mode,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let run = match self.cron.run(&job_id, mode).await {
            Ok(run) => run,
            Err(CronRegistryError::NotFound(message)) => {
                return RpcDispatchOutcome::not_found(message)
            }
            Err(CronRegistryError::Invalid(message)) => {
                return RpcDispatchOutcome::bad_request(message);
            }
        };
        self.apply_cron_execution_side_effects(&run, mode).await;
        RpcDispatchOutcome::Handled(json!(run.entry))
    }

    async fn handle_cron_runs(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_cron_runtime_from_config().await {
            return RpcDispatchOutcome::bad_request(err);
        }
        let params = match decode_params::<CronRunsParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!("invalid cron.runs params: {err}"));
            }
        };
        let job_id = match resolve_cron_job_id(params.id, params.job_id, "cron.runs") {
            Ok(id) => id,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let limit = params.limit.unwrap_or(50).clamp(1, 5_000);
        let entries = match self.cron.runs(&job_id, limit).await {
            Ok(entries) => entries,
            Err(CronRegistryError::NotFound(message)) => {
                return RpcDispatchOutcome::not_found(message)
            }
            Err(CronRegistryError::Invalid(message)) => {
                return RpcDispatchOutcome::bad_request(message);
            }
        };
        RpcDispatchOutcome::Handled(json!({
            "entries": entries
        }))
    }

    async fn handle_channels_status(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_channel_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "channel runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<ChannelsStatusParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let probe = params.probe.unwrap_or(false);
        let timeout_ms = params.timeout_ms.unwrap_or(10_000).max(1_000);

        let mut channel_order = Vec::new();
        let mut channel_labels = serde_json::Map::new();
        let mut channel_detail_labels = serde_json::Map::new();
        let mut channel_system_images = serde_json::Map::new();
        let mut channel_meta = Vec::new();
        let mut channels = serde_json::Map::new();
        let mut channel_accounts = serde_json::Map::new();
        let mut channel_default_account_id = serde_json::Map::new();

        for capability in &self.channel_capabilities {
            let id = capability.name.to_owned();
            let label = channel_label(capability.name);
            let system_image = channel_system_image(capability.name).to_owned();
            channel_order.push(id.clone());
            channel_labels.insert(id.clone(), Value::String(label.clone()));
            channel_detail_labels.insert(id.clone(), Value::String(label.clone()));
            channel_system_images.insert(id.clone(), Value::String(system_image.clone()));
            channel_meta.push(json!({
                "id": id,
                "label": label,
                "detailLabel": label,
                "systemImage": system_image
            }));
            let mut runtime_accounts = self.channel_runtime.accounts_for_channel(&id).await;
            if runtime_accounts.is_empty() {
                runtime_accounts.push(("default".to_owned(), ChannelAccountRuntime::default()));
            }
            let hinted_default_account_id =
                self.channel_runtime.default_account_for_channel(&id).await;
            let default_account_id = resolve_default_account_id(
                runtime_accounts.as_slice(),
                hinted_default_account_id.as_deref(),
            );
            runtime_accounts.sort_by(|(left_id, _), (right_id, _)| {
                let left_default = left_id.eq_ignore_ascii_case(&default_account_id);
                let right_default = right_id.eq_ignore_ascii_case(&default_account_id);
                match (left_default, right_default) {
                    (true, false) => std::cmp::Ordering::Less,
                    (false, true) => std::cmp::Ordering::Greater,
                    _ => left_id.cmp(right_id),
                }
            });

            let mut default_snapshot = ChannelAccountRuntime::default();
            let mut accounts_payload = Vec::new();
            for (account_id, snapshot) in runtime_accounts {
                if account_id.eq_ignore_ascii_case(&default_account_id) {
                    default_snapshot = snapshot.clone();
                }
                let mut account = json!({
                    "accountId": account_id,
                    "name": snapshot.name.clone().unwrap_or_else(|| account_id.clone()),
                    "enabled": snapshot.enabled.unwrap_or(true),
                    "configured": snapshot.configured.unwrap_or(false),
                    "linked": snapshot.linked.unwrap_or(false),
                    "running": snapshot.running.unwrap_or(false),
                    "connected": snapshot.connected.unwrap_or(false),
                    "mode": snapshot.mode.clone().unwrap_or_else(|| "polling".to_owned())
                });
                if let Some(reconnect_attempts) = snapshot.reconnect_attempts {
                    account["reconnectAttempts"] = json!(reconnect_attempts);
                }
                if let Some(last_connected_at) = snapshot.last_connected_at {
                    account["lastConnectedAt"] = json!(last_connected_at);
                }
                if let Some(last_error) = snapshot.last_error.clone() {
                    account["lastError"] = json!(last_error);
                }
                if let Some(last_start_at) = snapshot.last_start_at {
                    account["lastStartAt"] = json!(last_start_at);
                }
                if let Some(last_stop_at) = snapshot.last_stop_at {
                    account["lastStopAt"] = json!(last_stop_at);
                }
                if let Some(last_inbound_at) = snapshot.last_inbound_at {
                    account["lastInboundAt"] = json!(last_inbound_at);
                }
                if let Some(last_outbound_at) = snapshot.last_outbound_at {
                    account["lastOutboundAt"] = json!(last_outbound_at);
                }
                if let Some(last_reaction_at) = snapshot.last_reaction_at {
                    account["lastReactionAt"] = json!(last_reaction_at);
                }
                if let Some(last_edit_at) = snapshot.last_edit_at {
                    account["lastEditAt"] = json!(last_edit_at);
                }
                if let Some(last_delete_at) = snapshot.last_delete_at {
                    account["lastDeleteAt"] = json!(last_delete_at);
                }
                if let Some(last_thread_at) = snapshot.last_thread_at {
                    account["lastThreadAt"] = json!(last_thread_at);
                }
                if probe {
                    account["lastProbeAt"] = json!(now_ms());
                } else if let Some(last_probe_at) = snapshot.last_probe_at {
                    account["lastProbeAt"] = json!(last_probe_at);
                } else {
                    account["lastProbeAt"] = Value::Null;
                }
                if let Some(dm_policy) = snapshot.dm_policy.clone() {
                    account["dmPolicy"] = json!(dm_policy);
                }
                if let Some(allow_from) = snapshot.allow_from.clone() {
                    account["allowFrom"] = json!(allow_from);
                }
                if let Some(token_source) = snapshot.token_source.clone() {
                    account["tokenSource"] = json!(token_source);
                }
                if let Some(bot_token_source) = snapshot.bot_token_source.clone() {
                    account["botTokenSource"] = json!(bot_token_source);
                }
                if let Some(app_token_source) = snapshot.app_token_source.clone() {
                    account["appTokenSource"] = json!(app_token_source);
                }
                if let Some(base_url) = snapshot.base_url.clone() {
                    account["baseUrl"] = json!(base_url);
                }
                if let Some(allow_unmentioned_groups) = snapshot.allow_unmentioned_groups {
                    account["allowUnmentionedGroups"] = json!(allow_unmentioned_groups);
                }
                if let Some(cli_path) = snapshot.cli_path.clone() {
                    account["cliPath"] = cli_path;
                }
                if let Some(db_path) = snapshot.db_path.clone() {
                    account["dbPath"] = db_path;
                }
                if let Some(port) = snapshot.port {
                    account["port"] = json!(port);
                }
                if let Some(application) = snapshot.application.clone() {
                    account["application"] = application;
                }
                if let Some(audit) = snapshot.audit.clone() {
                    account["audit"] = audit;
                }
                if probe {
                    account["probe"] = json!({
                        "ok": true,
                        "source": "rust-parity",
                        "timeoutMs": timeout_ms
                    });
                } else if let Some(probe_payload) = snapshot.probe.clone() {
                    account["probe"] = probe_payload;
                }
                accounts_payload.push(account);
            }

            let mut channel_summary = json!({
                "configured": default_snapshot.configured.unwrap_or(false),
                "enabled": default_snapshot.enabled.unwrap_or(true),
                "linked": default_snapshot.linked.unwrap_or(false),
                "running": default_snapshot.running.unwrap_or(false),
                "connected": default_snapshot.connected.unwrap_or(false),
                "supports": {
                    "edit": capability.supports_edit,
                    "delete": capability.supports_delete,
                    "reactions": capability.supports_reactions,
                    "threads": capability.supports_threads,
                    "polls": capability.supports_polls,
                    "media": capability.supports_media,
                    "dmPairing": capability.default_dm_pairing
                }
            });
            if probe {
                channel_summary["lastProbeAt"] = json!(now_ms());
                channel_summary["probe"] = json!({
                    "ok": true,
                    "source": "rust-parity",
                    "timeoutMs": timeout_ms
                });
            } else {
                channel_summary["lastProbeAt"] = Value::Null;
            }
            channels.insert(id.clone(), channel_summary);
            channel_accounts.insert(id.clone(), Value::Array(accounts_payload));
            channel_default_account_id.insert(id, Value::String(default_account_id));
        }

        RpcDispatchOutcome::Handled(json!({
            "ts": now_ms(),
            "channelOrder": channel_order,
            "channelLabels": channel_labels,
            "channelDetailLabels": channel_detail_labels,
            "channelSystemImages": channel_system_images,
            "channelMeta": channel_meta,
            "channels": channels,
            "channelAccounts": channel_accounts,
            "channelDefaultAccountId": channel_default_account_id
        }))
    }

    async fn handle_channels_logout(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_channel_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "channel runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<ChannelsLogoutParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let Some(raw_channel) = normalize_optional_text(params.channel, 64) else {
            return RpcDispatchOutcome::bad_request("invalid channels.logout channel");
        };
        let channel = normalize_channel_id(Some(raw_channel.as_str()))
            .unwrap_or_else(|| normalize(&raw_channel));
        let supported = self
            .channel_capabilities
            .iter()
            .any(|cap| cap.name.eq_ignore_ascii_case(&channel));
        if !supported {
            return RpcDispatchOutcome::bad_request("invalid channels.logout channel");
        }
        let account_id =
            normalize_optional_text(params.account_id, 64).unwrap_or_else(|| "default".to_owned());
        self.system
            .log_line(format!(
                "channels.logout channel={channel} account={account_id}"
            ))
            .await;
        let logged_out = self
            .channel_runtime
            .mark_logout(channel.as_str(), account_id.as_str(), now_ms())
            .await;
        RpcDispatchOutcome::Handled(json!({
            "channel": channel,
            "accountId": account_id,
            "cleared": logged_out,
            "loggedOut": logged_out,
            "envToken": false,
            "supported": true
        }))
    }

    async fn handle_update_run(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<UpdateRunParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid update.run params: {err}"
                ));
            }
        };

        let session_key = normalize_optional_text(params.session_key, 256);
        let note = normalize_optional_text(params.note, 512);
        let restart_delay_ms = params.restart_delay_ms.unwrap_or(0);
        let timeout_ms = params
            .timeout_ms
            .map(|value| value.max(1_000))
            .unwrap_or(30_000);
        let (delivery_context, thread_id) = extract_update_delivery_info(session_key.as_deref());

        let step = json!({
            "name": "noop",
            "command": "rust-agent restart sentinel",
            "cwd": ".",
            "durationMs": 0,
            "log": {
                "stdoutTail": Value::Null,
                "stderrTail": Value::Null,
                "exitCode": 0
            }
        });
        let result = json!({
            "status": "ok",
            "mode": "rust-parity",
            "root": "memory://openclaw-rust-agent",
            "before": Value::Null,
            "after": Value::Null,
            "steps": [step.clone()],
            "durationMs": 0
        });
        let sentinel_payload = json!({
            "kind": "update",
            "status": "ok",
            "ts": now_ms(),
            "sessionKey": session_key,
            "deliveryContext": delivery_context,
            "threadId": thread_id,
            "message": note,
            "doctorHint": "Run `openclaw doctor --non-interactive` after restart.",
            "stats": {
                "mode": "rust-parity",
                "root": "memory://openclaw-rust-agent",
                "before": Value::Null,
                "after": Value::Null,
                "steps": [step],
                "reason": Value::Null,
                "durationMs": 0,
                "timeoutMs": timeout_ms
            }
        });
        let sentinel_path = format!("memory://restart-sentinel/update-{}", now_ms());
        self.system
            .log_line(format!(
                "update.run status=ok restartDelayMs={restart_delay_ms}"
            ))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "result": result,
            "restart": {
                "scheduled": true,
                "delayMs": restart_delay_ms,
                "reason": "update.run",
                "signal": "SIGUSR1"
            },
            "sentinel": {
                "path": sentinel_path,
                "payload": sentinel_payload
            }
        }))
    }

    async fn handle_web_login_start(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_web_login_runtime_from_config().await {
            self.system
                .log_line(format!("web_login.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("web login runtime unavailable");
        }
        let params = match decode_params::<WebLoginStartParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid web.login.start params: {err}"
                ));
            }
        };
        let Some(provider_id) = resolve_web_login_provider(&self.channel_capabilities) else {
            return RpcDispatchOutcome::bad_request("web login provider is not available");
        };
        let start = self
            .web_login
            .start(WebLoginStartInput {
                provider_id: provider_id.clone(),
                account_id: normalize_optional_text(params.account_id, 64)
                    .unwrap_or_else(|| "default".to_owned()),
                force: params.force.unwrap_or(false),
                verbose: params.verbose.unwrap_or(false),
                timeout_ms: params.timeout_ms.unwrap_or(30_000),
            })
            .await;
        self.system
            .log_line(format!(
                "web.login.start provider={} account={}",
                start.provider_id, start.account_id
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(start))
    }

    async fn handle_web_login_wait(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_web_login_runtime_from_config().await {
            self.system
                .log_line(format!("web_login.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("web login runtime unavailable");
        }
        let params = match decode_params::<WebLoginWaitParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid web.login.wait params: {err}"
                ));
            }
        };
        let Some(provider_id) = resolve_web_login_provider(&self.channel_capabilities) else {
            return RpcDispatchOutcome::bad_request("web login provider is not available");
        };
        let wait = self
            .web_login
            .wait(WebLoginWaitInput {
                provider_id: provider_id.clone(),
                account_id: normalize_optional_text(params.account_id, 64)
                    .unwrap_or_else(|| "default".to_owned()),
                timeout_ms: params.timeout_ms.unwrap_or(120_000),
            })
            .await;
        self.system
            .log_line(format!(
                "web.login.wait provider={} account={} connected={}",
                wait.provider_id, wait.account_id, wait.connected
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(wait))
    }

    async fn handle_auth_oauth_providers(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_oauth_runtime_from_config().await {
            self.system
                .log_line(format!("oauth.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("oauth runtime unavailable");
        }
        if let Err(err) = decode_params::<AuthOAuthProvidersParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!(
                "invalid auth.oauth.providers params: {err}"
            ));
        }
        RpcDispatchOutcome::Handled(json!(self.oauth.providers().await))
    }

    async fn handle_auth_oauth_start(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_oauth_runtime_from_config().await {
            self.system
                .log_line(format!("oauth.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("oauth runtime unavailable");
        }
        let params = match decode_params::<AuthOAuthStartParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid auth.oauth.start params: {err}"
                ));
            }
        };
        let Some(provider_id) = resolve_oauth_provider_param(params.provider_id, params.provider)
        else {
            return RpcDispatchOutcome::bad_request(
                "invalid auth.oauth.start params: provider required",
            );
        };
        let result = match self
            .oauth
            .start(OAuthStartInput {
                provider_id,
                account_id: normalize_optional_text(params.account_id, 128)
                    .unwrap_or_else(|| "default".to_owned()),
                timeout_ms: params.timeout_ms.unwrap_or(300_000),
                force: params.force.unwrap_or(false),
            })
            .await
        {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        self.system
            .log_line(format!(
                "auth.oauth.start provider={} account={}",
                result.provider_id, result.account_id
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(result))
    }

    async fn handle_auth_oauth_wait(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_oauth_runtime_from_config().await {
            self.system
                .log_line(format!("oauth.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("oauth runtime unavailable");
        }
        let params = match decode_params::<AuthOAuthWaitParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid auth.oauth.wait params: {err}"
                ));
            }
        };
        let provider_id = resolve_oauth_provider_param(params.provider_id, params.provider);
        let result = match self
            .oauth
            .wait(OAuthWaitInput {
                provider_id,
                account_id: normalize_optional_text(params.account_id, 128),
                session_id: normalize_optional_text(params.session_id, 128),
                timeout_ms: params.timeout_ms.unwrap_or(30_000),
            })
            .await
        {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        self.system
            .log_line(format!(
                "auth.oauth.wait provider={} account={} connected={}",
                result.provider_id, result.account_id, result.connected
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(result))
    }

    async fn handle_auth_oauth_complete(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_oauth_runtime_from_config().await {
            self.system
                .log_line(format!("oauth.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("oauth runtime unavailable");
        }
        let params = match decode_params::<AuthOAuthCompleteParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid auth.oauth.complete params: {err}"
                ));
            }
        };
        let result = match self
            .oauth
            .complete(OAuthCompleteInput {
                session_id: params.session_id,
                account_id: normalize_optional_text(params.account_id, 128),
                access_token: normalize_optional_text(params.access_token, 8_192),
                refresh_token: normalize_optional_text(params.refresh_token, 8_192),
                token_type: normalize_optional_text(params.token_type, 64),
                expires_at_ms: params.expires_at_ms,
                scopes: normalize_string_list(params.scopes, 32, 128),
                source: normalize_optional_text(params.source, 128),
            })
            .await
        {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        self.system
            .log_line(format!(
                "auth.oauth.complete provider={} account={}",
                result.provider_id, result.account_id
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(result))
    }

    async fn handle_auth_oauth_logout(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_oauth_runtime_from_config().await {
            self.system
                .log_line(format!("oauth.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("oauth runtime unavailable");
        }
        let params = match decode_params::<AuthOAuthLogoutParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid auth.oauth.logout params: {err}"
                ));
            }
        };
        let result = self
            .oauth
            .logout(OAuthLogoutInput {
                provider_id: resolve_oauth_provider_param(params.provider_id, params.provider),
                account_id: normalize_optional_text(params.account_id, 128),
                all: params.all.unwrap_or(false),
            })
            .await;
        self.system
            .log_line(format!(
                "auth.oauth.logout removed={} provider={}",
                result.removed, result.provider_id
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(result))
    }

    async fn handle_auth_oauth_import(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_oauth_runtime_from_config().await {
            self.system
                .log_line(format!("oauth.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("oauth runtime unavailable");
        }
        let params = match decode_params::<AuthOAuthImportParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid auth.oauth.import params: {err}"
                ));
            }
        };
        let result = self
            .oauth
            .import(OAuthImportInput {
                providers: normalize_string_list(params.providers, 32, 128),
                home_dir: normalize_optional_text(params.home_dir, 2048),
                codex_home: normalize_optional_text(params.codex_home, 2048),
                overwrite: params.overwrite.unwrap_or(false),
            })
            .await;
        self.system
            .log_line(format!(
                "auth.oauth.import imported={} requested={}",
                result.imported_count, result.requested_count
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(result))
    }

    async fn handle_wizard_start(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_wizard_runtime_from_config().await {
            self.system
                .log_line(format!("wizard.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("wizard runtime unavailable");
        }
        let params = match decode_params::<WizardStartParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid wizard.start params: {err}"
                ));
            }
        };
        let mode = match parse_wizard_mode(params.mode) {
            Ok(mode) => mode,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let workspace = normalize_optional_text(params.workspace, 1_024);
        let result = match self.wizard.start(mode, workspace).await {
            Ok(v) => v,
            Err(WizardRegistryError::Unavailable(message)) => {
                return RpcDispatchOutcome::Error {
                    code: 503,
                    message,
                    details: None,
                };
            }
            Err(WizardRegistryError::Invalid(message)) => {
                return RpcDispatchOutcome::bad_request(message);
            }
        };
        self.system.log_line("wizard.start".to_owned()).await;
        RpcDispatchOutcome::Handled(result)
    }

    async fn handle_wizard_next(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_wizard_runtime_from_config().await {
            self.system
                .log_line(format!("wizard.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("wizard runtime unavailable");
        }
        let params = match decode_params::<WizardNextParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid wizard.next params: {err}"
                ));
            }
        };
        let result = match self.wizard.next(params).await {
            Ok(v) => v,
            Err(WizardRegistryError::Unavailable(message)) => {
                return RpcDispatchOutcome::Error {
                    code: 503,
                    message,
                    details: None,
                };
            }
            Err(WizardRegistryError::Invalid(message)) => {
                return RpcDispatchOutcome::bad_request(message);
            }
        };
        self.system.log_line("wizard.next".to_owned()).await;
        RpcDispatchOutcome::Handled(result)
    }

    async fn handle_wizard_cancel(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_wizard_runtime_from_config().await {
            self.system
                .log_line(format!("wizard.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("wizard runtime unavailable");
        }
        let params = match decode_params::<WizardSessionParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid wizard.cancel params: {err}"
                ));
            }
        };
        let Some(session_id) = normalize_optional_text(params.session_id, 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid wizard.cancel params: sessionId required",
            );
        };
        let result = match self.wizard.cancel(&session_id).await {
            Ok(v) => v,
            Err(WizardRegistryError::Unavailable(message)) => {
                return RpcDispatchOutcome::Error {
                    code: 503,
                    message,
                    details: None,
                };
            }
            Err(WizardRegistryError::Invalid(message)) => {
                return RpcDispatchOutcome::bad_request(message);
            }
        };
        self.system.log_line("wizard.cancel".to_owned()).await;
        RpcDispatchOutcome::Handled(result)
    }

    async fn handle_wizard_status(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_wizard_runtime_from_config().await {
            self.system
                .log_line(format!("wizard.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("wizard runtime unavailable");
        }
        let params = match decode_params::<WizardSessionParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid wizard.status params: {err}"
                ));
            }
        };
        let Some(session_id) = normalize_optional_text(params.session_id, 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid wizard.status params: sessionId required",
            );
        };
        let result = match self.wizard.status(&session_id).await {
            Ok(v) => v,
            Err(WizardRegistryError::Unavailable(message)) => {
                return RpcDispatchOutcome::Error {
                    code: 503,
                    message,
                    details: None,
                };
            }
            Err(WizardRegistryError::Invalid(message)) => {
                return RpcDispatchOutcome::bad_request(message);
            }
        };
        RpcDispatchOutcome::Handled(result)
    }

    async fn handle_device_pair_list(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_device_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "device pair runtime unavailable: {err}"
            ));
        }
        if let Err(err) = decode_params::<DevicePairListParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!(
                "invalid device.pair.list params: {err}"
            ));
        }
        let list = self.devices.list().await;
        RpcDispatchOutcome::Handled(json!(list))
    }

    async fn handle_device_pair_approve(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_device_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "device pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<DevicePairApproveParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid device.pair.approve params: {err}"
                ));
            }
        };
        let Some(request_id) = normalize_optional_text(Some(params.request_id), 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid device.pair.approve params: requestId required",
            );
        };
        let Some(approved) = self.devices.approve(&request_id).await else {
            return RpcDispatchOutcome::bad_request("unknown requestId");
        };
        self.system
            .log_line(format!(
                "device pairing approved device={} role={}",
                approved.device.device_id,
                approved.device.role.as_deref().unwrap_or("unknown")
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(approved))
    }

    async fn handle_device_pair_reject(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_device_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "device pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<DevicePairRejectParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid device.pair.reject params: {err}"
                ));
            }
        };
        let Some(request_id) = normalize_optional_text(Some(params.request_id), 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid device.pair.reject params: requestId required",
            );
        };
        let Some(rejected) = self.devices.reject(&request_id).await else {
            return RpcDispatchOutcome::bad_request("unknown requestId");
        };
        RpcDispatchOutcome::Handled(json!(rejected))
    }

    async fn handle_device_pair_remove(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_device_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "device pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<DevicePairRemoveParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid device.pair.remove params: {err}"
                ));
            }
        };
        let Some(device_id) = normalize_optional_text(Some(params.device_id), 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid device.pair.remove params: deviceId required",
            );
        };
        let Some(removed) = self.devices.remove(&device_id).await else {
            return RpcDispatchOutcome::bad_request("unknown deviceId");
        };
        self.system
            .log_line(format!(
                "device pairing removed device={}",
                removed.device_id
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(removed))
    }

    async fn handle_device_token_rotate(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_device_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "device pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<DeviceTokenRotateParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid device.token.rotate params: {err}"
                ));
            }
        };
        let Some(device_id) = normalize_optional_text(Some(params.device_id), 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid device.token.rotate params: deviceId required",
            );
        };
        let Some(role) = normalize_optional_text(Some(params.role), 64) else {
            return RpcDispatchOutcome::bad_request(
                "invalid device.token.rotate params: role required",
            );
        };
        let Some(token) = self
            .devices
            .rotate_token(&device_id, &role, params.scopes)
            .await
        else {
            return RpcDispatchOutcome::bad_request("unknown deviceId/role");
        };
        self.system
            .log_line(format!(
                "device token rotated device={} role={} scopes={}",
                device_id,
                token.role,
                token.scopes.join(",")
            ))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "deviceId": device_id,
            "role": token.role,
            "token": token.token,
            "scopes": token.scopes,
            "rotatedAtMs": token.rotated_at_ms.unwrap_or(token.created_at_ms),
        }))
    }

    async fn handle_device_token_revoke(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_device_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "device pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<DeviceTokenRevokeParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid device.token.revoke params: {err}"
                ));
            }
        };
        let Some(device_id) = normalize_optional_text(Some(params.device_id), 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid device.token.revoke params: deviceId required",
            );
        };
        let Some(role) = normalize_optional_text(Some(params.role), 64) else {
            return RpcDispatchOutcome::bad_request(
                "invalid device.token.revoke params: role required",
            );
        };
        let Some(token) = self.devices.revoke_token(&device_id, &role).await else {
            return RpcDispatchOutcome::bad_request("unknown deviceId/role");
        };
        self.system
            .log_line(format!(
                "device token revoked device={} role={}",
                device_id, role
            ))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "deviceId": device_id,
            "role": token.role,
            "revokedAtMs": token.revoked_at_ms.unwrap_or_else(now_ms)
        }))
    }

    async fn handle_node_pair_request(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<NodePairRequestParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid node.pair.request params: {err}"
                ));
            }
        };
        let request = match self.nodes.request(params).await {
            Ok(value) => value,
            Err(message) => return RpcDispatchOutcome::bad_request(message),
        };
        self.system
            .log_line(format!(
                "node.pair.request node={} created={}",
                request.request.node_id, request.created
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(request))
    }

    async fn handle_node_pair_list(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        if let Err(err) = decode_params::<NodePairListParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!(
                "invalid node.pair.list params: {err}"
            ));
        }
        let list = self.nodes.list().await;
        RpcDispatchOutcome::Handled(json!(list))
    }

    async fn handle_node_pair_approve(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<NodePairApproveParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid node.pair.approve params: {err}"
                ));
            }
        };
        let Some(request_id) = normalize_optional_text(Some(params.request_id), 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid node.pair.approve params: requestId required",
            );
        };
        let Some(approved) = self.nodes.approve(&request_id).await else {
            return RpcDispatchOutcome::bad_request("unknown requestId");
        };
        self.system
            .log_line(format!(
                "node pairing approved node={}",
                approved.node.node_id
            ))
            .await;
        RpcDispatchOutcome::Handled(json!(approved))
    }

    async fn handle_node_pair_reject(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<NodePairRejectParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid node.pair.reject params: {err}"
                ));
            }
        };
        let Some(request_id) = normalize_optional_text(Some(params.request_id), 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid node.pair.reject params: requestId required",
            );
        };
        let Some(rejected) = self.nodes.reject(&request_id).await else {
            return RpcDispatchOutcome::bad_request("unknown requestId");
        };
        RpcDispatchOutcome::Handled(json!(rejected))
    }

    async fn handle_node_pair_verify(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<NodePairVerifyParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid node.pair.verify params: {err}"
                ));
            }
        };
        let Some(node_id) = normalize_optional_text(Some(params.node_id), 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid node.pair.verify params: nodeId required",
            );
        };
        let Some(token) = normalize_optional_text(Some(params.token), 256) else {
            return RpcDispatchOutcome::bad_request(
                "invalid node.pair.verify params: token required",
            );
        };
        let verified = self.nodes.verify(&node_id, &token).await;
        RpcDispatchOutcome::Handled(json!(verified))
    }

    async fn handle_node_rename(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<NodeRenameParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid node.rename params: {err}"
                ));
            }
        };
        let Some(node_id) = normalize_optional_text(Some(params.node_id), 128) else {
            return RpcDispatchOutcome::bad_request("invalid node.rename params: nodeId required");
        };
        let Some(display_name) = normalize_optional_text(Some(params.display_name), 128) else {
            return RpcDispatchOutcome::bad_request("displayName required");
        };
        let Some(renamed) = self.nodes.rename(&node_id, &display_name).await else {
            return RpcDispatchOutcome::bad_request("unknown nodeId");
        };
        RpcDispatchOutcome::Handled(json!(renamed))
    }

    async fn handle_node_list(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        if let Err(err) = decode_params::<NodeListParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!("invalid node.list params: {err}"));
        }
        let nodes = self.nodes.list_nodes().await;
        RpcDispatchOutcome::Handled(json!({
            "ts": now_ms(),
            "nodes": nodes
        }))
    }

    async fn handle_node_describe(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<NodeDescribeParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid node.describe params: {err}"
                ));
            }
        };
        let Some(node_id) = normalize_optional_text(Some(params.node_id), 128) else {
            return RpcDispatchOutcome::bad_request("nodeId required");
        };
        let Some(node) = self.nodes.describe_node(&node_id).await else {
            return RpcDispatchOutcome::bad_request("unknown nodeId");
        };
        RpcDispatchOutcome::Handled(json!({
            "ts": now_ms(),
            "nodeId": node.node_id,
            "displayName": node.display_name,
            "platform": node.platform,
            "version": node.version,
            "coreVersion": node.core_version,
            "uiVersion": node.ui_version,
            "deviceFamily": node.device_family,
            "modelIdentifier": node.model_identifier,
            "remoteIp": node.remote_ip,
            "caps": node.caps,
            "commands": node.commands,
            "pathEnv": node.path_env,
            "permissions": node.permissions,
            "connectedAtMs": node.connected_at_ms,
            "paired": node.paired,
            "connected": node.connected
        }))
    }

    async fn handle_node_invoke(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<NodeInvokeParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid node.invoke params: {err}"
                ));
            }
        };
        let Some(node_id) = normalize_optional_text(Some(params.node_id), 128) else {
            return RpcDispatchOutcome::bad_request("nodeId and command required");
        };
        let Some(command) = normalize_optional_text(Some(params.command), 160) else {
            return RpcDispatchOutcome::bad_request("nodeId and command required");
        };
        let Some(idempotency_key) = normalize_optional_text(Some(params.idempotency_key), 256)
        else {
            return RpcDispatchOutcome::bad_request(
                "invalid node.invoke params: idempotencyKey required",
            );
        };
        if command == "system.execApprovals.get" || command == "system.execApprovals.set" {
            return RpcDispatchOutcome::bad_request(
                "node.invoke does not allow system.execApprovals.*; use exec.approvals.node.*",
            );
        }
        let Some(node) = self.nodes.paired_node(&node_id).await else {
            return RpcDispatchOutcome::Error {
                code: 503,
                message: "node not connected".to_owned(),
                details: Some(json!({
                    "code": "NOT_CONNECTED"
                })),
            };
        };
        let node_policy = self.config.node_command_policy_config().await;
        if let Err(reason) = node_command_allowed(&node, &command, &node_policy) {
            return RpcDispatchOutcome::Error {
                code: 400,
                message: "node command not allowed".to_owned(),
                details: Some(json!({
                    "reason": reason.reason(),
                    "command": command
                })),
            };
        }

        let command_params = params.params.clone();
        let invoke_id = self
            .node_runtime
            .begin_invoke(&node_id, &command, params.timeout_ms, &idempotency_key)
            .await;
        if let Some(local_execution) = self
            .try_execute_local_node_command_for_paired_node(
                &node,
                &command,
                command_params.clone(),
                &invoke_id,
            )
            .await
        {
            let _ = self
                .node_runtime
                .complete_invoke(NodeInvokeResultParams {
                    id: invoke_id.clone(),
                    node_id: node_id.clone(),
                    ok: local_execution.ok,
                    payload: local_execution.payload.clone(),
                    payload_json: local_execution.payload_json.clone(),
                    error: local_execution.error.clone(),
                })
                .await;
            if !local_execution.ok {
                let message = local_execution
                    .error
                    .as_ref()
                    .and_then(|error| error.message.clone())
                    .unwrap_or_else(|| "local node command failed".to_owned());
                return RpcDispatchOutcome::Error {
                    code: 503,
                    message,
                    details: Some(json!({
                        "nodeId": node_id,
                        "command": command,
                        "invokeId": invoke_id,
                        "nodeError": local_execution.error.as_ref().map(|error| json!({
                            "code": error.code,
                            "message": error.message
                        })).unwrap_or(Value::Null)
                    })),
                };
            }
            self.system
                .log_line(format!(
                    "node.invoke local node={} command={} id={}",
                    node_id, command, invoke_id
                ))
                .await;
            return RpcDispatchOutcome::Handled(json!({
                "ok": true,
                "nodeId": node_id,
                "command": command,
                "payload": {
                    "status": "completed",
                    "invokeId": invoke_id,
                    "idempotencyKey": idempotency_key,
                    "mode": "rust-parity-local-host",
                    "params": command_params,
                    "timeoutMs": params.timeout_ms,
                    "result": local_execution.payload
                },
                "payloadJSON": local_execution.payload_json
            }));
        }
        self.system
            .log_line(format!(
                "node.invoke node={} command={} id={}",
                node_id, command, invoke_id
            ))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "nodeId": node_id,
            "command": command,
            "payload": {
                "status": "queued",
                "invokeId": invoke_id,
                "idempotencyKey": idempotency_key,
                "mode": "rust-parity",
                "params": command_params,
                "timeoutMs": params.timeout_ms
            },
            "payloadJSON": Value::Null
        }))
    }

    async fn handle_node_invoke_result(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let normalized = normalize_node_invoke_result_params(req.params.clone());
        let params = match decode_params::<NodeInvokeResultParams>(&normalized) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid node.invoke.result params: {err}"
                ));
            }
        };
        let result = self.node_runtime.complete_invoke(params).await;
        match result {
            NodeInvokeCompleteResult::Completed => RpcDispatchOutcome::Handled(json!({
                "ok": true
            })),
            NodeInvokeCompleteResult::Ignored => RpcDispatchOutcome::Handled(json!({
                "ok": true,
                "ignored": true
            })),
            NodeInvokeCompleteResult::NodeMismatch => {
                RpcDispatchOutcome::bad_request("nodeId mismatch")
            }
        }
    }

    async fn handle_node_event(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<NodeEventParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid node.event params: {err}"
                ));
            }
        };
        let Some(event) = normalize_optional_text(Some(params.event), 160) else {
            return RpcDispatchOutcome::bad_request("invalid node.event params: event required");
        };
        let payload_json = params.payload_json.or_else(|| {
            params
                .payload
                .as_ref()
                .and_then(|value| serde_json::to_string(value).ok())
        });
        if normalize(&event) == "push.apns.register" {
            if let Some(registration) = parse_apns_registration_event_payload(
                params.payload.as_ref(),
                payload_json.as_deref(),
            ) {
                self.apns.upsert(registration).await;
            }
        }
        self.node_runtime
            .record_event(event.clone(), payload_json.clone())
            .await;
        self.system
            .log_line(format!(
                "node.event event={} payloadBytes={}",
                event,
                payload_json.as_ref().map_or(0, |value| value.len())
            ))
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true
        }))
    }

    async fn handle_push_test(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<PushTestParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!("invalid push.test params: {err}"));
            }
        };
        let Some(node_id) = normalize_optional_text(Some(params.node_id), 128) else {
            return RpcDispatchOutcome::bad_request("invalid push.test params: nodeId required");
        };
        let environment_override = match params
            .environment
            .as_deref()
            .and_then(|value| normalize_optional_text(Some(value.to_owned()), 32))
        {
            Some(value) => match parse_apns_environment(Some(value.as_str())) {
                Some(parsed) => Some(parsed.to_owned()),
                None => {
                    return RpcDispatchOutcome::bad_request(
                        "invalid push.test params: environment must be sandbox|production",
                    );
                }
            },
            None => None,
        };
        let title =
            normalize_optional_text(params.title, 256).unwrap_or_else(|| "OpenClaw".to_owned());
        let body = normalize_optional_text(params.body, 2_048)
            .unwrap_or_else(|| format!("Push test for node {node_id}"));
        let Some(mut registration) = self.apns.get(&node_id).await else {
            return RpcDispatchOutcome::bad_request(format!(
                "node {node_id} has no APNs registration (connect iOS node first)"
            ));
        };
        if let Some(environment) = environment_override {
            registration.environment = environment;
        }
        let bearer_token = match resolve_apns_bearer_token_from_env() {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let result =
            match send_apns_alert(&bearer_token, &registration, &node_id, &title, &body).await {
                Ok(value) => value,
                Err(err) => {
                    return RpcDispatchOutcome::Error {
                        code: 503,
                        message: "push.test unavailable".to_owned(),
                        details: Some(json!({
                            "nodeId": node_id,
                            "reason": err
                        })),
                    };
                }
            };
        RpcDispatchOutcome::Handled(json!(result))
    }

    async fn handle_browser_request(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = req.params.as_object();
        let method = params
            .and_then(|value| value.get("method"))
            .and_then(Value::as_str)
            .map(|value| value.trim().to_ascii_uppercase())
            .unwrap_or_default();
        let path = params
            .and_then(|value| value.get("path"))
            .and_then(Value::as_str)
            .map(|value| value.trim().to_owned())
            .unwrap_or_default();
        let timeout_ms = params
            .and_then(|value| value.get("timeoutMs").or_else(|| value.get("timeout_ms")))
            .and_then(json_value_as_timeout_ms);
        let query = params
            .and_then(|value| value.get("query"))
            .filter(|value| value.is_object())
            .cloned();
        let body = params.and_then(|value| value.get("body")).cloned();
        let requested_node = params
            .and_then(|value| {
                value
                    .get("nodeId")
                    .or_else(|| value.get("node_id"))
                    .or_else(|| value.get("node"))
            })
            .and_then(Value::as_str)
            .and_then(|value| normalize_optional_text(Some(value.to_owned()), 128));

        if method.is_empty() || path.is_empty() {
            return RpcDispatchOutcome::bad_request("method and path are required");
        }
        if !matches!(method.as_str(), "GET" | "POST" | "DELETE") {
            return RpcDispatchOutcome::bad_request("method must be GET, POST, or DELETE");
        }

        self.system
            .log_line(format!(
                "browser.request method={} path={} timeoutMs={}",
                method,
                truncate_text(&path, 256),
                timeout_ms.unwrap_or(0)
            ))
            .await;

        let nodes = self.nodes.list_nodes().await;
        let browser_nodes = nodes
            .into_iter()
            .filter(node_inventory_browser_capable)
            .collect::<Vec<_>>();
        let selected_node =
            match resolve_browser_node_target(&browser_nodes, requested_node.as_deref()) {
                Ok(node) => node,
                Err(message) => {
                    return RpcDispatchOutcome::Error {
                        code: 503,
                        message,
                        details: Some(json!({
                            "method": method,
                            "path": path,
                            "query": query,
                            "node": requested_node
                        })),
                    };
                }
            };
        let Some(node) = selected_node else {
            return RpcDispatchOutcome::Error {
                code: 503,
                message: "browser control is disabled".to_owned(),
                details: Some(json!({
                    "method": method,
                    "path": path,
                    "query": query
                })),
            };
        };
        let node_policy = self.config.node_command_policy_config().await;
        if let Err(reason) = node_inventory_command_allowed(&node, "browser.proxy", &node_policy) {
            return RpcDispatchOutcome::Error {
                code: 400,
                message: "node command not allowed".to_owned(),
                details: Some(json!({
                    "reason": reason.reason(),
                    "command": "browser.proxy",
                    "nodeId": node.node_id
                })),
            };
        }
        let timeout_ms = timeout_ms.unwrap_or(20_000).min(120_000);
        let idempotency_key = next_browser_proxy_idempotency_key(&node.node_id);
        let proxy_params = {
            let mut payload = serde_json::Map::new();
            payload.insert("method".to_owned(), Value::String(method.clone()));
            payload.insert("path".to_owned(), Value::String(path.clone()));
            if let Some(query) = query.clone() {
                payload.insert("query".to_owned(), query);
            }
            if let Some(body) = body {
                payload.insert("body".to_owned(), body);
            }
            payload.insert("timeoutMs".to_owned(), json!(timeout_ms));
            Value::Object(payload)
        };
        let proxy_params_for_local = proxy_params.clone();
        let (invoke_id, waiter) = self
            .node_runtime
            .begin_invoke_with_wait(
                &node.node_id,
                "browser.proxy",
                Some(timeout_ms),
                &idempotency_key,
            )
            .await;
        self.system
            .log_line(format!(
                "browser.request dispatched node={} invokeId={} path={}",
                node.node_id,
                invoke_id,
                truncate_text(&path, 256)
            ))
            .await;
        self.node_runtime
            .record_event(
                "node.invoke.request".to_owned(),
                serde_json::to_string(&json!({
                    "id": invoke_id,
                    "nodeId": node.node_id,
                    "command": "browser.proxy",
                    "params": proxy_params,
                    "idempotencyKey": idempotency_key
                }))
                .ok(),
            )
            .await;
        if let Some(local_execution) = self
            .try_execute_local_node_command_for_inventory_node(
                &node,
                "browser.proxy",
                Some(proxy_params_for_local),
                &invoke_id,
            )
            .await
        {
            let _ = self
                .node_runtime
                .complete_invoke(NodeInvokeResultParams {
                    id: invoke_id.clone(),
                    node_id: node.node_id.clone(),
                    ok: local_execution.ok,
                    payload: local_execution.payload,
                    payload_json: local_execution.payload_json,
                    error: local_execution.error,
                })
                .await;
        }
        let completion = match tokio::time::timeout(Duration::from_millis(timeout_ms), waiter).await
        {
            Ok(Ok(result)) => result,
            Ok(Err(_)) => {
                return RpcDispatchOutcome::Error {
                    code: 503,
                    message: "browser proxy failed".to_owned(),
                    details: Some(json!({
                        "nodeId": node.node_id,
                        "invokeId": invoke_id
                    })),
                };
            }
            Err(_) => {
                self.node_runtime.cancel_invoke(&invoke_id).await;
                return RpcDispatchOutcome::Error {
                    code: 503,
                    message: "browser proxy timed out".to_owned(),
                    details: Some(json!({
                        "nodeId": node.node_id,
                        "invokeId": invoke_id,
                        "timeoutMs": timeout_ms
                    })),
                };
            }
        };
        if !completion.ok {
            let message = completion
                .error
                .as_ref()
                .and_then(|error| error.message.clone())
                .unwrap_or_else(|| "browser proxy failed".to_owned());
            return RpcDispatchOutcome::Error {
                code: 503,
                message,
                details: Some(json!({
                    "nodeId": node.node_id,
                    "invokeId": invoke_id,
                    "nodeError": completion.error.as_ref().map(|error| json!({
                        "code": error.code,
                        "message": error.message
                    })).unwrap_or(Value::Null)
                })),
            };
        }
        let proxy_payload = completion
            .payload_json
            .as_deref()
            .and_then(parse_payload_json)
            .or(completion.payload);
        let Some(result) = proxy_payload
            .as_ref()
            .and_then(|payload| payload.as_object())
            .and_then(|payload| payload.get("result"))
            .cloned()
        else {
            return RpcDispatchOutcome::Error {
                code: 503,
                message: "browser proxy failed".to_owned(),
                details: Some(json!({
                    "nodeId": node.node_id,
                    "invokeId": invoke_id,
                    "payload": proxy_payload
                })),
            };
        };
        RpcDispatchOutcome::Handled(result)
    }

    async fn handle_browser_open(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<BrowserOpenParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid browser.open params: {err}"
                ));
            }
        };
        let Some(url) = normalize_optional_text(Some(params.url), 2_048) else {
            return RpcDispatchOutcome::bad_request("invalid browser.open params: url required");
        };
        let mut request_params = serde_json::Map::new();
        request_params.insert("method".to_owned(), Value::String("POST".to_owned()));
        request_params.insert("path".to_owned(), Value::String("/tabs/open".to_owned()));
        request_params.insert(
            "body".to_owned(),
            json!({
                "url": url
            }),
        );
        if let Some(timeout_ms) = params.timeout_ms {
            request_params.insert("timeoutMs".to_owned(), json!(timeout_ms));
        }
        if let Some(profile) = normalize_optional_text(params.profile, 64) {
            request_params.insert(
                "query".to_owned(),
                json!({
                    "profile": profile
                }),
            );
        }
        if let Some(node) = normalize_optional_text(params.node.or(params.node_id), 128) {
            request_params.insert("node".to_owned(), Value::String(node));
        }
        let proxy_request = RpcRequestFrame {
            id: req.id.clone(),
            method: "browser.request".to_owned(),
            params: Value::Object(request_params),
        };
        self.handle_browser_request(&proxy_request).await
    }

    async fn handle_canvas_present(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<CanvasPresentParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid canvas.present params: {err}"
                ));
            }
        };
        let Some(node_id) = normalize_optional_text(params.node_id.or(params.node), 128) else {
            return RpcDispatchOutcome::bad_request(
                "invalid canvas.present params: nodeId required",
            );
        };
        let Some(node) = self.nodes.paired_node(&node_id).await else {
            return RpcDispatchOutcome::Error {
                code: 503,
                message: "node not connected".to_owned(),
                details: Some(json!({
                    "code": "NOT_CONNECTED"
                })),
            };
        };
        let node_policy = self.config.node_command_policy_config().await;
        if let Err(reason) = node_command_allowed(&node, "canvas.present", &node_policy) {
            return RpcDispatchOutcome::Error {
                code: 400,
                message: "node command not allowed".to_owned(),
                details: Some(json!({
                    "reason": reason.reason(),
                    "command": "canvas.present",
                    "nodeId": node_id
                })),
            };
        }
        let timeout_ms = params.timeout_ms.unwrap_or(20_000).clamp(1, 120_000);
        let idempotency_key = normalize_optional_text(params.idempotency_key, 256)
            .unwrap_or_else(|| next_canvas_present_idempotency_key(&node_id));
        let target = normalize_optional_text(params.target.or(params.url), 2_048);
        let invoke_params = {
            let mut payload = serde_json::Map::new();
            if let Some(target) = target {
                payload.insert("url".to_owned(), Value::String(target));
            }
            let mut placement = serde_json::Map::new();
            if let Some(value) = params.x {
                placement.insert("x".to_owned(), json!(value));
            }
            if let Some(value) = params.y {
                placement.insert("y".to_owned(), json!(value));
            }
            if let Some(value) = params.width {
                placement.insert("width".to_owned(), json!(value));
            }
            if let Some(value) = params.height {
                placement.insert("height".to_owned(), json!(value));
            }
            if !placement.is_empty() {
                payload.insert("placement".to_owned(), Value::Object(placement));
            }
            Value::Object(payload)
        };
        let invoke_params_for_local = invoke_params.clone();
        let (invoke_id, waiter) = self
            .node_runtime
            .begin_invoke_with_wait(
                &node_id,
                "canvas.present",
                Some(timeout_ms),
                &idempotency_key,
            )
            .await;
        self.system
            .log_line(format!(
                "canvas.present node={} invokeId={}",
                node_id, invoke_id
            ))
            .await;
        self.node_runtime
            .record_event(
                "node.invoke.request".to_owned(),
                serde_json::to_string(&json!({
                    "id": invoke_id,
                    "nodeId": node_id,
                    "command": "canvas.present",
                    "params": invoke_params,
                    "idempotencyKey": idempotency_key
                }))
                .ok(),
            )
            .await;
        if let Some(local_execution) = self
            .try_execute_local_node_command_for_paired_node(
                &node,
                "canvas.present",
                Some(invoke_params_for_local),
                &invoke_id,
            )
            .await
        {
            let _ = self
                .node_runtime
                .complete_invoke(NodeInvokeResultParams {
                    id: invoke_id.clone(),
                    node_id: node_id.clone(),
                    ok: local_execution.ok,
                    payload: local_execution.payload,
                    payload_json: local_execution.payload_json,
                    error: local_execution.error,
                })
                .await;
        }
        let completion = match tokio::time::timeout(Duration::from_millis(timeout_ms), waiter).await
        {
            Ok(Ok(result)) => result,
            Ok(Err(_)) => {
                return RpcDispatchOutcome::Error {
                    code: 503,
                    message: "canvas present failed".to_owned(),
                    details: Some(json!({
                        "nodeId": node_id,
                        "invokeId": invoke_id
                    })),
                };
            }
            Err(_) => {
                self.node_runtime.cancel_invoke(&invoke_id).await;
                return RpcDispatchOutcome::Error {
                    code: 503,
                    message: "canvas present timed out".to_owned(),
                    details: Some(json!({
                        "nodeId": node_id,
                        "invokeId": invoke_id,
                        "timeoutMs": timeout_ms
                    })),
                };
            }
        };
        if !completion.ok {
            let message = completion
                .error
                .as_ref()
                .and_then(|error| error.message.clone())
                .unwrap_or_else(|| "canvas present failed".to_owned());
            return RpcDispatchOutcome::Error {
                code: 503,
                message,
                details: Some(json!({
                    "nodeId": node_id,
                    "invokeId": invoke_id,
                    "nodeError": completion.error.as_ref().map(|error| json!({
                        "code": error.code,
                        "message": error.message
                    })).unwrap_or(Value::Null)
                })),
            };
        }
        let payload_json = completion.payload_json.clone();
        let payload = payload_json
            .as_deref()
            .and_then(parse_payload_json)
            .or(completion.payload)
            .unwrap_or_else(|| {
                json!({
                    "ok": true
                })
            });
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "nodeId": node_id,
            "command": "canvas.present",
            "invokeId": invoke_id,
            "payload": payload,
            "payloadJSON": payload_json
        }))
    }

    async fn try_execute_local_node_command_for_paired_node(
        &self,
        node: &PairedNodeEntry,
        command: &str,
        params: Option<Value>,
        invoke_id: &str,
    ) -> Option<LocalNodeCommandExecution> {
        let runtime = self.config.node_host_runtime_config().await;
        if !paired_node_supports_local_host_runtime(node, &runtime) {
            return None;
        }
        Some(
            self.execute_local_node_command(
                LocalNodeCommandContext {
                    node_id: &node.node_id,
                    platform: node.platform.as_deref(),
                    device_family: node.device_family.as_deref(),
                    invoke_id,
                },
                command,
                params,
                &runtime,
            )
            .await,
        )
    }

    async fn try_execute_local_node_command_for_inventory_node(
        &self,
        node: &NodeInventoryEntry,
        command: &str,
        params: Option<Value>,
        invoke_id: &str,
    ) -> Option<LocalNodeCommandExecution> {
        let runtime = self.config.node_host_runtime_config().await;
        if !inventory_node_supports_local_host_runtime(node, &runtime) {
            return None;
        }
        Some(
            self.execute_local_node_command(
                LocalNodeCommandContext {
                    node_id: &node.node_id,
                    platform: node.platform.as_deref(),
                    device_family: node.device_family.as_deref(),
                    invoke_id,
                },
                command,
                params,
                &runtime,
            )
            .await,
        )
    }

    async fn execute_local_node_command(
        &self,
        context: LocalNodeCommandContext<'_>,
        command: &str,
        params: Option<Value>,
        runtime: &NodeHostRuntimeConfig,
    ) -> LocalNodeCommandExecution {
        let node_id = context.node_id;
        let platform = context.platform;
        let device_family = context.device_family;
        let invoke_id = context.invoke_id;
        let command_key = normalize(command);
        if runtime.external_command.is_some()
            || !runtime.external_commands.is_empty()
            || !runtime.external_platforms.is_empty()
        {
            let external = self
                .node_host_runtime
                .execute_external_command(
                    node_id,
                    command,
                    params.as_ref(),
                    runtime,
                    platform,
                    device_family,
                )
                .await;
            if external.ok {
                self.system
                    .log_line(format!(
                        "node.invoke.local node={} command={} invokeId={} ok=true source=external-host-runtime",
                        node_id, command, invoke_id
                    ))
                    .await;
                return external;
            }
            if external
                .error
                .as_ref()
                .and_then(|error| error.code.as_deref())
                == Some("LOCAL_EXTERNAL_HOST_UNAVAILABLE")
            {
                self.system
                    .log_line(format!(
                        "node.invoke.local external host unavailable for node={} command={} invokeId={}; falling back to in-process runtime",
                        node_id, command, invoke_id
                    ))
                    .await;
            } else {
                self.system
                    .log_line(format!(
                        "node.invoke.local node={} command={} invokeId={} ok=false source=external-host-runtime",
                        node_id, command, invoke_id
                    ))
                    .await;
                return external;
            }
        }
        let result = match command_key.as_str() {
            "camera.list" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "cameras": [
                    {
                        "id": "camera-front",
                        "name": "Front Camera",
                        "facing": "front",
                        "formats": ["jpeg", "png"]
                    },
                    {
                        "id": "camera-rear",
                        "name": "Rear Camera",
                        "facing": "rear",
                        "formats": ["jpeg", "png", "heic"]
                    }
                ],
                "count": 2,
                "source": "local-host-runtime"
            })),
            "camera.snap" => {
                let quality = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("quality"))
                    .and_then(Value::as_str)
                    .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 32))
                    .unwrap_or_else(|| "default".to_owned());
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "capturedAtMs": now_ms(),
                    "quality": quality,
                    "mime": "image/jpeg",
                    "imagePath": format!("memory://nodes/{node_id}/camera/{}.jpg", now_ms()),
                    "source": "local-host-runtime"
                }))
            }
            "camera.clip" => {
                let duration_ms = local_node_host_duration_ms_from_params(
                    params.as_ref(),
                    LOCAL_NODE_HOST_CAMERA_CLIP_DEFAULT_DURATION_MS,
                    LOCAL_NODE_HOST_CAMERA_CLIP_MAX_DURATION_MS,
                );
                let include_audio = local_node_host_include_audio_from_params(params.as_ref());
                let format = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("format"))
                    .and_then(Value::as_str)
                    .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 32))
                    .unwrap_or_else(|| "mp4".to_owned());
                let facing = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("facing"))
                    .and_then(Value::as_str)
                    .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 32));
                let device_id = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("deviceId").or_else(|| obj.get("device_id")))
                    .and_then(Value::as_str)
                    .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 128));
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "capturedAtMs": now_ms(),
                    "format": format,
                    "durationMs": duration_ms,
                    "hasAudio": include_audio,
                    "facing": facing,
                    "deviceId": device_id,
                    "videoPath": format!("memory://nodes/{node_id}/camera/{}.mp4", now_ms()),
                    "source": "local-host-runtime"
                }))
            }
            "screen.record" => {
                let seconds = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("seconds"))
                    .and_then(config_value_as_u64)
                    .unwrap_or(1)
                    .clamp(1, 300);
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "recordedAtMs": now_ms(),
                    "durationMs": seconds.saturating_mul(1_000),
                    "videoPath": format!("memory://nodes/{node_id}/screen/{}.mp4", now_ms()),
                    "source": "local-host-runtime"
                }))
            }
            "location.get" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "provider": "local-host-runtime",
                "lat": 0.0,
                "lon": 0.0,
                "accuracyMeters": 50000.0,
                "ts": now_ms()
            })),
            "device.info" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "name": "Local Node",
                "platform": std::env::consts::OS,
                "os": std::env::consts::OS,
                "arch": std::env::consts::ARCH,
                "source": "local-host-runtime"
            })),
            "device.status" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "online": true,
                "batteryPercent": 100,
                "charging": true,
                "network": "wifi",
                "ts": now_ms(),
                "source": "local-host-runtime"
            })),
            "contacts.search" => {
                let query = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("query"))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty())
                    .unwrap_or("contact");
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "query": query,
                    "results": [{
                        "id": "contact-1",
                        "name": format!("{query} result"),
                        "phone": "+15550001111"
                    }],
                    "count": 1,
                    "source": "local-host-runtime"
                }))
            }
            "contacts.add" => {
                let object = params.as_ref().and_then(Value::as_object);
                let name = object
                    .and_then(|obj| obj.get("name"))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty())
                    .unwrap_or("New Contact");
                let phone = object
                    .and_then(|obj| obj.get("phone").or_else(|| obj.get("number")))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty());
                let email = object
                    .and_then(|obj| obj.get("email"))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty());
                let created_at_ms = now_ms();
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "contact": {
                        "id": format!("contact-{created_at_ms}"),
                        "name": name,
                        "phone": phone,
                        "email": email,
                        "createdAtMs": created_at_ms
                    },
                    "source": "local-host-runtime"
                }))
            }
            "calendar.events" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "events": [{
                    "id": "evt-1",
                    "title": "Parity Checkpoint",
                    "startTime": "2026-02-21T20:00:00Z",
                    "endTime": "2026-02-21T20:30:00Z"
                }],
                "count": 1,
                "source": "local-host-runtime"
            })),
            "calendar.add" => {
                let object = params.as_ref().and_then(Value::as_object);
                let title = object
                    .and_then(|obj| {
                        obj.get("title")
                            .or_else(|| obj.get("eventName"))
                            .or_else(|| obj.get("summary"))
                    })
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty())
                    .unwrap_or("Untitled Event");
                let start_time = object
                    .and_then(|obj| obj.get("startTime").or_else(|| obj.get("start")))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty())
                    .unwrap_or("2026-02-21T20:00:00Z");
                let end_time = object
                    .and_then(|obj| obj.get("endTime").or_else(|| obj.get("end")))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty());
                let location = object
                    .and_then(|obj| obj.get("location"))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty());
                let all_day = object
                    .and_then(|obj| obj.get("allDay").or_else(|| obj.get("all_day")))
                    .and_then(Value::as_bool)
                    .unwrap_or(false);
                let created_at_ms = now_ms();
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "event": {
                        "id": format!("evt-{created_at_ms}"),
                        "title": title,
                        "startTime": start_time,
                        "endTime": end_time,
                        "location": location,
                        "allDay": all_day,
                        "createdAtMs": created_at_ms
                    },
                    "source": "local-host-runtime"
                }))
            }
            "reminders.list" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "reminders": [{
                    "id": "rem-1",
                    "title": "Review parity artifacts",
                    "completed": false
                }],
                "count": 1,
                "source": "local-host-runtime"
            })),
            "reminders.add" => {
                let object = params.as_ref().and_then(Value::as_object);
                let title = object
                    .and_then(|obj| {
                        obj.get("title")
                            .or_else(|| obj.get("text"))
                            .or_else(|| obj.get("message"))
                    })
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty())
                    .unwrap_or("Reminder");
                let due_time = object
                    .and_then(|obj| obj.get("dueTime").or_else(|| obj.get("due")))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty());
                let list = object
                    .and_then(|obj| obj.get("list"))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty())
                    .unwrap_or("default");
                let priority = object
                    .and_then(|obj| obj.get("priority"))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty())
                    .unwrap_or("medium");
                let created_at_ms = now_ms();
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "reminder": {
                        "id": format!("rem-{created_at_ms}"),
                        "title": title,
                        "dueTime": due_time,
                        "list": list,
                        "priority": priority,
                        "completed": false,
                        "createdAtMs": created_at_ms
                    },
                    "source": "local-host-runtime"
                }))
            }
            "sms.send" => {
                let object = params.as_ref().and_then(Value::as_object);
                let Some(to) = object
                    .and_then(|obj| obj.get("to").or_else(|| obj.get("phone")))
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty())
                else {
                    return local_node_command_error(
                        "LOCAL_COMMAND_INVALID_ARGS",
                        "sms.send requires `to`".to_owned(),
                    );
                };
                let Some(message) = object
                    .and_then(|obj| {
                        obj.get("message")
                            .or_else(|| obj.get("text"))
                            .or_else(|| obj.get("body"))
                    })
                    .and_then(Value::as_str)
                    .map(str::trim)
                    .filter(|value| !value.is_empty())
                else {
                    return local_node_command_error(
                        "LOCAL_COMMAND_INVALID_ARGS",
                        "sms.send requires `message`".to_owned(),
                    );
                };
                let message_id = format!("sms-{}", now_ms());
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "messageId": message_id,
                    "to": to,
                    "message": message,
                    "queued": true,
                    "source": "local-host-runtime"
                }))
            }
            "photos.latest" => {
                let limit = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("limit"))
                    .and_then(config_value_as_u64)
                    .unwrap_or(1)
                    .clamp(1, 10) as usize;
                let photos = (0..limit)
                    .map(|idx| {
                        json!({
                            "id": format!("photo-{idx}"),
                            "mimeType": "image/jpeg",
                            "path": format!("memory://nodes/{node_id}/photos/{idx}.jpg")
                        })
                    })
                    .collect::<Vec<_>>();
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "photos": photos,
                    "count": limit,
                    "source": "local-host-runtime"
                }))
            }
            "motion.activity" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "activity": "stationary",
                "confidence": 0.95,
                "ts": now_ms(),
                "source": "local-host-runtime"
            })),
            "motion.pedometer" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "steps": 0,
                "distanceMeters": 0.0,
                "floorsAscended": 0,
                "floorsDescended": 0,
                "ts": now_ms(),
                "source": "local-host-runtime"
            })),
            "browser.proxy" => {
                let method = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("method"))
                    .and_then(Value::as_str)
                    .map(|raw| raw.trim().to_ascii_uppercase())
                    .filter(|raw| !raw.is_empty())
                    .unwrap_or_else(|| "GET".to_owned());
                let path = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("path"))
                    .and_then(Value::as_str)
                    .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 2_048))
                    .unwrap_or_else(|| "/".to_owned());
                let query = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("query"))
                    .filter(|value| value.is_object())
                    .cloned()
                    .unwrap_or(Value::Object(serde_json::Map::new()));
                local_node_command_ok(json!({
                    "result": {
                        "ok": true,
                        "status": 200,
                        "headers": {
                            "content-type": "application/json",
                            "x-openclaw-local-host": "true"
                        },
                        "body": {
                            "nodeId": node_id,
                            "method": method,
                            "path": path,
                            "query": query,
                            "mode": "rust-parity-local-host"
                        }
                    }
                }))
            }
            "canvas.hide" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "hidden": true,
                "ts": now_ms(),
                "source": "local-host-runtime"
            })),
            "canvas.navigate" => {
                let url = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("url"))
                    .and_then(Value::as_str)
                    .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 2_048))
                    .unwrap_or_else(|| "/".to_owned());
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "navigated": true,
                    "url": url,
                    "ts": now_ms(),
                    "source": "local-host-runtime"
                }))
            }
            "canvas.eval" => {
                let script = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("script").or_else(|| obj.get("code")))
                    .and_then(Value::as_str)
                    .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 8_192))
                    .unwrap_or_default();
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "script": script,
                    "result": Value::Null,
                    "source": "local-host-runtime"
                }))
            }
            "canvas.snapshot" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "mimeType": "image/png",
                "bytes": 0,
                "imageBase64": "",
                "source": "local-host-runtime"
            })),
            "canvas.a2ui.push" => {
                let pushed = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("items"))
                    .and_then(Value::as_array)
                    .map(|items| items.len())
                    .unwrap_or(0);
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "accepted": true,
                    "pushed": pushed,
                    "ts": now_ms(),
                    "source": "local-host-runtime"
                }))
            }
            "canvas.a2ui.pushjsonl" => {
                let pushed = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("jsonl"))
                    .and_then(Value::as_str)
                    .map(|raw| {
                        raw.lines()
                            .map(str::trim)
                            .filter(|line| !line.is_empty())
                            .count()
                    })
                    .unwrap_or(0);
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "accepted": true,
                    "pushed": pushed,
                    "format": "jsonl",
                    "ts": now_ms(),
                    "source": "local-host-runtime"
                }))
            }
            "canvas.a2ui.reset" => local_node_command_ok(json!({
                "ok": true,
                "nodeId": node_id,
                "reset": true,
                "ts": now_ms(),
                "source": "local-host-runtime"
            })),
            "canvas.present" => {
                let url = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("url"))
                    .and_then(Value::as_str)
                    .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 2_048));
                let placement = params
                    .as_ref()
                    .and_then(Value::as_object)
                    .and_then(|obj| obj.get("placement"))
                    .filter(|value| value.is_object())
                    .cloned()
                    .unwrap_or_else(|| json!({}));
                local_node_command_ok(json!({
                    "ok": true,
                    "nodeId": node_id,
                    "presented": true,
                    "target": url,
                    "placement": placement,
                    "presentedAtMs": now_ms(),
                    "source": "local-host-runtime"
                }))
            }
            "system.run" => {
                local_node_host_execute_system_run(node_id, params.as_ref(), runtime).await
            }
            "system.which" => local_node_host_execute_system_which(node_id, params.as_ref()),
            "system.notify" => local_node_host_execute_system_notify(node_id, params.as_ref()),
            _ => local_node_command_error(
                "LOCAL_COMMAND_UNSUPPORTED",
                format!("local host runtime does not implement command: {command}"),
            ),
        };
        self.system
            .log_line(format!(
                "node.invoke.local node={} command={} invokeId={} ok={}",
                node_id, command, invoke_id, result.ok
            ))
            .await;
        result
    }

    async fn handle_exec_approvals_get(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = decode_params::<ExecApprovalsGetParams>(&req.params) {
            return RpcDispatchOutcome::bad_request(format!(
                "invalid exec.approvals.get params: {err}"
            ));
        }
        let snapshot = self.exec_approvals.get_global().await;
        RpcDispatchOutcome::Handled(json!(snapshot))
    }

    async fn handle_exec_approvals_set(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<ExecApprovalsSetParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid exec.approvals.set params: {err}"
                ));
            }
        };
        let Some(file) = params.file else {
            return RpcDispatchOutcome::bad_request("exec approvals file is required");
        };
        if !file.is_object() {
            return RpcDispatchOutcome::bad_request("exec approvals file is required");
        }
        let snapshot = match self.exec_approvals.set_global(file, params.base_hash).await {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        RpcDispatchOutcome::Handled(json!(snapshot))
    }

    async fn handle_exec_approvals_node_get(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<ExecApprovalsNodeGetParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid exec.approvals.node.get params: {err}"
                ));
            }
        };
        let Some(node_id) = normalize_optional_text(Some(params.node_id), 128) else {
            return RpcDispatchOutcome::bad_request("nodeId required");
        };
        if self.nodes.paired_node(&node_id).await.is_none() {
            return RpcDispatchOutcome::Error {
                code: 503,
                message: "node not connected".to_owned(),
                details: Some(json!({
                    "code": "NOT_CONNECTED"
                })),
            };
        }
        let snapshot = self.exec_approvals.get_node(&node_id).await;
        RpcDispatchOutcome::Handled(json!(snapshot))
    }

    async fn handle_exec_approvals_node_set(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_node_pair_runtime_from_config().await {
            return RpcDispatchOutcome::internal_error(format!(
                "node pair runtime unavailable: {err}"
            ));
        }
        let params = match decode_params::<ExecApprovalsNodeSetParams>(&req.params) {
            Ok(v) => v,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid exec.approvals.node.set params: {err}"
                ));
            }
        };
        let Some(node_id) = normalize_optional_text(Some(params.node_id), 128) else {
            return RpcDispatchOutcome::bad_request("nodeId required");
        };
        let Some(file) = params.file else {
            return RpcDispatchOutcome::bad_request("exec approvals file is required");
        };
        if !file.is_object() {
            return RpcDispatchOutcome::bad_request("exec approvals file is required");
        }
        if self.nodes.paired_node(&node_id).await.is_none() {
            return RpcDispatchOutcome::Error {
                code: 503,
                message: "node not connected".to_owned(),
                details: Some(json!({
                    "code": "NOT_CONNECTED"
                })),
            };
        }
        let snapshot = match self
            .exec_approvals
            .set_node(&node_id, file, params.base_hash)
            .await
        {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        RpcDispatchOutcome::Handled(json!(snapshot))
    }

    async fn handle_exec_approval_request(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<ExecApprovalRequestParams>(&req.params) {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid exec.approval.request params: {err}"
                ));
            }
        };
        let Some(command) = normalize_optional_text(Some(params.command), 2_048) else {
            return RpcDispatchOutcome::bad_request("command required");
        };
        let timeout_ms = params
            .timeout_ms
            .unwrap_or(DEFAULT_EXEC_APPROVAL_TIMEOUT_MS)
            .max(1);
        let _request_payload = json!({
            "command": command,
            "cwd": normalize_optional_text(params.cwd, 1_024),
            "host": normalize_optional_text(params.host, 128),
            "security": normalize_optional_text(params.security, 64),
            "ask": normalize_optional_text(params.ask, 64),
            "agentId": normalize_optional_text(params.agent_id, 128),
            "resolvedPath": normalize_optional_text(params.resolved_path, 2_048),
            "sessionKey": normalize_optional_text(params.session_key, 512)
        });
        let create = match self
            .exec_approval
            .create(timeout_ms, normalize_optional_text(params.id, 128))
            .await
        {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        if params.two_phase.unwrap_or(false) {
            return RpcDispatchOutcome::Handled(json!({
                "status": "accepted",
                "id": create.id,
                "createdAtMs": create.created_at_ms,
                "expiresAtMs": create.expires_at_ms
            }));
        }
        let decision = create.receiver.await.ok().flatten();
        RpcDispatchOutcome::Handled(json!({
            "id": create.id,
            "decision": decision,
            "createdAtMs": create.created_at_ms,
            "expiresAtMs": create.expires_at_ms
        }))
    }

    async fn handle_exec_approval_wait_decision(
        &self,
        req: &RpcRequestFrame,
    ) -> RpcDispatchOutcome {
        let params = match decode_params::<ExecApprovalWaitDecisionParams>(&req.params) {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid exec.approval.waitDecision params: {err}"
                ));
            }
        };
        let Some(id) = normalize_optional_text(params.id, 128) else {
            return RpcDispatchOutcome::bad_request("id is required");
        };
        match self.exec_approval.wait_decision(&id).await {
            ExecApprovalWaitOutcome::Missing => {
                RpcDispatchOutcome::bad_request("approval expired or not found")
            }
            ExecApprovalWaitOutcome::Ready {
                decision,
                created_at_ms,
                expires_at_ms,
            } => RpcDispatchOutcome::Handled(json!({
                "id": id,
                "decision": decision,
                "createdAtMs": created_at_ms,
                "expiresAtMs": expires_at_ms
            })),
            ExecApprovalWaitOutcome::Pending {
                receiver,
                created_at_ms,
                expires_at_ms,
            } => {
                let decision = receiver.await.ok().flatten();
                RpcDispatchOutcome::Handled(json!({
                    "id": id,
                    "decision": decision,
                    "createdAtMs": created_at_ms,
                    "expiresAtMs": expires_at_ms
                }))
            }
        }
    }

    async fn handle_exec_approval_resolve(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<ExecApprovalResolveParams>(&req.params) {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid exec.approval.resolve params: {err}"
                ));
            }
        };
        let Some(id) = normalize_optional_text(Some(params.id), 128) else {
            return RpcDispatchOutcome::bad_request("id is required");
        };
        let Some(decision_raw) = normalize_optional_text(Some(params.decision), 32) else {
            return RpcDispatchOutcome::bad_request("invalid decision");
        };
        let decision = normalize(&decision_raw);
        if !matches!(decision.as_str(), "allow-once" | "allow-always" | "deny") {
            return RpcDispatchOutcome::bad_request("invalid decision");
        }
        let ok = self.exec_approval.resolve(&id, decision).await;
        if !ok {
            return RpcDispatchOutcome::bad_request("unknown approval id");
        }
        RpcDispatchOutcome::Handled(json!({
            "ok": true
        }))
    }

    async fn handle_chat_history(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<ChatHistoryParams>(&req.params) {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid chat.history params: {err}"
                ));
            }
        };
        let session_key = canonicalize_session_key(&params.session_key);
        if session_key.is_empty() {
            return RpcDispatchOutcome::bad_request("sessionKey is required");
        }
        let limit = params.limit.unwrap_or(200).clamp(1, 1_000);
        let mut send_records = self
            .sessions
            .history(Some(&session_key), Some(limit))
            .await
            .into_iter()
            .filter_map(|record| match record.kind {
                SessionHistoryKind::Send => Some(record),
                SessionHistoryKind::Decision => None,
            })
            .collect::<Vec<_>>();
        send_records.reverse();
        let mut messages = Vec::with_capacity(send_records.len());
        let mut previous_id: Option<String> = None;
        for (index, record) in send_records.into_iter().enumerate() {
            let Some(text) = normalize_optional_text(record.text.or(record.command), 12_000) else {
                continue;
            };
            let role = if record
                .source
                .as_deref()
                .map(|value| value.eq_ignore_ascii_case("chat.inject"))
                .unwrap_or(false)
            {
                "assistant"
            } else {
                "user"
            };
            let message_id = normalize_optional_text(record.request_id, 256)
                .unwrap_or_else(|| format!("msg-{}-{index}", record.at_ms));
            messages.push(json!({
                "id": message_id,
                "parentId": previous_id.clone(),
                "role": role,
                "timestamp": record.at_ms,
                "content": text
            }));
            previous_id = Some(message_id);
        }
        let meta = self.sessions.chat_meta(&session_key).await;
        RpcDispatchOutcome::Handled(json!({
            "sessionKey": session_key,
            "sessionId": meta.as_ref().map(|value| value.session_id.clone()),
            "messages": messages,
            "thinkingLevel": meta.as_ref().and_then(|value| value.thinking_level.clone()),
            "verboseLevel": meta.as_ref().and_then(|value| value.verbose_level.clone())
        }))
    }

    async fn handle_send(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        if let Err(err) = self.sync_channel_runtime_from_config().await {
            self.system
                .log_line(format!("channel.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("channel runtime unavailable");
        }
        let params = match decode_params::<GatewaySendParams>(&req.params) {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!("invalid send params: {err}"));
            }
        };
        let Some(idempotency_key) = normalize_optional_text(Some(params.idempotency_key), 256)
        else {
            return RpcDispatchOutcome::bad_request(
                "invalid send params: idempotencyKey is required",
            );
        };
        if let Err(err) = self.sync_send_runtime_from_config().await {
            self.system
                .log_line(format!("send.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("send runtime unavailable");
        }
        if let Some(cached) = self.send.get(&idempotency_key).await {
            return RpcDispatchOutcome::Handled(cached);
        }
        let run_id = idempotency_key;
        let _gif_playback = params.gif_playback.unwrap_or(false);

        let Some(to) = normalize_optional_text(Some(params.to), 512) else {
            return RpcDispatchOutcome::bad_request("invalid send params: to is required");
        };
        let to_for_transport = to.clone();
        let message = normalize_optional_text(params.message, 12_000);
        let media_url = normalize_optional_text(params.media_url, 2_048);
        let mut media_urls = params
            .media_urls
            .unwrap_or_default()
            .into_iter()
            .filter_map(|value| normalize_optional_text(Some(value), 2_048))
            .collect::<Vec<_>>();
        if let Some(url) = media_url {
            media_urls.push(url);
        }
        if message.is_none() && media_urls.is_empty() {
            return RpcDispatchOutcome::bad_request(
                "invalid send params: text or media is required",
            );
        }

        let channel_input = normalize_optional_text(params.channel.clone(), 64);
        let requested_channel = channel_input
            .clone()
            .unwrap_or_else(|| DEFAULT_SEND_CHANNEL.to_owned());
        let normalized_channel = normalize_channel_id(Some(requested_channel.as_str()))
            .unwrap_or_else(|| normalize(&requested_channel));
        if normalized_channel.eq_ignore_ascii_case("webchat") {
            return RpcDispatchOutcome::bad_request(
                "unsupported channel: webchat (internal-only). Use `chat.send` for WebChat UI messages or choose a deliverable channel.",
            );
        }
        let Some(capability) = self
            .channel_capabilities
            .iter()
            .find(|capability| capability.name.eq_ignore_ascii_case(&normalized_channel))
        else {
            let unsupported = params.channel.unwrap_or(requested_channel);
            return RpcDispatchOutcome::bad_request(format!("unsupported channel: {unsupported}"));
        };
        let channel = capability.name.to_owned();
        if !channel_supports_message_action(capability, ChannelMessageAction::Send) {
            return RpcDispatchOutcome::bad_request(format!("unsupported send channel: {channel}"));
        }

        let account_id = normalize_optional_text(params.account_id, 128);
        let thread_id = normalize_optional_text(params.thread_id, 128);
        let reply_to = normalize_optional_text(params.reply_to, 256);
        let session_key = normalize_optional_text(params.session_key, 256)
            .and_then(|value| {
                let canonical = canonicalize_session_key(&value);
                (!canonical.is_empty()).then_some(canonical)
            })
            .unwrap_or_else(|| derive_outbound_session_key(&channel, &to));
        let mirrored_message = message.clone().or_else(|| {
            (!media_urls.is_empty()).then(|| format!("[media] {}", media_urls.join(" ")))
        });
        let _ = self
            .sessions
            .record_send(SessionSend {
                session_key,
                request_id: Some(run_id.clone()),
                message: mirrored_message,
                command: None,
                source: "send".to_owned(),
                channel: Some(channel.clone()),
                to: Some(to),
                account_id: account_id.clone(),
                thread_id: thread_id.clone(),
                reply_back: None,
            })
            .await;
        self.channel_runtime
            .mark_outbound(
                channel.as_str(),
                account_id.as_deref().unwrap_or("default"),
                now_ms(),
            )
            .await;

        let message_id = next_send_message_id();
        let mut payload = json!({
            "runId": run_id,
            "messageId": message_id,
            "channel": channel
        });
        payload["transport"] = build_channel_transport_receipt(
            capability,
            ChannelMessageAction::Send,
            message_id.as_str(),
            Some(to_for_transport.as_str()),
            thread_id.as_deref(),
            reply_to.as_deref(),
            false,
        );
        if let Some(text) = message.as_deref() {
            let limit = default_text_chunk_limit(Some(channel.as_str()));
            let mode = default_chunk_mode(Some(channel.as_str()));
            let chunk_count = chunk_text_with_mode(text, limit, mode).len();
            payload["chunkCount"] = json!(chunk_count.max(1));
        }
        if let Some(account_id) = account_id {
            payload["accountId"] = json!(account_id);
        }
        if let Some(thread_id) = thread_id {
            payload["threadId"] = json!(thread_id);
        }
        if let Some(reply_to) = reply_to {
            payload["replyTo"] = json!(reply_to);
        }
        let cache_key = payload
            .pointer("/runId")
            .and_then(Value::as_str)
            .unwrap_or_default()
            .to_owned();
        if let Err(err) = self.send.set(cache_key, payload.clone()).await {
            self.system
                .log_line(format!("send.cache persist failed: {err:?}"))
                .await;
            return RpcDispatchOutcome::internal_error("send cache persistence failed");
        }
        RpcDispatchOutcome::Handled(payload)
    }

    async fn handle_poll(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        if let Err(err) = self.sync_channel_runtime_from_config().await {
            self.system
                .log_line(format!("channel.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("channel runtime unavailable");
        }
        let params = match decode_params::<GatewayPollParams>(&req.params) {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!("invalid poll params: {err}"));
            }
        };
        let Some(idempotency_key) = normalize_optional_text(Some(params.idempotency_key), 256)
        else {
            return RpcDispatchOutcome::bad_request(
                "invalid poll params: idempotencyKey is required",
            );
        };
        if let Err(err) = self.sync_send_runtime_from_config().await {
            self.system
                .log_line(format!("send.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("poll runtime unavailable");
        }
        let cache_key = format!("poll:{idempotency_key}");
        if let Some(cached) = self.send.get(&cache_key).await {
            return RpcDispatchOutcome::Handled(cached);
        }
        let run_id = idempotency_key;

        let Some(to) = normalize_optional_text(Some(params.to), 512) else {
            return RpcDispatchOutcome::bad_request("invalid poll params: to is required");
        };
        let to_for_transport = to.clone();
        let Some(question) = normalize_optional_text(Some(params.question), 2_048) else {
            return RpcDispatchOutcome::bad_request("invalid poll params: question is required");
        };
        let options = params
            .options
            .into_iter()
            .filter_map(|value| normalize_optional_text(Some(value), 1_024))
            .collect::<Vec<_>>();
        if !(2..=12).contains(&options.len()) {
            return RpcDispatchOutcome::bad_request(
                "invalid poll params: options must contain between 2 and 12 entries",
            );
        }
        if let Some(max_selections) = params.max_selections {
            if max_selections == 0 || max_selections > 12 {
                return RpcDispatchOutcome::bad_request(
                    "invalid poll params: maxSelections must be between 1 and 12",
                );
            }
            if max_selections > options.len() {
                return RpcDispatchOutcome::bad_request(
                    "invalid poll params: maxSelections cannot exceed options length",
                );
            }
        }
        if let Some(duration_hours) = params.duration_hours {
            if duration_hours == 0 {
                return RpcDispatchOutcome::bad_request(
                    "invalid poll params: durationHours must be >= 1",
                );
            }
        }

        let channel_input = normalize_optional_text(params.channel.clone(), 64);
        let requested_channel = channel_input
            .clone()
            .unwrap_or_else(|| DEFAULT_SEND_CHANNEL.to_owned());
        let normalized_channel = normalize_channel_id(Some(requested_channel.as_str()))
            .unwrap_or_else(|| normalize(&requested_channel));
        let Some(capability) = self
            .channel_capabilities
            .iter()
            .find(|capability| capability.name.eq_ignore_ascii_case(&normalized_channel))
        else {
            let unsupported = params.channel.unwrap_or(requested_channel);
            return RpcDispatchOutcome::bad_request(format!(
                "unsupported poll channel: {unsupported}"
            ));
        };
        let channel = capability.name.to_owned();
        if !channel_supports_message_action(capability, ChannelMessageAction::Poll) {
            return RpcDispatchOutcome::bad_request(format!("unsupported poll channel: {channel}"));
        }
        if params.duration_seconds.is_some() && !channel.eq_ignore_ascii_case("telegram") {
            return RpcDispatchOutcome::bad_request(
                "durationSeconds is only supported for Telegram polls",
            );
        }
        if params.is_anonymous.is_some() && !channel.eq_ignore_ascii_case("telegram") {
            return RpcDispatchOutcome::bad_request(
                "isAnonymous is only supported for Telegram polls",
            );
        }
        if let Some(duration_seconds) = params.duration_seconds {
            if duration_seconds == 0 || duration_seconds > 604_800 {
                return RpcDispatchOutcome::bad_request(
                    "invalid poll params: durationSeconds must be between 1 and 604800",
                );
            }
        }

        let _silent = params.silent.unwrap_or(false);
        let account_id = normalize_optional_text(params.account_id, 128);
        let thread_id = normalize_optional_text(params.thread_id, 128);
        let _ = self
            .sessions
            .record_send(SessionSend {
                session_key: derive_outbound_session_key(&channel, &to),
                request_id: Some(run_id.clone()),
                message: Some(format!("[poll] {question}")),
                command: None,
                source: "poll".to_owned(),
                channel: Some(channel.clone()),
                to: Some(to),
                account_id: account_id.clone(),
                thread_id: thread_id.clone(),
                reply_back: None,
            })
            .await;
        self.channel_runtime
            .mark_outbound(
                channel.as_str(),
                account_id.as_deref().unwrap_or("default"),
                now_ms(),
            )
            .await;

        let message_id = next_send_message_id();
        let poll_id = next_poll_id();
        let mut payload = json!({
            "runId": run_id,
            "messageId": message_id,
            "channel": channel,
            "pollId": poll_id
        });
        payload["transport"] = build_channel_transport_receipt(
            capability,
            ChannelMessageAction::Poll,
            message_id.as_str(),
            Some(to_for_transport.as_str()),
            thread_id.as_deref(),
            None,
            false,
        );
        if let Some(account_id) = account_id {
            payload["accountId"] = json!(account_id);
        }
        if let Some(thread_id) = thread_id {
            payload["threadId"] = json!(thread_id);
        }
        if let Err(err) = self.send.set(cache_key, payload.clone()).await {
            self.system
                .log_line(format!("poll.cache persist failed: {err:?}"))
                .await;
            return RpcDispatchOutcome::internal_error("poll cache persistence failed");
        }
        RpcDispatchOutcome::Handled(payload)
    }

    async fn handle_chat_send(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        if let Err(err) = self.sync_channel_runtime_from_config().await {
            self.system
                .log_line(format!("channel.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("channel runtime unavailable");
        }
        let params = match decode_params::<ChatSendParams>(&req.params) {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!("invalid chat.send params: {err}"));
            }
        };
        let session_key = canonicalize_session_key(&params.session_key);
        if session_key.is_empty() {
            return RpcDispatchOutcome::bad_request("sessionKey is required");
        }
        let run_id = normalize_optional_text(Some(params.idempotency_key), 256);
        let Some(run_id) = run_id else {
            return RpcDispatchOutcome::bad_request("idempotencyKey is required");
        };
        let _thinking = normalize_optional_text(params.thinking, 128);
        let _deliver = params.deliver.unwrap_or(false);
        let sanitized_message = match sanitize_chat_send_message_input(&params.message) {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let stop_command = is_chat_stop_command_text(&sanitized_message);
        let message = normalize_optional_text(Some(sanitized_message), 12_000);
        let has_attachments = params
            .attachments
            .as_ref()
            .map(|value| !value.is_empty())
            .unwrap_or(false);
        if message.is_none() && !has_attachments {
            return RpcDispatchOutcome::bad_request("message or attachment required");
        }
        if stop_command {
            let run_ids = self.chat.abort_session(&session_key).await;
            return RpcDispatchOutcome::Handled(json!({
                "ok": true,
                "aborted": !run_ids.is_empty(),
                "runIds": run_ids
            }));
        }
        let timeout_ms = params.timeout_ms.unwrap_or(30_000);
        match self.chat.start_run(&session_key, &run_id, timeout_ms).await {
            ChatRunStartOutcome::InFlight => {
                return RpcDispatchOutcome::Handled(json!({
                    "runId": run_id,
                    "status": "in_flight"
                }));
            }
            ChatRunStartOutcome::Completed => {
                return RpcDispatchOutcome::Handled(json!({
                    "runId": run_id,
                    "status": "ok"
                }));
            }
            ChatRunStartOutcome::Aborted => {
                return RpcDispatchOutcome::Handled(json!({
                    "runId": run_id,
                    "status": "aborted"
                }));
            }
            ChatRunStartOutcome::Started => {}
        }

        let stored_message = message.or_else(|| has_attachments.then(|| "[attachment]".to_owned()));
        let _ = self
            .sessions
            .record_send(SessionSend {
                session_key,
                request_id: Some(run_id.clone()),
                message: stored_message,
                command: None,
                source: "chat".to_owned(),
                channel: Some("webchat".to_owned()),
                to: None,
                account_id: None,
                thread_id: None,
                reply_back: None,
            })
            .await;
        self.channel_runtime
            .mark_outbound("webchat", "default", now_ms())
            .await;

        RpcDispatchOutcome::Handled(json!({
            "runId": run_id,
            "status": "started"
        }))
    }

    async fn handle_chat_abort(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<ChatAbortParams>(&req.params) {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid chat.abort params: {err}"
                ));
            }
        };
        let session_key = canonicalize_session_key(&params.session_key);
        if session_key.is_empty() {
            return RpcDispatchOutcome::bad_request("sessionKey is required");
        }
        let run_id = normalize_optional_text(params.run_id, 256);
        if let Some(run_id) = run_id {
            return match self.chat.abort_run(&session_key, &run_id).await {
                ChatAbortRunOutcome::SessionMismatch => {
                    RpcDispatchOutcome::bad_request("runId does not match sessionKey")
                }
                ChatAbortRunOutcome::NotFound => RpcDispatchOutcome::Handled(json!({
                    "ok": true,
                    "aborted": false,
                    "runIds": []
                })),
                ChatAbortRunOutcome::Aborted => RpcDispatchOutcome::Handled(json!({
                    "ok": true,
                    "aborted": true,
                    "runIds": [run_id]
                })),
            };
        }
        let run_ids = self.chat.abort_session(&session_key).await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "aborted": !run_ids.is_empty(),
            "runIds": run_ids
        }))
    }

    async fn handle_chat_inject(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        if let Err(err) = self.sync_channel_runtime_from_config().await {
            self.system
                .log_line(format!("channel.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("channel runtime unavailable");
        }
        let params = match decode_params::<ChatInjectParams>(&req.params) {
            Ok(value) => value,
            Err(err) => {
                return RpcDispatchOutcome::bad_request(format!(
                    "invalid chat.inject params: {err}"
                ));
            }
        };
        let requested_session_key = canonicalize_session_key(&params.session_key);
        if requested_session_key.is_empty() {
            return RpcDispatchOutcome::bad_request("sessionKey is required");
        }
        let Some(session_key) = self.sessions.resolve_key(&requested_session_key).await else {
            return RpcDispatchOutcome::bad_request("session not found");
        };
        let Some(message) = normalize_optional_text(Some(params.message), 12_000) else {
            return RpcDispatchOutcome::bad_request("message is required");
        };
        let label = normalize_optional_text(params.label, 64);
        let message_id = next_chat_inject_message_id();
        let run_id = format!("inject-{message_id}");
        let rendered_message = if let Some(label) = label {
            format!("[{label}] {message}")
        } else {
            message
        };
        let _ = self
            .sessions
            .record_send(SessionSend {
                session_key: session_key.clone(),
                request_id: Some(run_id.clone()),
                message: Some(rendered_message.clone()),
                command: None,
                source: "chat.inject".to_owned(),
                channel: Some("webchat".to_owned()),
                to: None,
                account_id: None,
                thread_id: None,
                reply_back: None,
            })
            .await;
        self.channel_runtime
            .mark_outbound("webchat", "default", now_ms())
            .await;
        let parent_id = self
            .sessions
            .history(Some(&session_key), Some(2))
            .await
            .get(1)
            .and_then(|record| normalize_optional_text(record.request_id.clone(), 256));
        let message_payload = json!({
            "id": run_id,
            "parentId": parent_id,
            "role": "assistant",
            "content": rendered_message
        });
        let chat_event_payload = json!({
            "runId": message_payload["id"],
            "sessionKey": session_key,
            "seq": 0,
            "state": "final",
            "message": message_payload
        });
        let payload_json = serde_json::to_string(&chat_event_payload)
            .ok()
            .filter(|value| !value.is_empty());
        self.node_runtime
            .record_event("chat".to_owned(), payload_json)
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "messageId": message_id
        }))
    }

    async fn handle_config_get(&self, _req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_config_runtime_from_config().await {
            self.system
                .log_line(format!("config.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("config runtime unavailable");
        }
        let snapshot = self.config.get_snapshot().await;
        RpcDispatchOutcome::Handled(json!({
            "exists": true,
            "valid": true,
            "path": snapshot.path,
            "raw": snapshot.raw,
            "config": snapshot.config,
            "hash": snapshot.hash,
            "updatedAtMs": snapshot.updated_at_ms
        }))
    }

    async fn handle_config_schema(&self, _req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_config_runtime_from_config().await {
            self.system
                .log_line(format!("config.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("config runtime unavailable");
        }
        RpcDispatchOutcome::Handled(self.config.schema())
    }

    async fn handle_config_set(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_config_runtime_from_config().await {
            self.system
                .log_line(format!("config.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("config runtime unavailable");
        }
        let params = match decode_params::<ConfigWriteParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let Some(raw) = params.raw else {
            return RpcDispatchOutcome::bad_request(
                "invalid config.set params: raw (string) required",
            );
        };
        let updated = match self.config.set(raw, params.base_hash).await {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        if let Err(err) = self.sync_config_runtime_from_config().await {
            self.system
                .log_line(format!("config.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("config runtime unavailable");
        }
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
        }
        self.system.log_line("config.set applied".to_owned()).await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "path": updated.path,
            "config": updated.config,
            "hash": updated.hash
        }))
    }

    async fn handle_config_patch(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_config_runtime_from_config().await {
            self.system
                .log_line(format!("config.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("config runtime unavailable");
        }
        let params = match decode_params::<ConfigWriteParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let Some(raw) = params.raw else {
            return RpcDispatchOutcome::bad_request(
                "invalid config.patch params: raw (string) required",
            );
        };
        let updated = match self.config.patch(raw, params.base_hash).await {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        if let Err(err) = self.sync_config_runtime_from_config().await {
            self.system
                .log_line(format!("config.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("config runtime unavailable");
        }
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
        }
        self.system
            .log_line("config.patch applied".to_owned())
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "path": updated.path,
            "config": updated.config,
            "hash": updated.hash
        }))
    }

    async fn handle_config_apply(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_config_runtime_from_config().await {
            self.system
                .log_line(format!("config.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("config runtime unavailable");
        }
        let params = match decode_params::<ConfigWriteParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let Some(raw) = params.raw else {
            return RpcDispatchOutcome::bad_request(
                "invalid config.apply params: raw (string) required",
            );
        };
        let updated = match self.config.patch(raw, params.base_hash.clone()).await {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        if let Err(err) = self.sync_config_runtime_from_config().await {
            self.system
                .log_line(format!("config.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("config runtime unavailable");
        }
        if let Err(err) = self.sync_agents_runtime_from_config().await {
            self.system
                .log_line(format!("agents.runtime sync failed: {err}"))
                .await;
        }
        self.system
            .log_line("config.apply requested".to_owned())
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "path": updated.path,
            "config": updated.config,
            "hash": updated.hash,
            "restart": {
                "requested": true,
                "sessionKey": normalize_optional_text(params.session_key, 256),
                "note": normalize_optional_text(params.note, 512),
                "restartDelayMs": params.restart_delay_ms.unwrap_or(0)
            }
        }))
    }

    async fn handle_logs_tail(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        let params = match decode_params::<LogsTailParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let limit = params.limit.unwrap_or(500).clamp(1, 5_000);
        let max_bytes = params.max_bytes.unwrap_or(250_000).clamp(1, 1_000_000);
        let tail = self.system.tail_logs(params.cursor, limit, max_bytes).await;
        RpcDispatchOutcome::Handled(json!({
            "file": tail.file,
            "cursor": tail.cursor,
            "size": tail.size,
            "lines": tail.lines,
            "truncated": tail.truncated,
            "reset": tail.reset
        }))
    }

    async fn handle_sessions_list(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsListParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let label = match parse_optional_label_filter(params.label) {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let sessions = self
            .sessions
            .list(SessionListQuery {
                limit: params.limit.unwrap_or(200).clamp(1, 1_000),
                active_minutes: params.active_minutes,
                include_global: params.include_global.unwrap_or(true),
                include_unknown: params.include_unknown.unwrap_or(true),
                search: normalize_optional_text(params.search, 128),
                agent_id: normalize_optional_text(params.agent_id, 64),
                label,
                spawned_by: normalize_optional_text(params.spawned_by, 128),
                channel: normalize_optional_text(params.channel, 128),
                to: normalize_optional_text(params.to, 256),
                account_id: normalize_optional_text(params.account_id, 128),
                thread_id: normalize_optional_text(params.thread_id, 128),
                include_derived_titles: params.include_derived_titles.unwrap_or(false),
                include_last_message: params.include_last_message.unwrap_or(false),
            })
            .await;
        RpcDispatchOutcome::Handled(json!({
            "ts": now_ms(),
            "path": SESSION_STORE_PATH,
            "defaults": {
                "modelProvider": Value::Null,
                "model": Value::Null,
                "contextTokens": Value::Null
            },
            "sessions": sessions,
            "count": sessions.len()
        }))
    }

    async fn handle_sessions_preview(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsPreviewParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let keys = params
            .keys
            .unwrap_or_default()
            .into_iter()
            .filter_map(|v| {
                let requested = v.trim().to_owned();
                if requested.is_empty() {
                    None
                } else {
                    Some(requested)
                }
            })
            .take(64)
            .collect::<Vec<_>>();
        let limit = params.limit.unwrap_or(12).clamp(1, 256);
        let max_chars = params.max_chars.unwrap_or(240).clamp(20, 4096);
        if keys.is_empty() {
            return RpcDispatchOutcome::Handled(json!({
                "ts": now_ms(),
                "previews": []
            }));
        }
        let lookup_keys = keys
            .iter()
            .map(|key| canonicalize_session_key(key))
            .collect::<Vec<_>>();
        let mut previews = self.sessions.preview(&lookup_keys, limit, max_chars).await;
        for (preview, requested) in previews.iter_mut().zip(keys.iter()) {
            preview.key = requested.clone();
        }
        RpcDispatchOutcome::Handled(json!({
            "ts": now_ms(),
            "previews": previews
        }))
    }

    async fn handle_sessions_patch(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsPatchParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let session_key = normalize_session_key_input(params.key.or(params.session_key));
        let Some(session_key) = session_key else {
            return RpcDispatchOutcome::bad_request("sessionKey|key is required");
        };

        let send_policy = match parse_patch_send_policy(param_patch_value(
            &req.params,
            &["sendPolicy", "send_policy"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let group_activation = match parse_patch_group_activation(param_patch_value(
            &req.params,
            &["groupActivation", "group_activation"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let queue_mode = match parse_patch_queue_mode(param_patch_value(
            &req.params,
            &["queueMode", "queue_mode"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let label = match parse_patch_text(param_patch_value(&req.params, &["label"]), "label", 64)
        {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let spawned_by = match parse_patch_text(
            param_patch_value(&req.params, &["spawnedBy", "spawned_by"]),
            "spawnedBy",
            128,
        ) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let spawn_depth = match parse_patch_u32(param_patch_value(
            &req.params,
            &["spawnDepth", "spawn_depth"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let thinking_level = match parse_patch_thinking_level(param_patch_value(
            &req.params,
            &["thinkingLevel", "thinking_level"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let verbose_level = match parse_patch_verbose_level(param_patch_value(
            &req.params,
            &["verboseLevel", "verbose_level"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let reasoning_level = match parse_patch_reasoning_level(param_patch_value(
            &req.params,
            &["reasoningLevel", "reasoning_level"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let response_usage = match parse_patch_response_usage(param_patch_value(
            &req.params,
            &["responseUsage", "response_usage"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let elevated_level = match parse_patch_elevated_level(param_patch_value(
            &req.params,
            &["elevatedLevel", "elevated_level"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let exec_host =
            match parse_patch_exec_host(param_patch_value(&req.params, &["execHost", "exec_host"]))
            {
                Ok(v) => v,
                Err(err) => return RpcDispatchOutcome::bad_request(err),
            };
        let exec_security = match parse_patch_exec_security(param_patch_value(
            &req.params,
            &["execSecurity", "exec_security"],
        )) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let exec_ask =
            match parse_patch_exec_ask(param_patch_value(&req.params, &["execAsk", "exec_ask"])) {
                Ok(v) => v,
                Err(err) => return RpcDispatchOutcome::bad_request(err),
            };
        let exec_node = match parse_patch_text(
            param_patch_value(&req.params, &["execNode", "exec_node"]),
            "execNode",
            64,
        ) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let model_override = match parse_patch_model(param_patch_value(&req.params, &["model"])) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };

        let patched = match self
            .sessions
            .patch(SessionPatch {
                session_key: session_key.clone(),
                send_policy,
                group_activation,
                queue_mode,
                label,
                spawned_by,
                spawn_depth,
                thinking_level,
                verbose_level,
                reasoning_level,
                response_usage,
                elevated_level,
                exec_host,
                exec_security,
                exec_ask,
                exec_node,
                model_override,
            })
            .await
        {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let resolved = self.resolve_session_model_failover(&session_key).await;
        let entry = patched.clone();
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "path": SESSION_STORE_PATH,
            "key": session_key,
            "entry": entry,
            "resolved": resolved,
            "session": patched
        }))
    }

    async fn handle_sessions_resolve(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsResolveParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let candidate = normalize_session_key_input(params.session_key.or(params.key));
        if let Some(candidate) = candidate {
            if let Some(key) = self.sessions.resolve_key(&candidate).await {
                return RpcDispatchOutcome::Handled(json!({
                    "ok": true,
                    "key": key
                }));
            }
            return RpcDispatchOutcome::not_found("session not found");
        }
        if let Some(session_id) = params
            .session_id
            .map(|v| v.trim().to_owned())
            .filter(|v| !v.is_empty())
        {
            if let Some(key) = self.sessions.resolve_session_id(&session_id).await {
                return RpcDispatchOutcome::Handled(json!({
                    "ok": true,
                    "key": key
                }));
            }
            return RpcDispatchOutcome::not_found("session not found");
        }

        let label = match parse_optional_label_filter(params.label) {
            Ok(value) => value,
            Err(err) => return RpcDispatchOutcome::bad_request(err),
        };
        let channel = normalize_optional_text(params.channel, 128);
        let to = normalize_optional_text(params.to, 256);
        let account_id = normalize_optional_text(params.account_id, 128);
        let thread_id = normalize_optional_text(params.thread_id, 128);
        if label.is_none()
            && channel.is_none()
            && to.is_none()
            && account_id.is_none()
            && thread_id.is_none()
        {
            return RpcDispatchOutcome::bad_request(
                "sessionKey|key|sessionId or label is required",
            );
        }

        let key = self
            .sessions
            .resolve_query(SessionResolveQuery {
                label,
                agent_id: normalize_optional_text(params.agent_id, 64),
                spawned_by: normalize_optional_text(params.spawned_by, 64),
                channel,
                to,
                account_id,
                thread_id,
                include_global: params.include_global.unwrap_or(true),
                include_unknown: params.include_unknown.unwrap_or(true),
            })
            .await;
        if let Some(key) = key {
            return RpcDispatchOutcome::Handled(json!({
                "ok": true,
                "key": key
            }));
        }
        RpcDispatchOutcome::not_found("session not found")
    }

    async fn handle_sessions_reset(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsResetParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let session_key = normalize_session_key_input(params.session_key.or(params.key));
        let Some(session_key) = session_key else {
            return RpcDispatchOutcome::bad_request("sessionKey|key is required");
        };

        let reset = self
            .sessions
            .reset(
                &session_key,
                match parse_reset_reason(params.reason) {
                    Ok(value) => value,
                    Err(err) => return RpcDispatchOutcome::bad_request(err),
                },
            )
            .await;
        let entry = reset.session.clone();
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "key": session_key,
            "reset": true,
            "entry": entry,
            "session": reset.session,
            "reason": reset.reason
        }))
    }

    async fn handle_sessions_delete(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsDeleteParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let session_key = normalize_session_key_input(params.session_key.or(params.key));
        let Some(session_key) = session_key else {
            return RpcDispatchOutcome::bad_request("sessionKey|key is required");
        };
        if parse_session_key(&session_key).kind == SessionKind::Main {
            return RpcDispatchOutcome::bad_request("cannot delete main session");
        }

        let deleted = self.sessions.delete(&session_key).await;
        let archived = if deleted && params.delete_transcript.unwrap_or(true) {
            vec![format!(
                "{SESSION_STORE_PATH}/archives/{session_key}.deleted"
            )]
        } else {
            Vec::new()
        };
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "path": SESSION_STORE_PATH,
            "key": session_key,
            "deleted": deleted,
            "archived": archived
        }))
    }

    async fn handle_sessions_compact(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsCompactParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let session_key = normalize_session_key_input(params.session_key.or(params.key));
        let Some(session_key) = session_key else {
            return RpcDispatchOutcome::bad_request("sessionKey|key is required");
        };
        let max_lines = match params.max_lines {
            Some(0) => return RpcDispatchOutcome::bad_request("maxLines must be >= 1"),
            Some(value) => value.min(100_000),
            None => 400,
        };
        let compacted = self.sessions.compact(&session_key, max_lines).await;
        if compacted.compacted {
            let _ = self.refresh_session_auth_profile(&session_key).await;
        }
        let resolved = if self.sessions.get(&session_key).await.is_some() {
            Some(self.resolve_session_model_failover(&session_key).await)
        } else {
            None
        };
        let archived = if compacted.compacted {
            vec![format!(
                "{SESSION_STORE_PATH}/archives/{session_key}.compact"
            )]
        } else {
            Vec::new()
        };
        RpcDispatchOutcome::Handled(json!({
            "ok": true,
            "path": SESSION_STORE_PATH,
            "key": session_key,
            "compacted": compacted.compacted,
            "kept": compacted.kept,
            "removed": compacted.removed,
            "reason": compacted.reason,
            "archived": archived,
            "resolved": resolved
        }))
    }

    async fn handle_sessions_usage(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsUsageParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let session_key = normalize_session_key_input(params.session_key.or(params.key));
        let window = resolve_usage_window(params.start_date, params.end_date, None);
        let usage = self
            .sessions
            .usage(
                session_key.as_deref(),
                params.limit,
                Some((window.start_day, window.end_day)),
                params.include_context_weight.unwrap_or(false),
            )
            .await;
        let total_tokens = usage.iter().map(|item| item.total_requests).sum::<u64>();
        let total_allow = usage.iter().map(|item| item.allowed_count).sum::<u64>();
        let total_review = usage.iter().map(|item| item.review_count).sum::<u64>();
        let total_block = usage.iter().map(|item| item.blocked_count).sum::<u64>();

        let mut by_agent_totals = HashMap::<String, u64>::new();
        let mut by_channel_totals = HashMap::<String, u64>::new();
        for item in &usage {
            if let Some(agent_id) = &item.agent_id {
                let next = by_agent_totals.entry(agent_id.clone()).or_insert(0);
                *next += item.total_requests;
            }
            if let Some(channel) = &item.channel {
                let next = by_channel_totals.entry(channel.clone()).or_insert(0);
                *next += item.total_requests;
            }
        }
        let by_agent = by_agent_totals
            .into_iter()
            .map(|(agent_id, total_tokens)| {
                json!({
                    "agentId": agent_id,
                    "totals": {
                        "input": 0,
                        "output": 0,
                        "cacheRead": 0,
                        "cacheWrite": 0,
                        "totalTokens": total_tokens,
                        "totalCost": 0.0,
                        "inputCost": 0.0,
                        "outputCost": 0.0,
                        "cacheReadCost": 0.0,
                        "cacheWriteCost": 0.0,
                        "missingCostEntries": 0
                    }
                })
            })
            .collect::<Vec<_>>();
        let by_channel = by_channel_totals
            .into_iter()
            .map(|(channel, total_tokens)| {
                json!({
                    "channel": channel,
                    "totals": {
                        "input": 0,
                        "output": 0,
                        "cacheRead": 0,
                        "cacheWrite": 0,
                        "totalTokens": total_tokens,
                        "totalCost": 0.0,
                        "inputCost": 0.0,
                        "outputCost": 0.0,
                        "cacheReadCost": 0.0,
                        "cacheWriteCost": 0.0,
                        "missingCostEntries": 0
                    }
                })
            })
            .collect::<Vec<_>>();

        let updated_at = now_ms();
        RpcDispatchOutcome::Handled(json!({
            "updatedAt": updated_at,
            "generatedAtMs": updated_at,
            "sessionKey": session_key,
            "startDate": window.start_date,
            "endDate": window.end_date,
            "range": {
                "startDate": window.start_date,
                "endDate": window.end_date,
                "days": window.days
            },
            "totals": {
                "input": 0,
                "output": 0,
                "cacheRead": 0,
                "cacheWrite": 0,
                "totalTokens": total_tokens,
                "totalCost": 0.0,
                "inputCost": 0.0,
                "outputCost": 0.0,
                "cacheReadCost": 0.0,
                "cacheWriteCost": 0.0,
                "missingCostEntries": 0
            },
            "aggregates": {
                "messages": {
                    "total": total_tokens,
                    "user": 0,
                    "assistant": 0,
                    "toolCalls": 0,
                    "toolResults": 0,
                    "errors": 0
                },
                "tools": {
                    "totalCalls": 0,
                    "uniqueTools": 0,
                    "tools": []
                },
                "byModel": [],
                "byProvider": [],
                "byAgent": by_agent,
                "byChannel": by_channel,
                "daily": []
            },
            "actions": {
                "allow": total_allow,
                "review": total_review,
                "block": total_block
            },
            "sessions": usage,
            "count": usage.len()
        }))
    }

    async fn handle_sessions_usage_timeseries(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsUsageTimeseriesParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let session_key = normalize_session_key_input(params.session_key.or(params.key));
        let Some(session_key) = session_key else {
            return RpcDispatchOutcome::bad_request("sessionKey|key is required");
        };
        let max_points = params.max_points.unwrap_or(200).clamp(1, 1_000);
        let Some(points) = self
            .sessions
            .usage_timeseries(&session_key, max_points)
            .await
        else {
            return RpcDispatchOutcome::not_found("session not found");
        };
        RpcDispatchOutcome::Handled(json!({
            "key": session_key,
            "points": points,
            "count": points.len()
        }))
    }

    async fn handle_sessions_usage_logs(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsUsageLogsParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let session_key = normalize_session_key_input(params.session_key.or(params.key));
        let Some(session_key) = session_key else {
            return RpcDispatchOutcome::bad_request("sessionKey|key is required");
        };
        let limit = params.limit.unwrap_or(200).clamp(1, 1_000);
        let Some(logs) = self.sessions.usage_logs(&session_key, limit).await else {
            return RpcDispatchOutcome::not_found("session not found");
        };
        RpcDispatchOutcome::Handled(json!({
            "key": session_key,
            "logs": logs,
            "count": logs.len()
        }))
    }

    async fn handle_sessions_history(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionsHistoryParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };

        let session_key = match params
            .session_key
            .or(params.key)
            .map(|value| canonicalize_session_key(&value))
        {
            Some(value) if value.is_empty() => {
                return RpcDispatchOutcome::bad_request("sessionKey|key cannot be empty");
            }
            Some(value) => Some(value),
            None => {
                if let Some(session_id) = params
                    .session_id
                    .map(|value| value.trim().to_owned())
                    .filter(|value| !value.is_empty())
                {
                    let Some(resolved) = self.sessions.resolve_session_id(&session_id).await else {
                        return RpcDispatchOutcome::not_found("session not found");
                    };
                    Some(resolved)
                } else {
                    None
                }
            }
        };

        let history = self
            .sessions
            .history(session_key.as_deref(), params.limit)
            .await;
        RpcDispatchOutcome::Handled(json!({
            "sessionKey": session_key,
            "history": history,
            "count": history.len()
        }))
    }

    async fn handle_sessions_send(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        if let Err(err) = self.sync_channel_runtime_from_config().await {
            self.system
                .log_line(format!("channel.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("channel runtime unavailable");
        }
        let params = match decode_params::<SessionsSendParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        let message = normalize_optional_text(params.message, 2_048);
        let command = normalize_optional_text(params.command, 1_024);
        if message.is_none() && command.is_none() {
            return RpcDispatchOutcome::bad_request("message or command is required");
        }
        let delivery_context_hints = params
            .delivery_context
            .as_ref()
            .map(extract_delivery_context_hints)
            .unwrap_or_default();
        let reply_back = params.reply_back.and_then(|value| value.then_some(true));
        let mut channel = normalize_optional_text(params.channel, 128)
            .or_else(|| delivery_context_hints.channel.clone());
        let mut to =
            normalize_optional_text(params.to, 256).or_else(|| delivery_context_hints.to.clone());
        let mut account_id = normalize_optional_text(params.account_id, 128)
            .or_else(|| delivery_context_hints.account_id.clone());
        let mut thread_id = normalize_optional_text(params.thread_id, 128)
            .or_else(|| delivery_context_hints.thread_id.clone());
        if let Some(canonical) = channel
            .as_deref()
            .and_then(|value| normalize_channel_id(Some(value)))
        {
            channel = Some(canonical);
        }

        let mut session_key = normalize_session_key_input(params.session_key.or(params.key));
        if session_key.is_none() {
            if let Some(session_id) = normalize_optional_text(params.session_id, 128) {
                if let Some(resolved) = self.sessions.resolve_session_id(&session_id).await {
                    session_key = Some(resolved);
                } else {
                    return RpcDispatchOutcome::not_found("session not found");
                }
            }
        }
        if session_key.is_none()
            && reply_back.is_some()
            && (channel.is_some() || to.is_some() || account_id.is_some() || thread_id.is_some())
        {
            session_key = self
                .sessions
                .resolve_query(SessionResolveQuery {
                    label: None,
                    agent_id: None,
                    spawned_by: None,
                    channel: channel.clone(),
                    to: to.clone(),
                    account_id: account_id.clone(),
                    thread_id: thread_id.clone(),
                    include_global: params.include_global.unwrap_or(true),
                    include_unknown: params.include_unknown.unwrap_or(true),
                })
                .await;
            if session_key.is_none() {
                return RpcDispatchOutcome::not_found("session not found");
            }
        }
        let Some(session_key) = session_key else {
            return RpcDispatchOutcome::bad_request("sessionKey|key|sessionId is required");
        };

        if reply_back.is_some() {
            if let Some(existing) = self.sessions.get(&session_key).await {
                if channel.is_none() {
                    channel = existing.channel.clone();
                }
                if to.is_none() {
                    to = existing
                        .delivery_context
                        .as_ref()
                        .and_then(|context| context.to.clone());
                }
                if account_id.is_none() {
                    account_id = existing.last_account_id.clone();
                }
                if thread_id.is_none() {
                    thread_id = existing
                        .delivery_context
                        .as_ref()
                        .and_then(|context| context.thread_id.clone());
                }
            }
            let parsed = parse_session_key(&session_key);
            if channel.is_none() {
                channel = parsed.channel.clone();
            }
            if to.is_none()
                && matches!(
                    parsed.kind,
                    SessionKind::Direct | SessionKind::Group | SessionKind::Channel
                )
            {
                to = parsed.scope_id.clone();
            }
            if thread_id.is_none() {
                thread_id = parsed.topic_id;
            }
        }
        if let Some(canonical) = channel
            .as_deref()
            .and_then(|value| normalize_channel_id(Some(value)))
        {
            channel = Some(canonical);
        }
        if channel
            .as_deref()
            .map(|value| value.eq_ignore_ascii_case("webchat"))
            .unwrap_or(false)
        {
            return RpcDispatchOutcome::bad_request(
                "unsupported channel: webchat (internal-only). Use `chat.send` for WebChat UI messages or choose a deliverable channel.",
            );
        }

        let (session, recorded) = self
            .sessions
            .record_send(SessionSend {
                session_key,
                request_id: params.request_id,
                message,
                command,
                source: normalize_optional_text(params.source, 128)
                    .unwrap_or_else(|| "rpc".to_owned()),
                channel,
                to,
                account_id: account_id.clone(),
                thread_id,
                reply_back,
            })
            .await;
        if let Some(channel) = recorded.channel.as_deref() {
            self.channel_runtime
                .mark_outbound(
                    channel,
                    account_id.as_deref().unwrap_or("default"),
                    now_ms(),
                )
                .await;
        }
        let chunk_count = recorded.text.as_deref().map(|text| {
            let limit = default_text_chunk_limit(recorded.channel.as_deref());
            let mode = default_chunk_mode(recorded.channel.as_deref());
            chunk_text_with_mode(text, limit, mode).len().max(1)
        });
        if let Some(run_id) = recorded
            .request_id
            .clone()
            .and_then(|value| normalize_optional_text(Some(value), 256))
        {
            self.agent_runs.complete_ok(run_id).await;
        }
        let mut payload = json!({
            "accepted": true,
            "session": session,
            "recorded": recorded
        });
        if let Some(chunk_count) = chunk_count {
            payload["chunkCount"] = json!(chunk_count);
        }
        RpcDispatchOutcome::Handled(payload)
    }

    async fn handle_session_status(&self, req: &RpcRequestFrame) -> RpcDispatchOutcome {
        if let Err(err) = self.sync_session_runtime_from_config().await {
            self.system
                .log_line(format!("session.runtime sync failed: {err}"))
                .await;
            return RpcDispatchOutcome::internal_error("session runtime unavailable");
        }
        let params = match decode_params::<SessionStatusParams>(&req.params) {
            Ok(v) => v,
            Err(err) => return RpcDispatchOutcome::bad_request(format!("invalid params: {err}")),
        };
        if let Some(session_key) = normalize_session_key_input(params.session_key) {
            if let Some(session) = self.sessions.get(&session_key).await {
                let resolved = self.resolve_session_model_failover(&session_key).await;
                return RpcDispatchOutcome::Handled(json!({
                    "session": session,
                    "resolved": resolved
                }));
            }
            return RpcDispatchOutcome::not_found("session not found");
        }

        let summary = self.sessions.summary().await;
        RpcDispatchOutcome::Handled(json!({
            "summary": summary
        }))
    }

    async fn refresh_session_auth_profile(&self, session_key: &str) -> Option<SessionView> {
        let state = self.sessions.model_runtime_state(session_key).await?;
        let provider = state.provider_override.as_deref()?;
        let current_profile = state.auth_profile_override.as_deref();

        let source = state.auth_profile_override_source.or_else(|| {
            if state.auth_profile_override_compaction_count.is_some() {
                Some(AuthProfileSource::Auto)
            } else if state.auth_profile_override.is_some() {
                Some(AuthProfileSource::User)
            } else {
                None
            }
        });

        if matches!(source, Some(AuthProfileSource::User)) && current_profile.is_some() {
            return self.sessions.get(session_key).await;
        }

        let stored_compaction = state
            .auth_profile_override_compaction_count
            .unwrap_or(state.compaction_count);
        let should_advance = state.compaction_count > stored_compaction;
        let selection = self
            .auth_profiles
            .select_for_provider(
                provider,
                current_profile,
                state.compaction_count,
                should_advance,
            )
            .await;

        match selection {
            Some(selection) => {
                self.sessions
                    .apply_auth_profile_resolution(
                        session_key,
                        Some(selection.profile_id),
                        Some(AuthProfileSource::Auto),
                        Some(state.compaction_count),
                    )
                    .await
            }
            None => {
                self.sessions
                    .apply_auth_profile_resolution(session_key, None, None, None)
                    .await
            }
        }
    }

    async fn resolve_session_model_failover(
        &self,
        session_key: &str,
    ) -> ModelFailoverResolutionView {
        let state = self.sessions.model_runtime_state(session_key).await;
        let config_snapshot = self.config.get_snapshot().await;
        let catalog = self.models.resolve_catalog(Some(&config_snapshot.config));
        let base = ModelRegistry::primary_model_from_catalog(&catalog);

        let mut primary_provider = state
            .as_ref()
            .and_then(|value| value.provider_override.clone())
            .map(|value| normalize_provider_id(&value))
            .unwrap_or_else(|| base.provider.clone());
        if primary_provider.is_empty() {
            primary_provider = base.provider.clone();
        }

        let mut primary_model = state
            .as_ref()
            .and_then(|value| value.model_override.clone())
            .unwrap_or_else(|| base.id.clone());
        if primary_model.trim().is_empty() {
            primary_model = base.id.clone();
        }

        let fallback_providers = model_provider_failover_chain(&primary_provider);
        let mut provider_chain = Vec::with_capacity(1 + fallback_providers.len());
        provider_chain.push(primary_provider.clone());
        for provider in &fallback_providers {
            if !provider_chain
                .iter()
                .any(|existing| existing.eq_ignore_ascii_case(provider))
            {
                provider_chain.push(provider.clone());
            }
        }

        let mut attempts = Vec::new();
        let mut selected_provider = primary_provider.clone();
        let mut selected_model = primary_model.clone();
        let mut selected_profile = state
            .as_ref()
            .and_then(|value| value.auth_profile_override.clone());
        let compaction_count = state
            .as_ref()
            .map(|value| value.compaction_count)
            .unwrap_or(0);
        let preferred_profile = state
            .as_ref()
            .and_then(|value| value.auth_profile_override.clone());
        let user_locked_profile = state
            .as_ref()
            .and_then(|value| {
                matches!(
                    value.auth_profile_override_source,
                    Some(AuthProfileSource::User)
                )
                .then(|| value.auth_profile_override.clone())
            })
            .flatten();

        for (idx, provider) in provider_chain.iter().enumerate() {
            let model = if idx == 0 {
                primary_model.clone()
            } else {
                ModelRegistry::default_model_for_provider_in_catalog(&catalog, provider)
                    .map(|value| value.id)
                    .unwrap_or_else(|| primary_model.clone())
            };

            if idx == 0 {
                if let Some(profile) = user_locked_profile.clone() {
                    selected_provider = provider.clone();
                    selected_model = model.clone();
                    selected_profile = Some(profile.clone());
                    attempts.push(ModelFailoverAttemptView {
                        provider: provider.clone(),
                        model,
                        auth_profile: Some(profile),
                        status: "ok".to_owned(),
                        reason: None,
                    });
                    break;
                }
            }

            let preferred = if idx == 0 {
                preferred_profile.as_deref()
            } else {
                None
            };
            let selection = self
                .auth_profiles
                .select_for_provider(provider, preferred, compaction_count, false)
                .await;

            match selection {
                Some(selection) if selection.available => {
                    selected_provider = provider.clone();
                    selected_model = model.clone();
                    selected_profile = Some(selection.profile_id.clone());
                    attempts.push(ModelFailoverAttemptView {
                        provider: provider.clone(),
                        model,
                        auth_profile: Some(selection.profile_id),
                        status: "ok".to_owned(),
                        reason: None,
                    });
                    break;
                }
                Some(selection) => {
                    attempts.push(ModelFailoverAttemptView {
                        provider: provider.clone(),
                        model,
                        auth_profile: Some(selection.profile_id),
                        status: "skipped".to_owned(),
                        reason: Some("profile_cooldown".to_owned()),
                    });
                    continue;
                }
                None => {
                    selected_provider = provider.clone();
                    selected_model = model.clone();
                    selected_profile = None;
                    attempts.push(ModelFailoverAttemptView {
                        provider: provider.clone(),
                        model,
                        auth_profile: None,
                        status: "ok".to_owned(),
                        reason: None,
                    });
                    break;
                }
            }
        }

        if attempts.is_empty() {
            attempts.push(ModelFailoverAttemptView {
                provider: selected_provider.clone(),
                model: selected_model.clone(),
                auth_profile: selected_profile.clone(),
                status: "ok".to_owned(),
                reason: None,
            });
        }

        ModelFailoverResolutionView {
            model_provider: selected_provider,
            model: selected_model,
            auth_profile: selected_profile,
            fallback_providers,
            attempts,
        }
    }

    async fn execute_agent_runtime_turn(
        &self,
        input: AgentRuntimeTurnRequest,
    ) -> Result<AgentRuntimeOutcome, String> {
        let AgentRuntimeTurnRequest {
            session_key,
            run_id,
            resolved,
            provider_runtime,
            extra_system_prompt,
            memory_query_text,
            workspace_root,
            config,
        } = input;
        let history = self
            .sessions
            .history(Some(&session_key), Some(AGENT_LLM_TURN_MAX_HISTORY))
            .await;
        let mut messages = build_openai_messages_from_session_history(&history);
        let recall_query_text = normalize_optional_text(memory_query_text, 12_000)
            .or_else(|| latest_user_text_from_session_history(&history));
        let memory_recall = self
            .memory
            .recall(MemoryRecallQuery {
                session_key: session_key.clone(),
                query_text: recall_query_text,
            })
            .await;
        if let Some(memory_prompt) = memory_recall.system_prompt.clone() {
            messages.insert(
                0,
                json!({
                    "role": "system",
                    "content": memory_prompt
                }),
            );
        }
        if let Some(system_prompt) = normalize_optional_text(extra_system_prompt, 8_192) {
            messages.insert(
                0,
                json!({
                    "role": "system",
                    "content": system_prompt
                }),
            );
        }
        if messages.is_empty() {
            return Err("no prompt content available for agent runtime".to_owned());
        }

        let tool_policy = resolve_tool_runtime_policy_config(&config);
        let sandbox_root = workspace_root.join(".sandbox");
        let tool_runtime = ToolRuntimeHost::new(workspace_root, sandbox_root, tool_policy)
            .await
            .map_err(|err| err.message)?;

        let tools = openai_agent_tool_definitions();
        let mut tool_calls_total = 0usize;

        for step in 0..AGENT_LLM_TOOL_LOOP_MAX_STEPS {
            let step_count = step.saturating_add(1);
            let completion = invoke_openai_chat_completion(
                &provider_runtime,
                &resolved.model,
                &messages,
                &tools,
            )
            .await?;
            let choice = completion
                .choices
                .into_iter()
                .next()
                .ok_or_else(|| "provider response missing choices".to_owned())?;
            let assistant_message = choice.message;
            let assistant_text = extract_openai_message_text(assistant_message.content.as_ref());
            if assistant_message.tool_calls.is_empty() {
                return Ok(AgentRuntimeOutcome {
                    assistant_text,
                    execution: AgentRuntimeExecutionView {
                        executed: true,
                        provider: resolved.model_provider.clone(),
                        model: resolved.model.clone(),
                        api_mode: Some(provider_runtime.api_mode.clone()),
                        tool_calls: Some(tool_calls_total),
                        loop_steps: Some(step_count),
                        memory_hits: Some(memory_recall.vector_hits),
                        memory_graph_facts: Some(memory_recall.graph_facts),
                        self_healing: None,
                        reason: None,
                    },
                });
            }

            messages.push(build_openai_assistant_tool_call_message(
                assistant_text.as_deref(),
                &assistant_message.tool_calls,
            ));

            for (tool_index, tool_call) in assistant_message.tool_calls.iter().enumerate() {
                let tool_call_id = tool_call
                    .id
                    .clone()
                    .unwrap_or_else(|| format!("tool-{run_id}-{step}-{tool_index}"));
                let tool_name = normalize_optional_text(Some(tool_call.function.name.clone()), 64)
                    .ok_or_else(|| "tool call name is required".to_owned())?;
                let args = parse_tool_call_arguments(&tool_call.function.arguments)?;
                let request = ToolRuntimeRequest {
                    request_id: format!("{run_id}:{step}:{tool_index}"),
                    session_id: session_key.clone(),
                    tool_name: tool_name.clone(),
                    args,
                    sandboxed: false,
                    model_provider: Some(resolved.model_provider.clone()),
                    model_id: Some(resolved.model.clone()),
                };
                let tool_payload = match tool_runtime.execute(request).await {
                    Ok(result) => {
                        json!({
                            "ok": true,
                            "result": result.result,
                            "warnings": result.warnings
                        })
                    }
                    Err(err) => {
                        json!({
                            "ok": false,
                            "error": {
                                "code": err.code.as_str(),
                                "message": err.message
                            }
                        })
                    }
                };
                let tool_payload_text = serde_json::to_string(&tool_payload).unwrap_or_else(|_| {
                    "{\"ok\":false,\"error\":\"serialization_failed\"}".to_owned()
                });
                let _ = self
                    .sessions
                    .record_send(SessionSend {
                        session_key: session_key.clone(),
                        request_id: Some(run_id.clone()),
                        message: Some(truncate_text(
                            &tool_payload_text,
                            AGENT_TOOL_OUTPUT_MAX_CHARS,
                        )),
                        command: None,
                        source: format!("agent.tool.{tool_name}"),
                        channel: Some("webchat".to_owned()),
                        to: None,
                        account_id: None,
                        thread_id: None,
                        reply_back: None,
                    })
                    .await;
                messages.push(json!({
                    "role": "tool",
                    "tool_call_id": tool_call_id,
                    "content": tool_payload_text
                }));
                tool_calls_total = tool_calls_total.saturating_add(1);
            }
        }

        Err(format!(
            "tool loop exceeded max steps ({AGENT_LLM_TOOL_LOOP_MAX_STEPS})"
        ))
    }
}

impl Default for RpcDispatcher {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub enum RpcDispatchOutcome {
    NotHandled,
    Handled(Value),
    Error {
        code: i64,
        message: String,
        details: Option<Value>,
    },
}

impl RpcDispatchOutcome {
    fn bad_request(message: impl Into<String>) -> Self {
        Self::Error {
            code: 400,
            message: message.into(),
            details: None,
        }
    }

    fn not_found(message: impl Into<String>) -> Self {
        Self::Error {
            code: 404,
            message: message.into(),
            details: None,
        }
    }

    fn internal_error(message: impl Into<String>) -> Self {
        Self::Error {
            code: 500,
            message: message.into(),
            details: None,
        }
    }
}

struct SystemRegistry {
    state: Mutex<SystemState>,
}

#[derive(Debug, Clone)]
struct SystemState {
    heartbeats_enabled: bool,
    last_heartbeat: Option<Value>,
    presence: HashMap<String, Value>,
    logs: VecDeque<String>,
    log_base_cursor: u64,
    log_next_cursor: u64,
}

#[derive(Debug, Clone)]
struct SystemPresenceUpdate {
    text: String,
    device_id: Option<String>,
    instance_id: Option<String>,
    host: Option<String>,
    ip: Option<String>,
    mode: Option<String>,
    version: Option<String>,
    platform: Option<String>,
    device_family: Option<String>,
    model_identifier: Option<String>,
    last_input_seconds: Option<u64>,
    reason: Option<String>,
    roles: Vec<String>,
    scopes: Vec<String>,
    tags: Vec<String>,
}

#[derive(Debug, Clone)]
struct LogTailSnapshot {
    file: String,
    cursor: u64,
    size: u64,
    lines: Vec<String>,
    truncated: bool,
    reset: bool,
}

impl SystemRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(SystemState {
                heartbeats_enabled: true,
                last_heartbeat: None,
                presence: HashMap::new(),
                logs: VecDeque::new(),
                log_base_cursor: 0,
                log_next_cursor: 0,
            }),
        }
    }

    async fn set_heartbeats_enabled(&self, enabled: bool) {
        let mut guard = self.state.lock().await;
        guard.heartbeats_enabled = enabled;
        append_system_log(&mut guard, format!("heartbeats enabled={enabled}"));
    }

    async fn log_line(&self, line: String) {
        let mut guard = self.state.lock().await;
        append_system_log(&mut guard, line);
    }

    async fn last_heartbeat(&self) -> Option<Value> {
        let guard = self.state.lock().await;
        guard.last_heartbeat.clone()
    }

    async fn presence(&self) -> Vec<Value> {
        let guard = self.state.lock().await;
        let mut entries = guard
            .presence
            .iter()
            .map(|(key, value)| (key.clone(), value.clone()))
            .collect::<Vec<_>>();
        entries.sort_by(|a, b| a.0.cmp(&b.0));
        entries.into_iter().map(|(_, value)| value).collect()
    }

    async fn update_last_heartbeat(&self, payload: Value) {
        let mut heartbeat = match payload {
            Value::Object(mut raw) => {
                raw.entry("ts".to_owned())
                    .or_insert_with(|| json!(now_ms()));
                Value::Object(raw)
            }
            Value::Null => json!({
                "ts": now_ms(),
                "status": "unknown"
            }),
            raw => json!({
                "ts": now_ms(),
                "status": "unknown",
                "payload": raw
            }),
        };
        if let Some(status) = heartbeat
            .get("status")
            .and_then(Value::as_str)
            .and_then(|value| normalize_optional_text(Some(value.to_owned()), 64))
        {
            if let Some(map) = heartbeat.as_object_mut() {
                map.insert("status".to_owned(), Value::String(status));
            }
        }
        let mut guard = self.state.lock().await;
        let status = heartbeat
            .get("status")
            .and_then(Value::as_str)
            .unwrap_or("unknown")
            .to_owned();
        guard.last_heartbeat = Some(heartbeat);
        append_system_log(&mut guard, format!("heartbeat status={status}"));
    }

    async fn replace_presence(&self, payload: Value) {
        let mut guard = self.state.lock().await;
        guard.presence.clear();
        for (index, entry) in extract_presence_entries(payload).into_iter().enumerate() {
            if !entry.is_object() {
                continue;
            }
            let key = presence_key_from_value(&entry, index);
            guard.presence.insert(key, entry);
        }
        let count = guard.presence.len();
        append_system_log(&mut guard, format!("presence replaced count={count}"));
    }

    async fn upsert_presence(&self, update: SystemPresenceUpdate) {
        let now = now_ms();
        let mut entry = serde_json::Map::new();
        entry.insert("ts".to_owned(), json!(now));
        entry.insert("text".to_owned(), Value::String(update.text));
        if let Some(value) = update.device_id {
            entry.insert("deviceId".to_owned(), Value::String(value));
        }
        if let Some(value) = update.instance_id {
            entry.insert("instanceId".to_owned(), Value::String(value));
        }
        if let Some(value) = update.host {
            entry.insert("host".to_owned(), Value::String(value));
        }
        if let Some(value) = update.ip {
            entry.insert("ip".to_owned(), Value::String(value));
        }
        if let Some(value) = update.mode {
            entry.insert("mode".to_owned(), Value::String(value));
        }
        if let Some(value) = update.version {
            entry.insert("version".to_owned(), Value::String(value));
        }
        if let Some(value) = update.platform {
            entry.insert("platform".to_owned(), Value::String(value));
        }
        if let Some(value) = update.device_family {
            entry.insert("deviceFamily".to_owned(), Value::String(value));
        }
        if let Some(value) = update.model_identifier {
            entry.insert("modelIdentifier".to_owned(), Value::String(value));
        }
        if let Some(value) = update.last_input_seconds {
            entry.insert("lastInputSeconds".to_owned(), json!(value));
        }
        if let Some(value) = update.reason {
            entry.insert("reason".to_owned(), Value::String(value));
        }
        if !update.roles.is_empty() {
            entry.insert("roles".to_owned(), json!(update.roles));
        }
        if !update.scopes.is_empty() {
            entry.insert("scopes".to_owned(), json!(update.scopes));
        }
        if !update.tags.is_empty() {
            entry.insert("tags".to_owned(), json!(update.tags));
        }
        let key = build_presence_key(&entry, &format!("ts:{now}"));
        let mut guard = self.state.lock().await;
        guard.presence.insert(key, Value::Object(entry));
        let count = guard.presence.len();
        append_system_log(&mut guard, format!("system-event ingested count={count}"));
    }

    async fn tail_logs(
        &self,
        cursor: Option<u64>,
        limit: usize,
        max_bytes: usize,
    ) -> LogTailSnapshot {
        let guard = self.state.lock().await;
        let limit = limit.clamp(1, 5_000);
        let max_bytes = max_bytes.clamp(1, 1_000_000);
        let base = guard.log_base_cursor;
        let next = guard.log_next_cursor;
        let mut reset = false;
        let mut start_cursor = cursor.unwrap_or(base);
        if cursor.is_none() {
            start_cursor = next.saturating_sub(limit as u64);
        } else if start_cursor < base || start_cursor > next {
            reset = true;
            start_cursor = next.saturating_sub(limit as u64);
        }

        let start_index = start_cursor.saturating_sub(base) as usize;
        let mut lines = guard
            .logs
            .iter()
            .skip(start_index)
            .cloned()
            .collect::<Vec<_>>();
        let mut truncated = false;
        if lines.len() > limit {
            lines = lines.split_off(lines.len() - limit);
            truncated = true;
            reset = reset || cursor.is_some();
        }
        let mut bytes = lines
            .iter()
            .map(|line| line.len().saturating_add(1))
            .sum::<usize>();
        if bytes > max_bytes {
            truncated = true;
            while bytes > max_bytes && !lines.is_empty() {
                let removed = lines.remove(0);
                bytes = bytes.saturating_sub(removed.len().saturating_add(1));
            }
            reset = reset || cursor.is_some();
        }

        LogTailSnapshot {
            file: SYSTEM_LOG_PATH.to_owned(),
            cursor: next,
            size: guard
                .logs
                .iter()
                .map(|line| line.len().saturating_add(1) as u64)
                .sum(),
            lines,
            truncated,
            reset,
        }
    }
}

fn append_system_log(state: &mut SystemState, line: String) {
    if state.logs.len() >= MAX_SYSTEM_LOG_LINES {
        let _ = state.logs.pop_front();
        state.log_base_cursor = state.log_base_cursor.saturating_add(1);
    }
    state.logs.push_back(line);
    state.log_next_cursor = state.log_next_cursor.saturating_add(1);
}

fn extract_presence_entries(payload: Value) -> Vec<Value> {
    if let Some(entries) = payload.get("presence").and_then(Value::as_array).cloned() {
        return entries;
    }
    payload.as_array().cloned().unwrap_or_default()
}

fn build_presence_key(entry: &serde_json::Map<String, Value>, fallback: &str) -> String {
    let candidates = ["instanceId", "deviceId", "host", "ip", "text"];
    for field in candidates {
        if let Some(key) = entry
            .get(field)
            .and_then(Value::as_str)
            .map(|value| value.trim())
            .filter(|value| !value.is_empty())
        {
            return format!("presence:{}", normalize(key));
        }
    }
    format!("presence:{}", normalize(fallback))
}

fn presence_key_from_value(value: &Value, index: usize) -> String {
    let Some(map) = value.as_object() else {
        return format!("presence:idx:{index}");
    };
    build_presence_key(map, &format!("idx:{index}"))
}

struct TalkRegistry {
    state: Mutex<TalkState>,
}

#[derive(Debug, Clone)]
struct TalkState {
    enabled: bool,
    phase: Option<String>,
    updated_at_ms: u64,
}

impl TalkRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(TalkState {
                enabled: false,
                phase: None,
                updated_at_ms: now_ms(),
            }),
        }
    }

    async fn set_mode(&self, enabled: bool, phase: Option<String>) -> TalkState {
        let mut guard = self.state.lock().await;
        guard.enabled = enabled;
        guard.phase = phase;
        guard.updated_at_ms = now_ms();
        guard.clone()
    }
}

struct TtsRegistry {
    state: Mutex<TtsState>,
}

#[derive(Debug, Clone)]
struct TtsState {
    enabled: bool,
    auto_mode: String,
    provider: String,
    updated_at_ms: u64,
}

impl TtsRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(TtsState {
                enabled: false,
                auto_mode: "off".to_owned(),
                provider: "edge".to_owned(),
                updated_at_ms: now_ms(),
            }),
        }
    }

    async fn snapshot(&self) -> TtsState {
        let guard = self.state.lock().await;
        guard.clone()
    }

    async fn set_enabled(&self, enabled: bool) -> TtsState {
        let mut guard = self.state.lock().await;
        guard.enabled = enabled;
        guard.updated_at_ms = now_ms();
        guard.clone()
    }

    async fn set_provider(&self, provider: String) -> TtsState {
        let mut guard = self.state.lock().await;
        guard.provider = provider;
        guard.updated_at_ms = now_ms();
        guard.clone()
    }
}

struct VoiceWakeRegistry {
    state: Mutex<VoiceWakeState>,
}

#[derive(Debug, Clone)]
struct VoiceWakeState {
    triggers: Vec<String>,
    updated_at_ms: u64,
}

impl VoiceWakeRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(VoiceWakeState {
                triggers: DEFAULT_VOICEWAKE_TRIGGERS
                    .iter()
                    .map(|value| (*value).to_owned())
                    .collect(),
                updated_at_ms: 0,
            }),
        }
    }

    async fn snapshot(&self) -> VoiceWakeState {
        let guard = self.state.lock().await;
        guard.clone()
    }

    async fn set_triggers(&self, triggers: Vec<String>) -> VoiceWakeState {
        let mut guard = self.state.lock().await;
        guard.triggers = triggers;
        guard.updated_at_ms = now_ms();
        guard.clone()
    }
}

struct VoiceIoRegistry {
    state: Arc<Mutex<VoiceIoState>>,
    capture_worker: Mutex<Option<JoinHandle<()>>>,
    playback_worker: Mutex<Option<JoinHandle<()>>>,
}

#[derive(Debug, Clone)]
struct VoiceIoState {
    input_device: String,
    output_device: String,
    capture_active: bool,
    capture_session_id: Option<String>,
    capture_started_at_ms: Option<u64>,
    capture_last_frame_at_ms: Option<u64>,
    capture_frames: u64,
    playback_active: bool,
    playback_queue_depth: usize,
    playback_last_audio_path: Option<String>,
    playback_last_provider: Option<String>,
    playback_last_started_at_ms: Option<u64>,
    playback_last_completed_at_ms: Option<u64>,
    playback_last_duration_ms: Option<u64>,
    playback_session_id: Option<String>,
    playback_active_until_ms: Option<u64>,
    playback_queue: VecDeque<VoicePlaybackQueuedEntry>,
    updated_at_ms: u64,
}

#[derive(Debug, Clone)]
struct VoicePlaybackQueuedEntry {
    session_id: String,
    audio_path: String,
    provider: String,
    duration_ms: u64,
    output_device: String,
}

impl VoiceIoRegistry {
    fn new() -> Self {
        Self {
            state: Arc::new(Mutex::new(VoiceIoState {
                input_device: VOICE_INPUT_DEVICE_DEFAULT.to_owned(),
                output_device: VOICE_OUTPUT_DEVICE_DEFAULT.to_owned(),
                capture_active: false,
                capture_session_id: None,
                capture_started_at_ms: None,
                capture_last_frame_at_ms: None,
                capture_frames: 0,
                playback_active: false,
                playback_queue_depth: 0,
                playback_last_audio_path: None,
                playback_last_provider: None,
                playback_last_started_at_ms: None,
                playback_last_completed_at_ms: None,
                playback_last_duration_ms: None,
                playback_session_id: None,
                playback_active_until_ms: None,
                playback_queue: VecDeque::new(),
                updated_at_ms: now_ms(),
            })),
            capture_worker: Mutex::new(None),
            playback_worker: Mutex::new(None),
        }
    }

    async fn snapshot(&self) -> VoiceIoState {
        let mut guard = self.state.lock().await;
        Self::refresh_playback_state(&mut guard, now_ms());
        guard.clone()
    }

    async fn set_capture_mode_and_devices(
        &self,
        enabled: bool,
        input_device: Option<&str>,
        output_device: Option<&str>,
    ) -> VoiceIoState {
        let mut guard = self.state.lock().await;
        let now = now_ms();
        Self::refresh_playback_state(&mut guard, now);
        if let Some(device) =
            input_device.and_then(|value| normalize_optional_text(Some(value.to_owned()), 128))
        {
            guard.input_device = device;
        }
        if let Some(device) =
            output_device.and_then(|value| normalize_optional_text(Some(value.to_owned()), 128))
        {
            guard.output_device = device;
        }
        if enabled {
            if guard.capture_session_id.is_none() {
                let sequence = VOICE_CAPTURE_SEQUENCE.fetch_add(1, Ordering::Relaxed) + 1;
                guard.capture_session_id = Some(format!("capture-{now}-{sequence}"));
            }
            guard.capture_active = true;
            if guard.capture_started_at_ms.is_none() {
                guard.capture_started_at_ms = Some(now);
            }
            guard.capture_last_frame_at_ms = Some(now);
            guard.capture_frames = guard.capture_frames.saturating_add(1);
        } else {
            guard.capture_active = false;
        }
        guard.updated_at_ms = now;
        let should_start_worker = enabled;
        let snapshot = guard.clone();
        drop(guard);
        if should_start_worker {
            self.ensure_capture_worker().await;
        } else {
            self.stop_capture_worker().await;
        }
        snapshot
    }

    async fn touch_capture_frame(&self) -> VoiceIoState {
        let mut guard = self.state.lock().await;
        let now = now_ms();
        Self::refresh_playback_state(&mut guard, now);
        if guard.capture_active {
            guard.capture_last_frame_at_ms = Some(now);
            guard.capture_frames = guard.capture_frames.saturating_add(1);
            guard.updated_at_ms = now;
        }
        guard.clone()
    }

    async fn record_playback_with_output(
        &self,
        audio_path: &str,
        provider: &str,
        duration_ms: u64,
        output_device: Option<&str>,
    ) -> VoiceIoState {
        let mut guard = self.state.lock().await;
        let now = now_ms();
        let playback_device = output_device
            .and_then(|value| normalize_optional_text(Some(value.to_owned()), 128))
            .unwrap_or_else(|| guard.output_device.clone());
        let sequence = VOICE_PLAYBACK_SEQUENCE.fetch_add(1, Ordering::Relaxed) + 1;
        guard.playback_queue.push_back(VoicePlaybackQueuedEntry {
            session_id: format!("playback-{now}-{sequence}"),
            audio_path: audio_path.to_owned(),
            provider: provider.to_owned(),
            duration_ms: duration_ms.max(200),
            output_device: playback_device,
        });
        Self::refresh_playback_state(&mut guard, now);
        guard.updated_at_ms = now;
        let snapshot = guard.clone();
        drop(guard);
        self.ensure_playback_worker().await;
        snapshot
    }

    fn refresh_playback_state(state: &mut VoiceIoState, now: u64) {
        let mut updated = false;
        let mut cursor_ms = now;
        loop {
            if state.playback_active {
                let until_ms = state.playback_active_until_ms.unwrap_or(cursor_ms);
                if now >= until_ms {
                    state.playback_active = false;
                    state.playback_last_completed_at_ms = Some(until_ms);
                    state.playback_session_id = None;
                    state.playback_active_until_ms = None;
                    cursor_ms = until_ms;
                    updated = true;
                    continue;
                }
                break;
            }
            let Some(next) = state.playback_queue.pop_front() else {
                break;
            };
            let start_ms = cursor_ms.min(now);
            state.playback_active = true;
            state.playback_session_id = Some(next.session_id);
            state.playback_last_audio_path = Some(next.audio_path);
            state.playback_last_provider = Some(next.provider);
            state.playback_last_started_at_ms = Some(start_ms);
            state.playback_last_duration_ms = Some(next.duration_ms);
            state.playback_active_until_ms = Some(start_ms.saturating_add(next.duration_ms));
            state.output_device = next.output_device;
            updated = true;
            continue;
        }

        state.playback_queue_depth = state.playback_queue.len();
        if state.playback_active {
            state.playback_queue_depth = state.playback_queue_depth.saturating_add(1);
        }
        if updated {
            state.updated_at_ms = now;
        }
    }

    async fn ensure_capture_worker(&self) {
        let mut worker_guard = self.capture_worker.lock().await;
        if worker_guard
            .as_ref()
            .is_some_and(|handle| !handle.is_finished())
        {
            return;
        }
        if let Some(handle) = worker_guard.take() {
            handle.abort();
        }
        let state = Arc::clone(&self.state);
        *worker_guard = Some(tokio::spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_millis(40)).await;
                let mut guard = state.lock().await;
                if !guard.capture_active {
                    break;
                }
                let now = now_ms();
                guard.capture_last_frame_at_ms = Some(now);
                guard.capture_frames = guard.capture_frames.saturating_add(1);
                guard.updated_at_ms = now;
            }
        }));
    }

    async fn stop_capture_worker(&self) {
        let mut worker_guard = self.capture_worker.lock().await;
        if let Some(handle) = worker_guard.take() {
            handle.abort();
        }
    }

    async fn ensure_playback_worker(&self) {
        let mut worker_guard = self.playback_worker.lock().await;
        if worker_guard
            .as_ref()
            .is_some_and(|handle| !handle.is_finished())
        {
            return;
        }
        if let Some(handle) = worker_guard.take() {
            handle.abort();
        }
        let state = Arc::clone(&self.state);
        *worker_guard = Some(tokio::spawn(async move {
            loop {
                let sleep_duration = {
                    let mut guard = state.lock().await;
                    let now = now_ms();
                    VoiceIoRegistry::refresh_playback_state(&mut guard, now);
                    if !guard.playback_active && guard.playback_queue.is_empty() {
                        None
                    } else {
                        let until = guard
                            .playback_active_until_ms
                            .unwrap_or_else(|| now.saturating_add(50));
                        let remaining = until.saturating_sub(now);
                        Some(Duration::from_millis(remaining.clamp(20, 200)))
                    }
                };
                let Some(duration) = sleep_duration else {
                    break;
                };
                tokio::time::sleep(duration).await;
            }
        }));
    }
}

struct ModelRegistry {
    models: Vec<ModelChoice>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct ModelChoice {
    id: String,
    name: String,
    provider: String,
    #[serde(rename = "contextWindow", skip_serializing_if = "Option::is_none")]
    context_window: Option<u32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    reasoning: Option<bool>,
    #[serde(
        rename = "fallbackProviders",
        skip_serializing_if = "Vec::is_empty",
        default
    )]
    fallback_providers: Vec<String>,
}

impl ModelRegistry {
    fn new() -> Self {
        let mut models = vec![
            ModelChoice {
                id: "claude-sonnet-4-5".to_owned(),
                name: "Claude Sonnet 4.5".to_owned(),
                provider: "anthropic".to_owned(),
                context_window: Some(200_000),
                reasoning: Some(true),
                fallback_providers: model_provider_failover_chain("anthropic"),
            },
            ModelChoice {
                id: "claude-haiku-4-5".to_owned(),
                name: "Claude Haiku 4.5".to_owned(),
                provider: "anthropic".to_owned(),
                context_window: Some(200_000),
                reasoning: None,
                fallback_providers: model_provider_failover_chain("anthropic"),
            },
            ModelChoice {
                id: "gpt-5.3".to_owned(),
                name: "gpt-5.3".to_owned(),
                provider: "openai".to_owned(),
                context_window: Some(200_000),
                reasoning: Some(true),
                fallback_providers: model_provider_failover_chain("openai"),
            },
            ModelChoice {
                id: "gpt-5.3-codex".to_owned(),
                name: "gpt-5.3-codex".to_owned(),
                provider: "openai-codex".to_owned(),
                context_window: Some(200_000),
                reasoning: Some(true),
                fallback_providers: model_provider_failover_chain("openai-codex"),
            },
            ModelChoice {
                id: "glm-5-free".to_owned(),
                name: "GLM-5-Free".to_owned(),
                provider: "opencode".to_owned(),
                context_window: Some(131_072),
                reasoning: Some(true),
                fallback_providers: model_provider_failover_chain("opencode"),
            },
            ModelChoice {
                id: "kimi-k2.5-free".to_owned(),
                name: "Kimi K2.5 Free".to_owned(),
                provider: "opencode".to_owned(),
                context_window: Some(128_000),
                reasoning: Some(true),
                fallback_providers: model_provider_failover_chain("opencode"),
            },
            ModelChoice {
                id: "minimax-m2.5-free".to_owned(),
                name: "MiniMax M2.5 Free".to_owned(),
                provider: "opencode".to_owned(),
                context_window: Some(128_000),
                reasoning: Some(true),
                fallback_providers: model_provider_failover_chain("opencode"),
            },
            ModelChoice {
                id: "glm-5".to_owned(),
                name: "GLM-5".to_owned(),
                provider: "zhipuai".to_owned(),
                context_window: Some(128_000),
                reasoning: Some(true),
                fallback_providers: model_provider_failover_chain("zhipuai"),
            },
            ModelChoice {
                id: "google/gemini-2.0-flash-exp:free".to_owned(),
                name: "Gemini 2.0 Flash (OpenRouter Free)".to_owned(),
                provider: "openrouter".to_owned(),
                context_window: None,
                reasoning: None,
                fallback_providers: model_provider_failover_chain("openrouter"),
            },
        ];
        Self::sort_models(&mut models);
        Self { models }
    }

    fn list(&self) -> Vec<ModelChoice> {
        self.models.clone()
    }

    fn resolve_catalog(&self, config: Option<&Value>) -> Vec<ModelChoice> {
        if let Some(config) = config {
            let mut configured = model_catalog_from_config(config);
            if !configured.is_empty() {
                Self::sort_models(&mut configured);
                return configured;
            }
        }
        self.list()
    }

    fn sort_models(models: &mut Vec<ModelChoice>) {
        models.sort_by(|a, b| {
            let provider = a.provider.cmp(&b.provider);
            if provider != std::cmp::Ordering::Equal {
                return provider;
            }
            let name = a.name.cmp(&b.name);
            if name != std::cmp::Ordering::Equal {
                return name;
            }
            a.id.cmp(&b.id)
        });
        models.dedup_by(|a, b| {
            a.id.eq_ignore_ascii_case(&b.id) && a.provider.eq_ignore_ascii_case(&b.provider)
        });
    }

    fn default_model_for_provider_in_catalog(
        catalog: &[ModelChoice],
        provider: &str,
    ) -> Option<ModelChoice> {
        let provider = normalize_provider_id(provider);
        catalog
            .iter()
            .find(|entry| entry.provider.eq_ignore_ascii_case(&provider))
            .cloned()
    }

    fn primary_model_from_catalog(catalog: &[ModelChoice]) -> ModelChoice {
        Self::default_model_for_provider_in_catalog(catalog, DEFAULT_MODEL_PROVIDER)
            .or_else(|| catalog.first().cloned())
            .unwrap_or_else(|| ModelChoice {
                id: DEFAULT_MODEL_ID.to_owned(),
                name: DEFAULT_MODEL_ID.to_owned(),
                provider: DEFAULT_MODEL_PROVIDER.to_owned(),
                context_window: Some(200_000),
                reasoning: Some(true),
                fallback_providers: model_provider_failover_chain(DEFAULT_MODEL_PROVIDER),
            })
    }
}

fn model_catalog_from_config(config: &Value) -> Vec<ModelChoice> {
    let arrays = [
        config.pointer("/models/catalog").and_then(Value::as_array),
        config.pointer("/models/list").and_then(Value::as_array),
        config
            .pointer("/gateway/models/catalog")
            .and_then(Value::as_array),
        config.pointer("/gateway/models").and_then(Value::as_array),
    ];
    let mut models = Vec::new();
    for entries in arrays.into_iter().flatten() {
        if entries.is_empty() {
            continue;
        }
        models.extend(entries.iter().filter_map(model_choice_from_config_entry));
    }
    models.extend(model_catalog_from_provider_entries(config));
    models
}

fn model_catalog_from_provider_entries(config: &Value) -> Vec<ModelChoice> {
    let provider_maps = [
        config
            .pointer("/models/providers")
            .and_then(Value::as_object),
        config
            .pointer("/gateway/models/providers")
            .and_then(Value::as_object),
    ];
    let mut models = Vec::new();
    for provider_map in provider_maps.into_iter().flatten() {
        for (provider_key, provider_value) in provider_map {
            let Some(provider_object) = provider_value.as_object() else {
                continue;
            };
            let provider = normalize_provider_id(provider_key);
            let Some(entries) = provider_object
                .get("models")
                .or_else(|| provider_object.get("catalog"))
                .and_then(Value::as_array)
            else {
                continue;
            };
            for entry in entries {
                if let Some(choice) = model_choice_from_provider_model_entry(&provider, entry) {
                    models.push(choice);
                }
            }
        }
    }
    models
}

fn model_choice_from_provider_model_entry(provider: &str, value: &Value) -> Option<ModelChoice> {
    match value {
        Value::String(raw) => {
            let id = normalize_optional_text(Some(raw.clone()), 256)?;
            let (normalized_provider, normalized_model) = normalize_model_ref(provider, &id);
            Some(ModelChoice {
                id: normalized_model.clone(),
                name: normalized_model,
                provider: normalized_provider.clone(),
                context_window: None,
                reasoning: None,
                fallback_providers: model_provider_failover_chain(&normalized_provider),
            })
        }
        Value::Object(object) => {
            let id = object
                .get("id")
                .or_else(|| object.get("model"))
                .and_then(Value::as_str)
                .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 256))?;
            let (normalized_provider, normalized_model) = normalize_model_ref(provider, &id);
            let name = object
                .get("name")
                .and_then(Value::as_str)
                .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 256))
                .unwrap_or_else(|| normalized_model.clone());
            let context_window = object
                .get("contextWindow")
                .or_else(|| object.get("context_window"))
                .and_then(parse_u32_from_config_value);
            let reasoning = object.get("reasoning").and_then(Value::as_bool);
            let mut fallback_providers = object
                .get("fallbackProviders")
                .or_else(|| object.get("fallback_providers"))
                .and_then(Value::as_array)
                .map(|items| {
                    items
                        .iter()
                        .filter_map(|entry| entry.as_str())
                        .filter_map(|raw| normalize_optional_text(Some(raw.to_owned()), 128))
                        .map(|raw| normalize_provider_id(&raw))
                        .collect::<Vec<_>>()
                })
                .unwrap_or_default();
            if fallback_providers.is_empty() {
                fallback_providers = model_provider_failover_chain(&normalized_provider);
            } else {
                sort_and_dedup_strings(&mut fallback_providers);
                fallback_providers.retain(|raw| !raw.eq_ignore_ascii_case(&normalized_provider));
            }
            Some(ModelChoice {
                id: normalized_model,
                name,
                provider: normalized_provider,
                context_window,
                reasoning,
                fallback_providers,
            })
        }
        _ => None,
    }
}

fn model_choice_from_config_entry(value: &Value) -> Option<ModelChoice> {
    let object = value.as_object()?;
    let id = object
        .get("id")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 256))?;
    let provider = object
        .get("provider")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 128))
        .map(|raw| normalize_provider_id(&raw))?;
    let name = object
        .get("name")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 256))
        .unwrap_or_else(|| id.clone());

    let context_window = object
        .get("contextWindow")
        .or_else(|| object.get("context_window"))
        .and_then(parse_u32_from_config_value);
    let reasoning = object.get("reasoning").and_then(Value::as_bool);

    let mut fallback_providers = object
        .get("fallbackProviders")
        .or_else(|| object.get("fallback_providers"))
        .and_then(Value::as_array)
        .map(|items| {
            items
                .iter()
                .filter_map(|entry| entry.as_str())
                .filter_map(|raw| normalize_optional_text(Some(raw.to_owned()), 128))
                .map(|raw| normalize_provider_id(&raw))
                .filter(|raw| !raw.eq_ignore_ascii_case(&provider))
                .collect::<Vec<_>>()
        })
        .unwrap_or_default();
    if fallback_providers.is_empty() {
        fallback_providers = model_provider_failover_chain(&provider);
    } else {
        sort_and_dedup_strings(&mut fallback_providers);
    }

    Some(ModelChoice {
        id,
        name,
        provider,
        context_window,
        reasoning,
        fallback_providers,
    })
}

fn parse_u32_from_config_value(value: &Value) -> Option<u32> {
    if let Some(raw) = value.as_u64() {
        return u32::try_from(raw).ok();
    }
    value
        .as_str()
        .and_then(|raw| raw.trim().parse::<u32>().ok())
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "lowercase")]
enum AuthProfileSource {
    Auto,
    User,
}

#[derive(Debug, Clone)]
struct AuthProfileRegistry {
    state: Arc<Mutex<AuthProfileState>>,
}

#[derive(Debug, Clone)]
struct AuthProfileState {
    by_provider: HashMap<String, Vec<AuthProfileEntry>>,
}

#[derive(Debug, Clone)]
struct AuthProfileEntry {
    id: String,
    cooldown_until_ms: Option<u64>,
}

impl AuthProfileEntry {
    fn in_cooldown(&self, now_ms: u64) -> bool {
        self.cooldown_until_ms
            .map(|until| now_ms < until)
            .unwrap_or(false)
    }
}

#[derive(Debug, Clone)]
struct AuthProfileSelection {
    profile_id: String,
    available: bool,
}

impl AuthProfileRegistry {
    fn new() -> Self {
        let mut by_provider: HashMap<String, Vec<AuthProfileEntry>> = HashMap::new();
        let mut insert_profiles = |provider: &str, profile_ids: &[&str]| {
            by_provider.insert(
                normalize_provider_id(provider),
                profile_ids
                    .iter()
                    .map(|id| AuthProfileEntry {
                        id: (*id).to_owned(),
                        cooldown_until_ms: None,
                    })
                    .collect(),
            );
        };

        insert_profiles("anthropic", &["anthropic:default", "anthropic:backup"]);
        insert_profiles("openai", &["openai:default", "openai:backup"]);
        insert_profiles("openai-codex", &["openai-codex:default"]);
        insert_profiles("qwen-portal", &["qwen-portal:default"]);
        insert_profiles("zai", &["zai:default"]);
        insert_profiles("zhipuai", &["zhipuai:default"]);
        insert_profiles("zhipuai-coding", &["zhipuai-coding:default"]);
        insert_profiles("opencode", &["opencode:default"]);
        insert_profiles("kimi-coding", &["kimi-coding:default"]);

        Self {
            state: Arc::new(Mutex::new(AuthProfileState { by_provider })),
        }
    }

    async fn select_for_provider(
        &self,
        provider: &str,
        preferred_profile: Option<&str>,
        compaction_count: u64,
        advance_from_preferred: bool,
    ) -> Option<AuthProfileSelection> {
        let provider = normalize_provider_id(provider);
        let now = now_ms();
        let guard = self.state.lock().await;
        let profiles = guard.by_provider.get(&provider)?;
        if profiles.is_empty() {
            return None;
        }

        let preferred_index = preferred_profile.and_then(|preferred| {
            profiles
                .iter()
                .position(|profile| profile.id.eq_ignore_ascii_case(preferred))
        });
        let start_index = preferred_index
            .map(|idx| {
                if advance_from_preferred {
                    (idx + 1) % profiles.len()
                } else {
                    idx
                }
            })
            .unwrap_or((compaction_count as usize) % profiles.len());

        for offset in 0..profiles.len() {
            let idx = (start_index + offset) % profiles.len();
            let profile = &profiles[idx];
            if !profile.in_cooldown(now) {
                return Some(AuthProfileSelection {
                    profile_id: profile.id.clone(),
                    available: true,
                });
            }
        }

        Some(AuthProfileSelection {
            profile_id: profiles[start_index].id.clone(),
            available: false,
        })
    }

    #[cfg(test)]
    async fn set_provider_cooldown_until(&self, provider: &str, cooldown_until_ms: Option<u64>) {
        let provider = normalize_provider_id(provider);
        let mut guard = self.state.lock().await;
        if let Some(profiles) = guard.by_provider.get_mut(&provider) {
            for profile in profiles {
                profile.cooldown_until_ms = cooldown_until_ms;
            }
        }
    }
}

#[derive(Debug, Clone, serde::Serialize)]
struct ModelFailoverAttemptView {
    provider: String,
    model: String,
    #[serde(rename = "authProfile", skip_serializing_if = "Option::is_none")]
    auth_profile: Option<String>,
    status: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    reason: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct ModelFailoverResolutionView {
    #[serde(rename = "modelProvider")]
    model_provider: String,
    model: String,
    #[serde(rename = "authProfile", skip_serializing_if = "Option::is_none")]
    auth_profile: Option<String>,
    #[serde(
        rename = "fallbackProviders",
        default,
        skip_serializing_if = "Vec::is_empty"
    )]
    fallback_providers: Vec<String>,
    attempts: Vec<ModelFailoverAttemptView>,
}

#[derive(Debug, Clone)]
struct ProviderRuntimeConfig {
    provider: String,
    api_mode: String,
    base_url: String,
    api_key: Option<String>,
    allow_missing_api_key: bool,
    website_url: Option<String>,
    bridge_candidates: Vec<String>,
    auth_header_name: String,
    auth_header_prefix: String,
    timeout_ms: u64,
    headers: Vec<(String, String)>,
    request_overrides: serde_json::Map<String, Value>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum RuntimeFeatureProfile {
    Core,
    Edge,
}

impl RuntimeFeatureProfile {
    fn as_str(self) -> &'static str {
        match self {
            Self::Core => "core",
            Self::Edge => "edge",
        }
    }

    fn from_raw(raw: &str) -> Option<Self> {
        match normalize(raw).as_str() {
            "core" => Some(Self::Core),
            "edge" => Some(Self::Edge),
            _ => None,
        }
    }
}

#[derive(Debug, Clone)]
struct AgentSelfHealingRuntimeConfig {
    profile: RuntimeFeatureProfile,
    enabled: bool,
    max_attempts: usize,
    backoff_ms: u64,
}

impl AgentSelfHealingRuntimeConfig {
    fn defaults_for_profile(profile: RuntimeFeatureProfile) -> Self {
        match profile {
            RuntimeFeatureProfile::Core => Self {
                profile,
                enabled: true,
                max_attempts: AGENT_SELF_HEAL_DEFAULT_MAX_ATTEMPTS_CORE,
                backoff_ms: AGENT_SELF_HEAL_DEFAULT_BACKOFF_MS_CORE,
            },
            RuntimeFeatureProfile::Edge => Self {
                profile,
                enabled: true,
                max_attempts: AGENT_SELF_HEAL_DEFAULT_MAX_ATTEMPTS_EDGE,
                backoff_ms: AGENT_SELF_HEAL_DEFAULT_BACKOFF_MS_EDGE,
            },
        }
    }
}

#[derive(Debug, Clone, serde::Serialize)]
struct AgentRuntimeExecutionView {
    executed: bool,
    provider: String,
    model: String,
    #[serde(rename = "apiMode", skip_serializing_if = "Option::is_none")]
    api_mode: Option<String>,
    #[serde(rename = "toolCalls", skip_serializing_if = "Option::is_none")]
    tool_calls: Option<usize>,
    #[serde(rename = "loopSteps", skip_serializing_if = "Option::is_none")]
    loop_steps: Option<usize>,
    #[serde(rename = "memoryHits", skip_serializing_if = "Option::is_none")]
    memory_hits: Option<usize>,
    #[serde(rename = "memoryGraphFacts", skip_serializing_if = "Option::is_none")]
    memory_graph_facts: Option<usize>,
    #[serde(rename = "selfHealing", skip_serializing_if = "Option::is_none")]
    self_healing: Option<AgentRuntimeSelfHealingView>,
    #[serde(skip_serializing_if = "Option::is_none")]
    reason: Option<String>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct AgentRuntimeSelfHealingView {
    enabled: bool,
    recovered: bool,
    #[serde(rename = "profile", skip_serializing_if = "Option::is_none")]
    profile: Option<String>,
    #[serde(rename = "maxAttempts", skip_serializing_if = "Option::is_none")]
    max_attempts: Option<usize>,
    #[serde(rename = "backoffMs", skip_serializing_if = "Option::is_none")]
    backoff_ms: Option<u64>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    attempts: Vec<AgentRuntimeSelfHealingAttemptView>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct AgentRuntimeSelfHealingAttemptView {
    provider: String,
    model: String,
    status: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    reason: Option<String>,
}

#[derive(Debug, Clone)]
struct AgentRuntimeOutcome {
    assistant_text: Option<String>,
    execution: AgentRuntimeExecutionView,
}

#[derive(Debug, Clone)]
struct AgentRuntimeTurnRequest {
    session_key: String,
    run_id: String,
    resolved: ModelFailoverResolutionView,
    provider_runtime: ProviderRuntimeConfig,
    extra_system_prompt: Option<String>,
    memory_query_text: Option<String>,
    workspace_root: PathBuf,
    config: Value,
}

#[derive(Debug, Clone, Deserialize)]
struct OpenAiChatCompletionResponse {
    choices: Vec<OpenAiChatCompletionChoice>,
}

#[derive(Debug, Clone, Deserialize)]
struct OpenAiChatCompletionChoice {
    message: OpenAiChatCompletionMessage,
}

#[derive(Debug, Clone, Deserialize)]
struct OpenAiChatCompletionMessage {
    content: Option<Value>,
    #[serde(default, rename = "tool_calls")]
    tool_calls: Vec<OpenAiChatToolCall>,
}

#[derive(Debug, Clone, Deserialize)]
struct OpenAiChatToolCall {
    id: Option<String>,
    function: OpenAiChatToolFunction,
}

#[derive(Debug, Clone, Deserialize)]
struct OpenAiChatToolFunction {
    name: String,
    arguments: String,
}

struct AgentRegistry {
    state: Mutex<AgentState>,
}

#[derive(Debug, Clone)]
struct AgentState {
    default_id: String,
    main_key: String,
    scope: String,
    entries: HashMap<String, AgentEntry>,
}

#[derive(Debug, Clone)]
struct AgentEntry {
    id: String,
    name: Option<String>,
    workspace: String,
    model: Option<String>,
    identity: Option<AgentIdentityState>,
    files: HashMap<String, AgentFileState>,
}

#[derive(Debug, Clone)]
struct AgentIdentityState {
    name: Option<String>,
    theme: Option<String>,
    emoji: Option<String>,
    avatar: Option<String>,
    avatar_url: Option<String>,
}

#[derive(Debug, Clone)]
struct AgentFileState {
    content: String,
    updated_at_ms: u64,
}

#[derive(Debug, Clone, serde::Serialize)]
struct AgentListSnapshot {
    #[serde(rename = "defaultId")]
    default_id: String,
    #[serde(rename = "mainKey")]
    main_key: String,
    scope: String,
    agents: Vec<AgentSummaryView>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct AgentSummaryView {
    id: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    identity: Option<AgentIdentityView>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct AgentIdentityView {
    #[serde(skip_serializing_if = "Option::is_none")]
    name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    theme: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    emoji: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    avatar: Option<String>,
    #[serde(rename = "avatarUrl", skip_serializing_if = "Option::is_none")]
    avatar_url: Option<String>,
}

#[derive(Debug, Clone)]
struct AgentCreatedResult {
    agent_id: String,
    name: String,
    workspace: String,
}

#[derive(Debug, Clone)]
struct AgentDeleteResult {
    agent_id: String,
    removed_bindings: u64,
}

#[derive(Debug, Clone, serde::Serialize)]
struct AgentFileView {
    name: String,
    path: String,
    missing: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    size: Option<u64>,
    #[serde(rename = "updatedAtMs", skip_serializing_if = "Option::is_none")]
    updated_at_ms: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    content: Option<String>,
}

impl AgentRegistry {
    fn new() -> Self {
        let mut entries = HashMap::new();
        entries.insert(
            DEFAULT_AGENT_ID.to_owned(),
            AgentEntry {
                id: DEFAULT_AGENT_ID.to_owned(),
                name: Some(DEFAULT_AGENT_NAME.to_owned()),
                workspace: DEFAULT_AGENT_WORKSPACE.to_owned(),
                model: None,
                identity: Some(AgentIdentityState {
                    name: Some(DEFAULT_AGENT_IDENTITY_NAME.to_owned()),
                    theme: Some(DEFAULT_AGENT_IDENTITY_THEME.to_owned()),
                    emoji: Some(DEFAULT_AGENT_IDENTITY_EMOJI.to_owned()),
                    avatar: Some(DEFAULT_AGENT_IDENTITY_AVATAR.to_owned()),
                    avatar_url: Some(DEFAULT_AGENT_IDENTITY_AVATAR_URL.to_owned()),
                }),
                files: HashMap::new(),
            },
        );
        Self {
            state: Mutex::new(AgentState {
                default_id: DEFAULT_AGENT_ID.to_owned(),
                main_key: DEFAULT_MAIN_KEY.to_owned(),
                scope: DEFAULT_AGENT_SCOPE.to_owned(),
                entries,
            }),
        }
    }

    async fn sync_from_config(&self, config: &Value) -> Result<(), String> {
        let mut next = agent_state_from_config(config);
        let mut guard = self.state.lock().await;
        for (agent_id, entry) in &guard.entries {
            if let Some(next_entry) = next.entries.get_mut(agent_id) {
                if agent_workspace_is_memory(&next_entry.workspace) {
                    next_entry.files = entry.files.clone();
                }
            }
        }
        *guard = next;
        Ok(())
    }

    async fn contains(&self, raw_agent_id: &str) -> bool {
        let agent_id = normalize_agent_id(raw_agent_id);
        let guard = self.state.lock().await;
        guard.entries.contains_key(&agent_id)
    }

    async fn workspace_for(&self, raw_agent_id: &str) -> Option<String> {
        let agent_id = normalize_agent_id(raw_agent_id);
        let guard = self.state.lock().await;
        guard
            .entries
            .get(&agent_id)
            .map(|entry| entry.workspace.clone())
    }

    async fn identity(&self, requested_agent_id: Option<String>) -> Result<Value, String> {
        let agent_id = requested_agent_id
            .map(|value| normalize_agent_id(&value))
            .unwrap_or_else(|| DEFAULT_AGENT_ID.to_owned());
        let guard = self.state.lock().await;
        let Some(entry) = guard.entries.get(&agent_id) else {
            return Err(format!(
                "invalid agent.identity.get params: unknown agent id \"{agent_id}\""
            ));
        };
        let name = entry
            .identity
            .as_ref()
            .and_then(|identity| identity.name.clone())
            .or_else(|| entry.name.clone());
        let emoji = entry
            .identity
            .as_ref()
            .and_then(|identity| identity.emoji.clone());
        let avatar = entry
            .identity
            .as_ref()
            .and_then(|identity| identity.avatar_url.clone())
            .or_else(|| {
                entry
                    .identity
                    .as_ref()
                    .and_then(|identity| identity.avatar.clone())
            });
        let mut payload = serde_json::Map::new();
        payload.insert("agentId".to_owned(), Value::String(agent_id));
        if let Some(name) = name {
            payload.insert("name".to_owned(), Value::String(name));
        }
        if let Some(avatar) = avatar {
            payload.insert("avatar".to_owned(), Value::String(avatar));
        }
        if let Some(emoji) = emoji {
            payload.insert("emoji".to_owned(), Value::String(emoji));
        }
        Ok(Value::Object(payload))
    }

    async fn list(&self) -> AgentListSnapshot {
        let guard = self.state.lock().await;
        let mut ids = guard.entries.keys().cloned().collect::<Vec<_>>();
        ids.sort_by(|a, b| {
            if a.eq_ignore_ascii_case(&guard.default_id) {
                return std::cmp::Ordering::Less;
            }
            if b.eq_ignore_ascii_case(&guard.default_id) {
                return std::cmp::Ordering::Greater;
            }
            a.cmp(b)
        });
        let agents = ids
            .into_iter()
            .filter_map(|id| guard.entries.get(&id))
            .map(agent_summary_from_entry)
            .collect::<Vec<_>>();
        AgentListSnapshot {
            default_id: guard.default_id.clone(),
            main_key: guard.main_key.clone(),
            scope: guard.scope.clone(),
            agents,
        }
    }

    async fn create(&self, params: AgentsCreateParams) -> Result<AgentCreatedResult, String> {
        let name = normalize_optional_text(Some(params.name), 128)
            .ok_or_else(|| "name is required".to_owned())?;
        let workspace = normalize_optional_text(Some(params.workspace), 512)
            .ok_or_else(|| "workspace is required".to_owned())?;
        let agent_id = normalize_agent_id(&name);
        if agent_id.eq_ignore_ascii_case(DEFAULT_AGENT_ID) {
            return Err(format!("\"{DEFAULT_AGENT_ID}\" is reserved"));
        }
        let emoji = normalize_optional_text(params.emoji, 32);
        let avatar = normalize_optional_text(params.avatar, 128);
        let identity = AgentIdentityState {
            name: Some(name.clone()),
            theme: None,
            emoji,
            avatar,
            avatar_url: None,
        };
        if !agent_workspace_is_memory(&workspace) {
            ensure_agent_workspace_on_disk(&workspace, Some(&identity))?;
        }

        let mut guard = self.state.lock().await;
        if guard.entries.contains_key(&agent_id) {
            return Err(format!("agent \"{agent_id}\" already exists"));
        }
        guard.entries.insert(
            agent_id.clone(),
            AgentEntry {
                id: agent_id.clone(),
                name: Some(name.clone()),
                workspace: workspace.clone(),
                model: None,
                identity: Some(identity),
                files: HashMap::new(),
            },
        );
        Ok(AgentCreatedResult {
            agent_id,
            name,
            workspace,
        })
    }

    async fn update(&self, params: AgentsUpdateParams) -> Result<String, String> {
        let agent_id = normalize_agent_id(&params.agent_id);
        let pending_workspace = match params.workspace.clone() {
            Some(workspace) => Some(
                normalize_optional_text(Some(workspace), 512)
                    .ok_or_else(|| "workspace must be a non-empty string".to_owned())?,
            ),
            None => None,
        };
        if let Some(workspace) = pending_workspace.as_deref() {
            if !agent_workspace_is_memory(workspace) {
                ensure_agent_workspace_on_disk(workspace, None)?;
            }
        }
        let mut guard = self.state.lock().await;
        let Some(entry) = guard.entries.get_mut(&agent_id) else {
            return Err(format!("agent \"{agent_id}\" not found"));
        };

        if let Some(name) = normalize_optional_text(params.name.clone(), 128) {
            entry.name = Some(name.clone());
            upsert_agent_identity(entry, |identity| {
                identity.name = Some(name.clone());
            });
        }
        if let Some(workspace) = pending_workspace {
            entry.workspace = workspace;
        }
        if let Some(model) = normalize_optional_text(params.model.clone(), 256) {
            entry.model = Some(model);
        }
        if let Some(avatar) = normalize_optional_text(params.avatar.clone(), 256) {
            upsert_agent_identity(entry, |identity| {
                identity.avatar = Some(avatar.clone());
            });
        }
        let workspace = entry.workspace.clone();
        let identity = entry.identity.clone();
        drop(guard);
        if !agent_workspace_is_memory(&workspace) {
            ensure_agent_workspace_on_disk(&workspace, identity.as_ref())?;
        }
        Ok(agent_id)
    }

    async fn delete(&self, params: AgentsDeleteParams) -> Result<AgentDeleteResult, String> {
        let agent_id = normalize_agent_id(&params.agent_id);
        if agent_id.eq_ignore_ascii_case(DEFAULT_AGENT_ID) {
            return Err(format!("\"{DEFAULT_AGENT_ID}\" cannot be deleted"));
        }
        let delete_files = params.delete_files.unwrap_or(true);

        let mut guard = self.state.lock().await;
        let removed = guard.entries.remove(&agent_id);
        let workspace = removed.as_ref().map(|entry| entry.workspace.clone());
        if removed.is_none() {
            return Err(format!("agent \"{agent_id}\" not found"));
        }
        drop(guard);
        if delete_files {
            if let Some(workspace) = workspace {
                remove_agent_workspace_best_effort(&workspace);
            }
        }
        Ok(AgentDeleteResult {
            agent_id,
            removed_bindings: 1,
        })
    }

    async fn list_files(
        &self,
        params: AgentsFilesListParams,
    ) -> Result<(String, String, Vec<AgentFileView>), String> {
        let agent_id = normalize_agent_id(&params.agent_id);
        let entry = {
            let guard = self.state.lock().await;
            let Some(entry) = guard.entries.get(&agent_id) else {
                return Err("unknown agent id".to_owned());
            };
            entry.clone()
        };

        let mut files = Vec::new();
        for name in AGENT_BOOTSTRAP_FILE_NAMES {
            files.push(agent_file_view_for_entry(&entry, name, false)?);
        }
        if agent_workspace_file_exists(&entry.workspace, AGENT_PRIMARY_MEMORY_FILE_NAME, &entry) {
            files.push(agent_file_view_for_entry(
                &entry,
                AGENT_PRIMARY_MEMORY_FILE_NAME,
                false,
            )?);
        } else if agent_workspace_file_exists(&entry.workspace, AGENT_ALT_MEMORY_FILE_NAME, &entry)
        {
            files.push(agent_file_view_for_entry(
                &entry,
                AGENT_ALT_MEMORY_FILE_NAME,
                false,
            )?);
        } else {
            files.push(agent_file_view_for_entry(
                &entry,
                AGENT_PRIMARY_MEMORY_FILE_NAME,
                false,
            )?);
        }

        Ok((agent_id, entry.workspace.clone(), files))
    }

    async fn get_file(
        &self,
        params: AgentsFilesGetParams,
    ) -> Result<(String, String, AgentFileView), String> {
        let agent_id = normalize_agent_id(&params.agent_id);
        let name = normalize_optional_text(Some(params.name), 128)
            .ok_or_else(|| "unsupported file \"\"".to_owned())?;
        if !is_allowed_agent_file_name(&name) {
            return Err(format!("unsupported file \"{name}\""));
        }

        let entry = {
            let guard = self.state.lock().await;
            let Some(entry) = guard.entries.get(&agent_id) else {
                return Err("unknown agent id".to_owned());
            };
            entry.clone()
        };
        let file = agent_file_view_for_entry(&entry, &name, true)?;
        Ok((agent_id, entry.workspace.clone(), file))
    }

    async fn set_file(
        &self,
        params: AgentsFilesSetParams,
    ) -> Result<(String, String, AgentFileView), String> {
        let agent_id = normalize_agent_id(&params.agent_id);
        let name = normalize_optional_text(Some(params.name), 128)
            .ok_or_else(|| "unsupported file \"\"".to_owned())?;
        if !is_allowed_agent_file_name(&name) {
            return Err(format!("unsupported file \"{name}\""));
        }
        let content = params.content;
        let workspace = {
            let guard = self.state.lock().await;
            let Some(entry) = guard.entries.get(&agent_id) else {
                return Err("unknown agent id".to_owned());
            };
            entry.workspace.clone()
        };
        if !agent_workspace_is_memory(&workspace) {
            write_agent_workspace_file(&workspace, &name, &content)?;
            let file = read_agent_workspace_file(&workspace, &name, true, None)?.unwrap_or(
                AgentFileView {
                    name: name.clone(),
                    path: agent_workspace_file_path(&workspace, &name),
                    missing: false,
                    size: Some(content.len() as u64),
                    updated_at_ms: Some(now_ms()),
                    content: Some(content),
                },
            );
            return Ok((agent_id, workspace, file));
        }

        let mut guard = self.state.lock().await;
        let Some(entry) = guard.entries.get_mut(&agent_id) else {
            return Err("unknown agent id".to_owned());
        };
        let now = now_ms();
        entry.files.insert(
            name.clone(),
            AgentFileState {
                content,
                updated_at_ms: now,
            },
        );
        let file = agent_file_view_from_state(entry, &name, true);
        Ok((agent_id, entry.workspace.clone(), file))
    }
}

fn upsert_agent_identity<F>(entry: &mut AgentEntry, mut mutate: F)
where
    F: FnMut(&mut AgentIdentityState),
{
    let mut identity = entry.identity.clone().unwrap_or(AgentIdentityState {
        name: None,
        theme: None,
        emoji: None,
        avatar: None,
        avatar_url: None,
    });
    mutate(&mut identity);
    entry.identity = Some(identity);
}

fn agent_summary_from_entry(entry: &AgentEntry) -> AgentSummaryView {
    let _has_model_override = entry.model.is_some();
    AgentSummaryView {
        id: entry.id.clone(),
        name: entry.name.clone(),
        identity: entry.identity.as_ref().map(|identity| AgentIdentityView {
            name: identity.name.clone(),
            theme: identity.theme.clone(),
            emoji: identity.emoji.clone(),
            avatar: identity.avatar.clone(),
            avatar_url: identity.avatar_url.clone(),
        }),
    }
}

fn agent_file_view_from_state(
    entry: &AgentEntry,
    name: &str,
    include_content: bool,
) -> AgentFileView {
    let path = agent_workspace_file_path(&entry.workspace, name);
    if let Some(file) = entry.files.get(name) {
        return AgentFileView {
            name: name.to_owned(),
            path,
            missing: false,
            size: Some(file.content.len() as u64),
            updated_at_ms: Some(file.updated_at_ms),
            content: include_content.then(|| file.content.clone()),
        };
    }
    AgentFileView {
        name: name.to_owned(),
        path,
        missing: true,
        size: None,
        updated_at_ms: None,
        content: None,
    }
}

fn agent_workspace_file_path(workspace: &str, name: &str) -> String {
    if agent_workspace_is_memory(workspace) {
        let trimmed = workspace
            .trim()
            .trim_end_matches('/')
            .trim_end_matches('\\')
            .to_owned();
        if trimmed.is_empty() {
            return name.to_owned();
        }
        return format!("{trimmed}/{name}");
    }
    Path::new(workspace)
        .join(name)
        .to_string_lossy()
        .to_string()
}

fn agent_file_view_for_entry(
    entry: &AgentEntry,
    name: &str,
    include_content: bool,
) -> Result<AgentFileView, String> {
    if agent_workspace_is_memory(&entry.workspace) {
        return Ok(agent_file_view_from_state(entry, name, include_content));
    }
    let from_disk = read_agent_workspace_file(&entry.workspace, name, include_content, Some(name))?;
    Ok(from_disk.unwrap_or(AgentFileView {
        name: name.to_owned(),
        path: agent_workspace_file_path(&entry.workspace, name),
        missing: true,
        size: None,
        updated_at_ms: None,
        content: None,
    }))
}

fn read_agent_workspace_file(
    workspace: &str,
    name: &str,
    include_content: bool,
    output_name: Option<&str>,
) -> Result<Option<AgentFileView>, String> {
    let path = Path::new(workspace).join(name);
    let path_text = path.to_string_lossy().to_string();
    let metadata = match std::fs::metadata(&path) {
        Ok(metadata) => metadata,
        Err(err) if err.kind() == std::io::ErrorKind::NotFound => return Ok(None),
        Err(err) => {
            return Err(format!(
                "failed reading agent file metadata {path_text}: {err}"
            ))
        }
    };
    if !metadata.is_file() {
        return Ok(None);
    }
    let updated_at_ms = metadata
        .modified()
        .ok()
        .and_then(|value| {
            value
                .duration_since(UNIX_EPOCH)
                .ok()
                .map(|duration| duration.as_millis() as u64)
        })
        .unwrap_or_else(now_ms);
    let content = if include_content {
        Some(
            std::fs::read_to_string(&path)
                .map_err(|err| format!("failed reading agent file {path_text}: {err}"))?,
        )
    } else {
        None
    };
    Ok(Some(AgentFileView {
        name: output_name.unwrap_or(name).to_owned(),
        path: path_text,
        missing: false,
        size: Some(metadata.len()),
        updated_at_ms: Some(updated_at_ms),
        content,
    }))
}

fn write_agent_workspace_file(workspace: &str, name: &str, content: &str) -> Result<(), String> {
    std::fs::create_dir_all(workspace)
        .map_err(|err| format!("failed creating workspace directory {workspace}: {err}"))?;
    let path = Path::new(workspace).join(name);
    std::fs::write(&path, content)
        .map_err(|err| format!("failed writing agent file {}: {err}", path.display()))
}

fn agent_workspace_file_exists(workspace: &str, name: &str, entry: &AgentEntry) -> bool {
    if agent_workspace_is_memory(workspace) {
        return entry.files.contains_key(name);
    }
    std::fs::metadata(Path::new(workspace).join(name))
        .map(|metadata| metadata.is_file())
        .unwrap_or(false)
}

fn agent_workspace_is_memory(workspace: &str) -> bool {
    normalize(workspace).starts_with("memory://")
}

fn ensure_agent_workspace_on_disk(
    workspace: &str,
    identity: Option<&AgentIdentityState>,
) -> Result<(), String> {
    std::fs::create_dir_all(workspace)
        .map_err(|err| format!("failed creating workspace directory {workspace}: {err}"))?;
    for name in AGENT_BOOTSTRAP_FILE_NAMES {
        if *name == "IDENTITY.md" {
            continue;
        }
        let path = Path::new(workspace).join(name);
        if path.exists() {
            continue;
        }
        std::fs::write(&path, "")
            .map_err(|err| format!("failed creating bootstrap file {}: {err}", path.display()))?;
    }
    let identity_path = Path::new(workspace).join("IDENTITY.md");
    if let Some(identity) = identity {
        let rendered = render_agent_identity_markdown(identity);
        if !rendered.trim().is_empty() {
            std::fs::write(&identity_path, rendered).map_err(|err| {
                format!(
                    "failed writing identity bootstrap file {}: {err}",
                    identity_path.display()
                )
            })?;
            return Ok(());
        }
    }
    if !identity_path.exists() {
        std::fs::write(&identity_path, "").map_err(|err| {
            format!(
                "failed creating identity bootstrap file {}: {err}",
                identity_path.display()
            )
        })?;
    }
    Ok(())
}

fn render_agent_identity_markdown(identity: &AgentIdentityState) -> String {
    let mut lines = Vec::new();
    if let Some(name) = identity
        .name
        .as_ref()
        .and_then(|value| normalize_optional_text(Some(value.clone()), 256))
    {
        lines.push(format!("- Name: {name}"));
    }
    if let Some(theme) = identity
        .theme
        .as_ref()
        .and_then(|value| normalize_optional_text(Some(value.clone()), 128))
    {
        lines.push(format!("- Theme: {theme}"));
    }
    if let Some(emoji) = identity
        .emoji
        .as_ref()
        .and_then(|value| normalize_optional_text(Some(value.clone()), 128))
    {
        lines.push(format!("- Emoji: {emoji}"));
    }
    if let Some(avatar) = identity
        .avatar
        .as_ref()
        .and_then(|value| normalize_optional_text(Some(value.clone()), 512))
    {
        lines.push(format!("- Avatar: {avatar}"));
    }
    if lines.is_empty() {
        String::new()
    } else {
        format!("{}\n", lines.join("\n"))
    }
}

fn remove_agent_workspace_best_effort(workspace: &str) {
    if agent_workspace_is_memory(workspace) {
        return;
    }
    let path = PathBuf::from(workspace);
    if path.parent().is_none() {
        return;
    }
    let _ = std::fs::remove_dir_all(path);
}

fn agent_state_from_config(config: &Value) -> AgentState {
    let main_key = config
        .pointer("/session/mainKey")
        .or_else(|| config.pointer("/session/main_key"))
        .and_then(Value::as_str)
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 64))
        .unwrap_or_else(|| DEFAULT_MAIN_KEY.to_owned());
    let scope = config
        .pointer("/session/scope")
        .and_then(Value::as_str)
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 64))
        .unwrap_or_else(|| DEFAULT_AGENT_SCOPE.to_owned());
    let default_workspace = config
        .pointer("/agents/defaults/workspace")
        .or_else(|| config.pointer("/agents/defaults/workspaceDir"))
        .or_else(|| config.pointer("/agents/defaults/workspace_dir"))
        .and_then(Value::as_str)
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 512));
    let default_model = config
        .pointer("/agents/defaults/model")
        .and_then(parse_agent_model_value);

    let list_entries = config
        .pointer("/agents/list")
        .and_then(Value::as_array)
        .cloned()
        .unwrap_or_default();
    let default_id_from_list = list_entries.iter().find_map(|entry| {
        let object = entry.as_object()?;
        if object.get("default").and_then(Value::as_bool) != Some(true) {
            return None;
        }
        object
            .get("id")
            .and_then(Value::as_str)
            .map(normalize_agent_id)
    });

    let mut entries = HashMap::new();
    for entry in &list_entries {
        let Some(object) = entry.as_object() else {
            continue;
        };
        let Some(raw_id) = object.get("id").and_then(Value::as_str) else {
            continue;
        };
        let id = normalize_agent_id(raw_id);
        let name = object
            .get("name")
            .and_then(Value::as_str)
            .and_then(|value| normalize_optional_text(Some(value.to_owned()), 128));
        let workspace = object
            .get("workspace")
            .or_else(|| object.get("workspaceDir"))
            .or_else(|| object.get("workspace_dir"))
            .and_then(Value::as_str)
            .and_then(|value| normalize_optional_text(Some(value.to_owned()), 512))
            .or_else(|| {
                if id.eq_ignore_ascii_case(DEFAULT_AGENT_ID) {
                    default_workspace.clone()
                } else {
                    None
                }
            })
            .unwrap_or_else(|| format!("memory://agents/{id}"));
        let model = object
            .get("model")
            .and_then(parse_agent_model_value)
            .or_else(|| default_model.clone());
        let identity = object
            .get("identity")
            .and_then(parse_agent_identity_state_from_config);
        entries.insert(
            id.clone(),
            AgentEntry {
                id,
                name,
                workspace,
                model,
                identity,
                files: HashMap::new(),
            },
        );
    }

    let default_id = default_id_from_list
        .or_else(|| {
            list_entries.iter().find_map(|entry| {
                entry
                    .get("id")
                    .and_then(Value::as_str)
                    .map(normalize_agent_id)
            })
        })
        .unwrap_or_else(|| DEFAULT_AGENT_ID.to_owned());
    if !entries.contains_key(&default_id) {
        entries.insert(default_id.clone(), default_agent_entry(&default_id));
    }
    if !entries.contains_key(&main_key) {
        entries.insert(main_key.clone(), default_agent_entry(&main_key));
    }

    AgentState {
        default_id,
        main_key,
        scope,
        entries,
    }
}

fn default_agent_entry(agent_id: &str) -> AgentEntry {
    let normalized = normalize_agent_id(agent_id);
    if normalized.eq_ignore_ascii_case(DEFAULT_AGENT_ID) {
        AgentEntry {
            id: DEFAULT_AGENT_ID.to_owned(),
            name: Some(DEFAULT_AGENT_NAME.to_owned()),
            workspace: DEFAULT_AGENT_WORKSPACE.to_owned(),
            model: None,
            identity: Some(AgentIdentityState {
                name: Some(DEFAULT_AGENT_IDENTITY_NAME.to_owned()),
                theme: Some(DEFAULT_AGENT_IDENTITY_THEME.to_owned()),
                emoji: Some(DEFAULT_AGENT_IDENTITY_EMOJI.to_owned()),
                avatar: Some(DEFAULT_AGENT_IDENTITY_AVATAR.to_owned()),
                avatar_url: Some(DEFAULT_AGENT_IDENTITY_AVATAR_URL.to_owned()),
            }),
            files: HashMap::new(),
        }
    } else {
        AgentEntry {
            id: normalized.clone(),
            name: Some(normalized.clone()),
            workspace: format!("memory://agents/{normalized}"),
            model: None,
            identity: Some(AgentIdentityState {
                name: Some(normalized),
                theme: None,
                emoji: None,
                avatar: None,
                avatar_url: None,
            }),
            files: HashMap::new(),
        }
    }
}

fn parse_agent_identity_state_from_config(value: &Value) -> Option<AgentIdentityState> {
    let object = value.as_object()?;
    let name = object
        .get("name")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 128));
    let theme = object
        .get("theme")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 128));
    let emoji = object
        .get("emoji")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 128));
    let avatar = object
        .get("avatar")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 512));
    let avatar_url = object
        .get("avatarUrl")
        .or_else(|| object.get("avatar_url"))
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 1024));
    if name.is_none()
        && theme.is_none()
        && emoji.is_none()
        && avatar.is_none()
        && avatar_url.is_none()
    {
        return None;
    }
    Some(AgentIdentityState {
        name,
        theme,
        emoji,
        avatar,
        avatar_url,
    })
}

fn parse_agent_model_value(value: &Value) -> Option<String> {
    if let Some(raw) = value.as_str() {
        return normalize_optional_text(Some(raw.to_owned()), 256);
    }
    value
        .as_object()
        .and_then(|object| object.get("primary"))
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 256))
}

fn apply_agent_create_to_config(
    config: &mut Value,
    created: &AgentCreatedResult,
    emoji: Option<&str>,
    avatar: Option<&str>,
) {
    let default_id = current_default_agent_id_from_config(config);
    let root = ensure_value_object(config);
    let agents = ensure_object_field(root, "agents");
    let list = ensure_array_field(agents, "list");
    let agent_id = normalize_agent_id(&created.agent_id);
    if find_agent_config_entry_index(list, &agent_id).is_some() {
        return;
    }
    if default_id != agent_id && find_agent_config_entry_index(list, &default_id).is_none() {
        list.insert(0, json!({ "id": default_id }));
    }
    let mut entry = json!({
        "id": agent_id,
        "name": created.name,
        "workspace": created.workspace,
    });
    if emoji.is_some() || avatar.is_some() {
        let identity = json!({
            "emoji": emoji.and_then(|value| normalize_optional_text(Some(value.to_owned()), 128)),
            "avatar": avatar.and_then(|value| normalize_optional_text(Some(value.to_owned()), 512))
        });
        if let Some(entry_obj) = entry.as_object_mut() {
            entry_obj.insert("identity".to_owned(), identity);
        }
    }
    list.push(entry);
}

fn apply_agent_update_to_config(
    config: &mut Value,
    params: &AgentsUpdateParams,
) -> Result<(), String> {
    let root = ensure_value_object(config);
    let agents = ensure_object_field(root, "agents");
    let list = ensure_array_field(agents, "list");
    let agent_id = normalize_agent_id(&params.agent_id);
    let Some(index) = find_agent_config_entry_index(list, &agent_id) else {
        return Err(format!("agent \"{agent_id}\" not found"));
    };
    let Some(entry_obj) = list.get_mut(index).and_then(Value::as_object_mut) else {
        return Err(format!("agent \"{agent_id}\" not found"));
    };

    if let Some(name) = params
        .name
        .as_ref()
        .and_then(|value| normalize_optional_text(Some(value.clone()), 128))
    {
        entry_obj.insert("name".to_owned(), Value::String(name.clone()));
        let identity = ensure_object_field(entry_obj, "identity");
        identity.insert("name".to_owned(), Value::String(name));
    }
    if let Some(workspace) = params.workspace.as_ref() {
        let normalized = normalize_optional_text(Some(workspace.clone()), 512)
            .ok_or_else(|| "workspace must be a non-empty string".to_owned())?;
        entry_obj.insert("workspace".to_owned(), Value::String(normalized));
    }
    if let Some(model) = params
        .model
        .as_ref()
        .and_then(|value| normalize_optional_text(Some(value.clone()), 256))
    {
        entry_obj.insert("model".to_owned(), Value::String(model));
    }
    if let Some(avatar) = params
        .avatar
        .as_ref()
        .and_then(|value| normalize_optional_text(Some(value.clone()), 512))
    {
        let identity = ensure_object_field(entry_obj, "identity");
        identity.insert("avatar".to_owned(), Value::String(avatar));
    }

    Ok(())
}

fn apply_agent_delete_to_config(config: &mut Value, agent_id: &str) -> u64 {
    let root = ensure_value_object(config);
    let agents = ensure_object_field(root, "agents");
    let list = ensure_array_field(agents, "list");
    let agent_id = normalize_agent_id(agent_id);
    if let Some(index) = find_agent_config_entry_index(list, &agent_id) {
        list.remove(index);
    }

    let mut removed_bindings = 0u64;
    if let Some(bindings) = root.get_mut("bindings").and_then(Value::as_array_mut) {
        bindings.retain(|binding| {
            let keep = binding
                .get("agentId")
                .or_else(|| binding.get("agent_id"))
                .and_then(Value::as_str)
                .map(|value| !normalize_agent_id(value).eq_ignore_ascii_case(&agent_id))
                .unwrap_or(true);
            if !keep {
                removed_bindings = removed_bindings.saturating_add(1);
            }
            keep
        });
    }

    if let Some(tools) = root.get_mut("tools").and_then(Value::as_object_mut) {
        let agent_to_agent = if tools.contains_key("agentToAgent") {
            tools.get_mut("agentToAgent")
        } else {
            tools.get_mut("agent_to_agent")
        };
        if let Some(agent_to_agent) = agent_to_agent.and_then(Value::as_object_mut) {
            let allow = if agent_to_agent.contains_key("allow") {
                agent_to_agent.get_mut("allow")
            } else {
                agent_to_agent.get_mut("Allow")
            };
            if let Some(allow) = allow.and_then(Value::as_array_mut) {
                allow.retain(|value| {
                    value
                        .as_str()
                        .map(|raw| !normalize_agent_id(raw).eq_ignore_ascii_case(&agent_id))
                        .unwrap_or(true)
                });
            }
        }
    }

    removed_bindings
}

fn ensure_value_object(value: &mut Value) -> &mut serde_json::Map<String, Value> {
    if !value.is_object() {
        *value = Value::Object(serde_json::Map::new());
    }
    value
        .as_object_mut()
        .expect("config value should be an object")
}

fn ensure_object_field<'a>(
    object: &'a mut serde_json::Map<String, Value>,
    key: &str,
) -> &'a mut serde_json::Map<String, Value> {
    let entry = object
        .entry(key.to_owned())
        .or_insert_with(|| Value::Object(serde_json::Map::new()));
    if !entry.is_object() {
        *entry = Value::Object(serde_json::Map::new());
    }
    entry.as_object_mut().expect("field should be object")
}

fn ensure_array_field<'a>(
    object: &'a mut serde_json::Map<String, Value>,
    key: &str,
) -> &'a mut Vec<Value> {
    let entry = object
        .entry(key.to_owned())
        .or_insert_with(|| Value::Array(Vec::new()));
    if !entry.is_array() {
        *entry = Value::Array(Vec::new());
    }
    entry.as_array_mut().expect("field should be array")
}

fn find_agent_config_entry_index(entries: &[Value], agent_id: &str) -> Option<usize> {
    entries.iter().position(|entry| {
        entry
            .get("id")
            .and_then(Value::as_str)
            .map(|raw| normalize_agent_id(raw).eq_ignore_ascii_case(agent_id))
            .unwrap_or(false)
    })
}

fn current_default_agent_id_from_config(config: &Value) -> String {
    config
        .pointer("/agents/list")
        .and_then(Value::as_array)
        .and_then(|entries| {
            entries.iter().find_map(|entry| {
                let object = entry.as_object()?;
                if object.get("default").and_then(Value::as_bool) != Some(true) {
                    return None;
                }
                object
                    .get("id")
                    .and_then(Value::as_str)
                    .map(normalize_agent_id)
            })
        })
        .or_else(|| {
            config
                .pointer("/agents/list")
                .and_then(Value::as_array)
                .and_then(|entries| {
                    entries.iter().find_map(|entry| {
                        entry
                            .get("id")
                            .and_then(Value::as_str)
                            .map(normalize_agent_id)
                    })
                })
        })
        .or_else(|| {
            config
                .pointer("/agents/defaults/id")
                .and_then(Value::as_str)
                .map(normalize_agent_id)
        })
        .unwrap_or_else(|| DEFAULT_AGENT_ID.to_owned())
}

fn is_allowed_agent_file_name(name: &str) -> bool {
    AGENT_BOOTSTRAP_FILE_NAMES
        .iter()
        .any(|candidate| *candidate == name)
        || name == AGENT_PRIMARY_MEMORY_FILE_NAME
        || name == AGENT_ALT_MEMORY_FILE_NAME
}

fn normalize_agent_id(value: &str) -> String {
    let trimmed = value.trim();
    if trimmed.is_empty() {
        return DEFAULT_AGENT_ID.to_owned();
    }
    let lowered = trimmed.to_ascii_lowercase();
    if is_valid_agent_id(&lowered) {
        return lowered;
    }
    let mut normalized = String::with_capacity(lowered.len());
    let mut last_dash = false;
    for ch in lowered.chars() {
        let valid = ch.is_ascii_alphanumeric() || ch == '_' || ch == '-';
        if valid {
            normalized.push(ch);
            last_dash = false;
            continue;
        }
        if !last_dash {
            normalized.push('-');
            last_dash = true;
        }
    }
    let trimmed_dash = normalized.trim_matches('-');
    let output = trimmed_dash.chars().take(64).collect::<String>();
    if output.is_empty() {
        DEFAULT_AGENT_ID.to_owned()
    } else {
        output
    }
}

fn is_valid_agent_id(value: &str) -> bool {
    if value.is_empty() || value.len() > 64 {
        return false;
    }
    let mut chars = value.chars();
    let Some(first) = chars.next() else {
        return false;
    };
    if !first.is_ascii_alphanumeric() {
        return false;
    }
    chars.all(|ch| ch.is_ascii_alphanumeric() || ch == '_' || ch == '-')
}

fn resolve_agent_id_from_session_key_input(session_key: &str) -> Result<String, String> {
    let trimmed = session_key.trim();
    if trimmed.is_empty() {
        return Ok(DEFAULT_AGENT_ID.to_owned());
    }
    let parsed = parse_session_key(trimmed);
    if normalize(trimmed).starts_with("agent:") {
        let malformed_agent = parsed
            .agent_id
            .as_ref()
            .map(|value| value.trim().is_empty())
            .unwrap_or(true);
        let malformed_shape = matches!(parsed.kind, SessionKind::Other)
            && parsed
                .scope_id
                .as_ref()
                .map(|value| value.trim().is_empty())
                .unwrap_or(true)
            && parsed
                .channel
                .as_ref()
                .map(|value| value.trim().is_empty())
                .unwrap_or(true);
        if malformed_agent || malformed_shape {
            return Err(format!(
                "invalid agent.identity.get params: malformed session key \"{trimmed}\""
            ));
        }
    }
    Ok(parsed
        .agent_id
        .map(|value| normalize_agent_id(&value))
        .unwrap_or_else(|| DEFAULT_AGENT_ID.to_owned()))
}

#[derive(Clone)]
struct AgentRunRegistry {
    state: Arc<Mutex<AgentRunState>>,
}

#[derive(Debug, Clone)]
struct AgentRunState {
    entries: HashMap<String, AgentRunSnapshot>,
}

#[derive(Debug, Clone)]
struct AgentRunSnapshot {
    status: String,
    started_at: u64,
    ended_at: u64,
    error: Option<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum AgentRunStartOutcome {
    Started,
    InFlight,
    Completed,
}

impl AgentRunRegistry {
    fn new() -> Self {
        Self {
            state: Arc::new(Mutex::new(AgentRunState {
                entries: HashMap::new(),
            })),
        }
    }

    async fn start_run(&self, run_id: &str) -> AgentRunStartOutcome {
        let run_key = run_id.trim();
        if run_key.is_empty() {
            return AgentRunStartOutcome::Completed;
        }
        let mut guard = self.state.lock().await;
        if let Some(snapshot) = guard.entries.get(run_key) {
            if normalize(&snapshot.status) == "ok" {
                return AgentRunStartOutcome::Completed;
            }
            return AgentRunStartOutcome::InFlight;
        }
        let now = now_ms();
        guard.entries.insert(
            run_key.to_owned(),
            AgentRunSnapshot {
                status: "in_flight".to_owned(),
                started_at: now,
                ended_at: 0,
                error: None,
            },
        );
        AgentRunStartOutcome::Started
    }

    async fn complete_ok(&self, run_id: String) {
        self.complete_with_status(run_id, "ok", None).await;
    }

    async fn complete_error(&self, run_id: String, error: String) {
        self.complete_with_status(run_id, "error", Some(error))
            .await;
    }

    async fn complete_with_status(&self, run_id: String, status: &str, error: Option<String>) {
        let now = now_ms();
        let mut guard = self.state.lock().await;
        if let Some(entry) = guard.entries.get_mut(&run_id) {
            entry.status = status.to_owned();
            if entry.started_at == 0 {
                entry.started_at = now;
            }
            entry.ended_at = now;
            entry.error = error.clone();
        } else {
            guard.entries.insert(
                run_id,
                AgentRunSnapshot {
                    status: status.to_owned(),
                    started_at: now,
                    ended_at: now,
                    error,
                },
            );
        }
        if guard.entries.len() > 4_096 {
            let mut oldest_key: Option<String> = None;
            let mut oldest = u64::MAX;
            for (entry_key, entry) in &guard.entries {
                if entry.ended_at < oldest {
                    oldest = entry.ended_at;
                    oldest_key = Some(entry_key.clone());
                }
            }
            if let Some(oldest_key) = oldest_key {
                let _ = guard.entries.remove(&oldest_key);
            }
        }
    }

    async fn wait(&self, run_id: &str, timeout_ms: u64) -> Option<AgentRunSnapshot> {
        let run_key = run_id.trim();
        if run_key.is_empty() {
            return None;
        }
        {
            let guard = self.state.lock().await;
            if let Some(snapshot) = guard.entries.get(run_key) {
                return Some(snapshot.clone());
            }
        }
        if timeout_ms == 0 {
            return None;
        }
        let guard = self.state.lock().await;
        guard.entries.get(run_key).cloned()
    }
}

struct CronRegistry {
    state: Mutex<CronState>,
}

#[derive(Debug, Clone)]
struct CronState {
    enabled: bool,
    store_path: String,
    jobs: HashMap<String, CronJob>,
    run_logs: HashMap<String, VecDeque<CronRunLogEntry>>,
}

#[derive(Debug, Clone)]
enum CronRegistryError {
    NotFound(String),
    Invalid(String),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum CronRunMode {
    Due,
    Force,
}

impl CronRunMode {
    fn as_str(self) -> &'static str {
        match self {
            Self::Due => "due",
            Self::Force => "force",
        }
    }
}

#[derive(Debug, Clone)]
struct CronRunExecution {
    entry: CronRunLogEntry,
    system_event_text: Option<String>,
    job: CronJob,
}

#[derive(Debug, Clone)]
struct CronWebhookDispatch {
    target: String,
    payload: Value,
    best_effort: bool,
    authorization_bearer: Option<String>,
    source: CronWebhookSource,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum CronWebhookSource {
    DeliveryMode,
    LegacyNotifyFallback,
}

#[derive(Debug, Clone, Default)]
struct CronWebhookDefaults {
    webhook: Option<String>,
    webhook_token: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct CronRuntimeConfig {
    enabled: Option<bool>,
    store_path: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct SendRuntimeConfig {
    store_path: Option<String>,
    ttl_ms: Option<u64>,
    max_entries: Option<usize>,
}

#[derive(Debug, Clone, Default)]
struct SessionRuntimeConfig {
    store_path: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct ChannelRuntimeConfig {
    store_path: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct DevicePairRuntimeConfig {
    store_path: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct NodePairRuntimeConfig {
    store_path: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct ConfigRuntimeConfig {
    store_path: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct WebLoginRuntimeConfig {
    store_path: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct OAuthRuntimeConfig {
    store_path: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct WizardRuntimeConfig {
    store_path: Option<String>,
}

#[derive(Debug, Clone, Default)]
struct NodeHostRuntimeConfig {
    local_node_ids: Vec<String>,
    allow_system_run: bool,
    system_run_timeout_ms: u64,
    external_persistent: bool,
    external_queue_capacity: usize,
    external_idle_timeout_ms: u64,
    external_command: Option<String>,
    external_args: Vec<String>,
    external_commands: HashMap<String, NodeHostExternalCommand>,
    external_platforms: HashMap<String, NodeHostPlatformRuntimeConfig>,
}

#[derive(Debug, Clone, Default)]
struct NodeCommandPolicyConfig {
    allow_commands: Vec<String>,
    deny_commands: Vec<String>,
}

#[derive(Debug, Clone)]
struct NodeHostExternalCommand {
    command: String,
    args: Vec<String>,
}

#[derive(Debug, Clone, Default)]
struct NodeHostPlatformRuntimeConfig {
    external_command: Option<String>,
    external_args: Vec<String>,
    external_commands: HashMap<String, NodeHostExternalCommand>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(tag = "kind")]
enum CronSchedule {
    #[serde(rename = "at")]
    At { at: String },
    #[serde(rename = "every")]
    Every {
        #[serde(rename = "everyMs")]
        every_ms: u64,
        #[serde(rename = "anchorMs", skip_serializing_if = "Option::is_none")]
        anchor_ms: Option<u64>,
    },
    #[serde(rename = "cron")]
    Cron {
        expr: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        tz: Option<String>,
    },
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(tag = "kind")]
enum CronPayload {
    #[serde(rename = "systemEvent")]
    SystemEvent { text: String },
    #[serde(rename = "agentTurn")]
    AgentTurn {
        message: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        model: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        thinking: Option<String>,
        #[serde(rename = "timeoutSeconds", skip_serializing_if = "Option::is_none")]
        timeout_seconds: Option<u64>,
        #[serde(
            rename = "allowUnsafeExternalContent",
            skip_serializing_if = "Option::is_none"
        )]
        allow_unsafe_external_content: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        deliver: Option<bool>,
        #[serde(skip_serializing_if = "Option::is_none")]
        channel: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        to: Option<String>,
        #[serde(rename = "bestEffortDeliver", skip_serializing_if = "Option::is_none")]
        best_effort_deliver: Option<bool>,
    },
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(deny_unknown_fields)]
struct CronDelivery {
    mode: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    channel: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    to: Option<String>,
    #[serde(rename = "bestEffort", skip_serializing_if = "Option::is_none")]
    best_effort: Option<bool>,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(default, deny_unknown_fields)]
struct CronJobState {
    #[serde(rename = "nextRunAtMs", skip_serializing_if = "Option::is_none")]
    next_run_at_ms: Option<u64>,
    #[serde(rename = "runningAtMs", skip_serializing_if = "Option::is_none")]
    running_at_ms: Option<u64>,
    #[serde(rename = "lastRunAtMs", skip_serializing_if = "Option::is_none")]
    last_run_at_ms: Option<u64>,
    #[serde(rename = "lastStatus", skip_serializing_if = "Option::is_none")]
    last_status: Option<CronRunStatus>,
    #[serde(rename = "lastError", skip_serializing_if = "Option::is_none")]
    last_error: Option<String>,
    #[serde(rename = "lastDurationMs", skip_serializing_if = "Option::is_none")]
    last_duration_ms: Option<u64>,
    #[serde(rename = "consecutiveErrors", skip_serializing_if = "Option::is_none")]
    consecutive_errors: Option<u64>,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "lowercase")]
enum CronRunStatus {
    Ok,
    Error,
    Skipped,
}

#[derive(Debug, Clone, serde::Serialize)]
struct CronRunLogEntry {
    ts: u64,
    #[serde(rename = "jobId")]
    job_id: String,
    action: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    status: Option<CronRunStatus>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    summary: Option<String>,
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    session_id: Option<String>,
    #[serde(rename = "sessionKey", skip_serializing_if = "Option::is_none")]
    session_key: Option<String>,
    #[serde(rename = "runAtMs", skip_serializing_if = "Option::is_none")]
    run_at_ms: Option<u64>,
    #[serde(rename = "durationMs", skip_serializing_if = "Option::is_none")]
    duration_ms: Option<u64>,
    #[serde(rename = "nextRunAtMs", skip_serializing_if = "Option::is_none")]
    next_run_at_ms: Option<u64>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct CronJob {
    id: String,
    #[serde(rename = "agentId", skip_serializing_if = "Option::is_none")]
    agent_id: Option<String>,
    #[serde(rename = "sessionKey", skip_serializing_if = "Option::is_none")]
    session_key: Option<String>,
    name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    description: Option<String>,
    enabled: bool,
    #[serde(rename = "deleteAfterRun", skip_serializing_if = "Option::is_none")]
    delete_after_run: Option<bool>,
    #[serde(rename = "createdAtMs")]
    created_at_ms: u64,
    #[serde(rename = "updatedAtMs")]
    updated_at_ms: u64,
    schedule: CronSchedule,
    #[serde(rename = "sessionTarget")]
    session_target: String,
    #[serde(rename = "wakeMode")]
    wake_mode: String,
    payload: CronPayload,
    #[serde(skip_serializing_if = "Option::is_none")]
    delivery: Option<CronDelivery>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    notify: Option<bool>,
    #[serde(default)]
    state: CronJobState,
}

#[derive(Debug, Clone, serde::Serialize)]
struct CronRemoveResult {
    ok: bool,
    id: String,
    removed: bool,
}

#[derive(Debug, Clone, serde::Serialize)]
struct CronStatusSnapshot {
    enabled: bool,
    jobs: usize,
    #[serde(rename = "nextWakeAtMs", skip_serializing_if = "Option::is_none")]
    next_wake_at_ms: Option<u64>,
    #[serde(rename = "storePath")]
    store_path: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(default)]
struct CronStoreDiskState {
    version: u32,
    enabled: bool,
    jobs: Vec<CronJob>,
}

impl Default for CronStoreDiskState {
    fn default() -> Self {
        Self {
            version: 1,
            enabled: true,
            jobs: Vec::new(),
        }
    }
}

impl CronRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(CronState {
                enabled: true,
                store_path: CRON_STORE_PATH.to_owned(),
                jobs: HashMap::new(),
                run_logs: HashMap::new(),
            }),
        }
    }

    async fn apply_runtime_config(
        &self,
        runtime: CronRuntimeConfig,
    ) -> Result<(), CronRegistryError> {
        let mut guard = self.state.lock().await;
        if let Some(path) = runtime.store_path {
            if guard.store_path != path {
                let loaded = load_cron_store_disk_state(&path)?;
                guard.store_path = path.clone();
                guard.jobs = loaded
                    .jobs
                    .into_iter()
                    .map(|job| (job.id.clone(), job))
                    .collect::<HashMap<_, _>>();
                let active_job_ids = guard.jobs.keys().cloned().collect::<HashSet<_>>();
                guard
                    .run_logs
                    .retain(|job_id, _| active_job_ids.contains(job_id));
                if runtime.enabled.is_none() {
                    guard.enabled = loaded.enabled;
                }
            }
        }
        if let Some(enabled) = runtime.enabled {
            guard.enabled = enabled;
        }
        persist_cron_store_disk_state(&guard)?;
        Ok(())
    }

    async fn list(&self, include_disabled: bool) -> Vec<CronJob> {
        let guard = self.state.lock().await;
        let mut jobs = guard
            .jobs
            .values()
            .filter(|job| include_disabled || job.enabled)
            .cloned()
            .collect::<Vec<_>>();
        jobs.sort_by(|a, b| {
            a.created_at_ms
                .cmp(&b.created_at_ms)
                .then_with(|| a.id.cmp(&b.id))
        });
        jobs
    }

    async fn status(&self) -> CronStatusSnapshot {
        let guard = self.state.lock().await;
        let next_wake_at_ms = guard
            .jobs
            .values()
            .filter(|job| job.enabled)
            .filter_map(|job| job.state.next_run_at_ms)
            .min();
        CronStatusSnapshot {
            enabled: guard.enabled,
            jobs: guard.jobs.len(),
            next_wake_at_ms,
            store_path: guard.store_path.clone(),
        }
    }

    async fn add(&self, params: CronAddParams) -> Result<CronJob, CronRegistryError> {
        let name = normalize_optional_text(Some(params.name), 128)
            .ok_or_else(|| CronRegistryError::Invalid("cron.add name is required".to_owned()))?;
        let schedule = normalize_cron_schedule(params.schedule)?;
        let session_target = parse_cron_session_target(params.session_target)?;
        let wake_mode = parse_cron_wake_mode(params.wake_mode)?;
        let payload = normalize_cron_payload(params.payload)?;
        let mut delivery = match params.delivery {
            Some(raw) => Some(normalize_cron_delivery(raw, "cron.add")?),
            None => None,
        };
        if delivery.is_none() {
            delivery = legacy_cron_delivery_from_payload(&payload);
        }
        let now = now_ms();
        let id = next_cron_job_id();
        let job = CronJob {
            id: id.clone(),
            agent_id: normalize_optional_text(params.agent_id.flatten(), 64),
            session_key: normalize_session_key_input(params.session_key.flatten()),
            name,
            description: normalize_optional_text(params.description, 512),
            enabled: params.enabled.unwrap_or(true),
            delete_after_run: params.delete_after_run,
            created_at_ms: now,
            updated_at_ms: now,
            schedule: schedule.clone(),
            session_target,
            wake_mode,
            payload,
            delivery,
            notify: params.notify,
            state: CronJobState {
                next_run_at_ms: estimate_next_run_at_ms(&schedule, now),
                ..CronJobState::default()
            },
        };
        let mut guard = self.state.lock().await;
        guard.jobs.insert(id, job.clone());
        persist_cron_store_disk_state(&guard)?;
        Ok(job)
    }

    async fn update(
        &self,
        job_id: &str,
        patch: CronUpdatePatchInput,
    ) -> Result<CronJob, CronRegistryError> {
        let now = now_ms();
        let mut guard = self.state.lock().await;
        let updated_job = {
            let Some(job) = guard.jobs.get_mut(job_id) else {
                return Err(CronRegistryError::NotFound(format!(
                    "cron job not found: {job_id}"
                )));
            };
            if let Some(value) = patch.name {
                job.name = normalize_optional_text(Some(value), 128).ok_or_else(|| {
                    CronRegistryError::Invalid("cron.update patch.name cannot be empty".to_owned())
                })?;
            }
            if let Some(value) = patch.agent_id {
                job.agent_id = normalize_optional_text(value, 64);
            }
            if let Some(value) = patch.session_key {
                job.session_key = normalize_session_key_input(value);
            }
            if let Some(value) = patch.description {
                job.description = normalize_optional_text(value, 512);
            }
            if let Some(value) = patch.enabled {
                job.enabled = value;
            }
            if let Some(value) = patch.delete_after_run {
                job.delete_after_run = Some(value);
            }
            if let Some(value) = patch.schedule {
                let schedule = normalize_cron_schedule(value)?;
                job.schedule = schedule.clone();
                job.state.next_run_at_ms = estimate_next_run_at_ms(&schedule, now);
            }
            if let Some(value) = patch.session_target {
                job.session_target = parse_cron_session_target(Some(value))?;
            }
            if let Some(value) = patch.wake_mode {
                job.wake_mode = parse_cron_wake_mode(Some(value))?;
            }
            if let Some(payload_patch) = patch.payload {
                let (payload, legacy_delivery) =
                    apply_cron_payload_patch(&job.payload, payload_patch)?;
                job.payload = payload;
                if patch.delivery.is_none() {
                    if let Some(raw) = legacy_delivery {
                        job.delivery = Some(normalize_cron_delivery(raw, "cron.update")?);
                    }
                }
            }
            if let Some(delivery_patch) = patch.delivery {
                job.delivery = apply_cron_delivery_patch(job.delivery.clone(), delivery_patch)?;
            }
            if let Some(value) = patch.notify {
                job.notify = value;
            }
            if let Some(state_patch) = patch.state {
                apply_cron_job_state_patch(&mut job.state, state_patch)?;
            }
            job.updated_at_ms = now;
            job.clone()
        };
        persist_cron_store_disk_state(&guard)?;
        Ok(updated_job)
    }

    async fn remove(&self, job_id: &str) -> Result<CronRemoveResult, CronRegistryError> {
        let mut guard = self.state.lock().await;
        if guard.jobs.remove(job_id).is_none() {
            return Err(CronRegistryError::NotFound(format!(
                "cron job not found: {job_id}"
            )));
        }
        persist_cron_store_disk_state(&guard)?;
        Ok(CronRemoveResult {
            ok: true,
            id: job_id.to_owned(),
            removed: true,
        })
    }

    async fn run(
        &self,
        job_id: &str,
        mode: CronRunMode,
    ) -> Result<CronRunExecution, CronRegistryError> {
        let now = now_ms();
        let mut guard = self.state.lock().await;
        let (entry, system_event_text, job_snapshot, should_disable, should_delete) = {
            let Some(job) = guard.jobs.get_mut(job_id) else {
                return Err(CronRegistryError::NotFound(format!(
                    "cron job not found: {job_id}"
                )));
            };
            let mut status = CronRunStatus::Ok;
            if !job.enabled {
                status = CronRunStatus::Skipped;
            } else if mode == CronRunMode::Due {
                if let Some(next) = job.state.next_run_at_ms {
                    if next > now {
                        status = CronRunStatus::Skipped;
                    }
                }
            }

            let summary = match (&status, &job.payload) {
                (CronRunStatus::Ok, CronPayload::SystemEvent { text }) => {
                    Some(truncate_text(text, 256))
                }
                (CronRunStatus::Ok, CronPayload::AgentTurn { message, .. }) => {
                    Some(truncate_text(message, 256))
                }
                (CronRunStatus::Skipped, _) if !job.enabled => Some("job disabled".to_owned()),
                (CronRunStatus::Skipped, _) => Some("not due".to_owned()),
                (CronRunStatus::Error, _) => None,
            };

            let system_event_text = if matches!(status, CronRunStatus::Ok) {
                match &job.payload {
                    CronPayload::SystemEvent { text } => Some(text.clone()),
                    _ => None,
                }
            } else {
                None
            };

            job.state.running_at_ms = None;
            job.state.last_run_at_ms = Some(now);
            job.state.last_duration_ms = Some(0);
            job.state.last_status = Some(status.clone());
            if matches!(status, CronRunStatus::Error) {
                let current = job.state.consecutive_errors.unwrap_or(0);
                job.state.consecutive_errors = Some(current.saturating_add(1));
            } else {
                job.state.consecutive_errors = Some(0);
                job.state.last_error = None;
            }

            if matches!(status, CronRunStatus::Ok) {
                match &job.schedule {
                    CronSchedule::Every { every_ms, .. } => {
                        job.state.next_run_at_ms = Some(now.saturating_add(*every_ms));
                    }
                    CronSchedule::At { .. } => {
                        job.state.next_run_at_ms = None;
                    }
                    CronSchedule::Cron { .. } => {}
                }
            }
            job.updated_at_ms = now;
            let entry = CronRunLogEntry {
                ts: now,
                job_id: job_id.to_owned(),
                action: "finished".to_owned(),
                status: Some(status),
                error: None,
                summary,
                session_id: None,
                session_key: job.session_key.clone(),
                run_at_ms: Some(now),
                duration_ms: Some(0),
                next_run_at_ms: job.state.next_run_at_ms,
            };
            let job_snapshot = job.clone();
            (
                entry,
                system_event_text,
                job_snapshot,
                matches!(&job.schedule, CronSchedule::At { .. }),
                job.delete_after_run.unwrap_or(false),
            )
        };

        let logs = guard
            .run_logs
            .entry(job_id.to_owned())
            .or_insert_with(VecDeque::new);
        if logs.len() >= MAX_CRON_RUN_LOGS_PER_JOB {
            let _ = logs.pop_front();
        }
        logs.push_back(entry.clone());

        if should_delete {
            let _ = guard.jobs.remove(job_id);
        } else if should_disable {
            if let Some(job) = guard.jobs.get_mut(job_id) {
                job.enabled = false;
                job.updated_at_ms = now;
            }
        }

        persist_cron_store_disk_state(&guard)?;

        Ok(CronRunExecution {
            entry,
            system_event_text,
            job: job_snapshot,
        })
    }

    async fn run_due_batch(&self, limit: usize) -> Vec<CronRunExecution> {
        let max_jobs = limit.max(1);
        let due_job_ids = self.due_job_ids(now_ms(), max_jobs).await;
        let mut executions = Vec::with_capacity(due_job_ids.len());
        for job_id in due_job_ids {
            let Ok(execution) = self.run(&job_id, CronRunMode::Due).await else {
                continue;
            };
            if matches!(
                execution.entry.status.as_ref(),
                Some(CronRunStatus::Skipped)
            ) {
                continue;
            }
            executions.push(execution);
        }
        executions
    }

    async fn due_job_ids(&self, now: u64, limit: usize) -> Vec<String> {
        let max_jobs = limit.max(1);
        let guard = self.state.lock().await;
        let mut due_jobs = guard
            .jobs
            .values()
            .filter(|job| job.enabled)
            .filter_map(|job| {
                job.state
                    .next_run_at_ms
                    .filter(|next_run_at_ms| *next_run_at_ms <= now)
                    .map(|next_run_at_ms| (next_run_at_ms, job.id.clone()))
            })
            .collect::<Vec<_>>();
        due_jobs.sort_by(|a, b| a.0.cmp(&b.0).then_with(|| a.1.cmp(&b.1)));
        if due_jobs.len() > max_jobs {
            due_jobs.truncate(max_jobs);
        }
        due_jobs
            .into_iter()
            .map(|(_, job_id)| job_id)
            .collect::<Vec<_>>()
    }

    async fn runs(
        &self,
        job_id: &str,
        limit: usize,
    ) -> Result<Vec<CronRunLogEntry>, CronRegistryError> {
        let guard = self.state.lock().await;
        if !guard.jobs.contains_key(job_id) && !guard.run_logs.contains_key(job_id) {
            return Err(CronRegistryError::NotFound(format!(
                "cron job not found: {job_id}"
            )));
        }
        let mut entries = guard
            .run_logs
            .get(job_id)
            .map(|logs| logs.iter().cloned().collect::<Vec<_>>())
            .unwrap_or_default();
        if entries.len() > limit {
            entries = entries.split_off(entries.len() - limit);
        }
        Ok(entries)
    }
}

struct SkillsRegistry {
    state: Mutex<SkillsState>,
}

#[derive(Debug, Clone)]
struct SkillsState {
    managed_skills_dir: String,
    entries: HashMap<String, SkillConfigState>,
    virtual_skills: HashMap<String, VirtualSkillEntry>,
}

#[derive(Debug, Clone, Default)]
struct SkillConfigState {
    enabled: Option<bool>,
    api_key: Option<String>,
    env: HashMap<String, String>,
}

#[derive(Debug, Clone)]
struct VirtualSkillEntry {
    name: String,
    description: String,
}

#[derive(Debug, Clone)]
struct DiscoveredSkill {
    name: String,
    description: String,
    source: String,
    file_path: String,
    base_dir: String,
    skill_key: String,
    bundled: bool,
    primary_env: Option<String>,
    emoji: Option<String>,
    homepage: Option<String>,
    requirements: SkillRequirementSet,
    install: Vec<SkillInstallOption>,
}

#[derive(Debug, Clone, Default)]
struct SkillRequirementSet {
    bins: Vec<String>,
    env: Vec<String>,
    config: Vec<String>,
    os: Vec<String>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SkillsStatusConfigCheck {
    path: String,
    satisfied: bool,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SkillInstallOption {
    id: String,
    kind: String,
    label: String,
    bins: Vec<String>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SkillStatusRequirements {
    bins: Vec<String>,
    env: Vec<String>,
    config: Vec<String>,
    os: Vec<String>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SkillStatusEntryView {
    name: String,
    description: String,
    source: String,
    #[serde(rename = "filePath")]
    file_path: String,
    #[serde(rename = "baseDir")]
    base_dir: String,
    #[serde(rename = "skillKey")]
    skill_key: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    bundled: Option<bool>,
    #[serde(rename = "primaryEnv", skip_serializing_if = "Option::is_none")]
    primary_env: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    emoji: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    homepage: Option<String>,
    always: bool,
    disabled: bool,
    #[serde(rename = "blockedByAllowlist")]
    blocked_by_allowlist: bool,
    eligible: bool,
    requirements: SkillStatusRequirements,
    missing: SkillStatusRequirements,
    #[serde(rename = "configChecks")]
    config_checks: Vec<SkillsStatusConfigCheck>,
    install: Vec<SkillInstallOption>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SkillsStatusReport {
    #[serde(rename = "workspaceDir")]
    workspace_dir: String,
    #[serde(rename = "managedSkillsDir")]
    managed_skills_dir: String,
    skills: Vec<SkillStatusEntryView>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SkillConfigView {
    #[serde(skip_serializing_if = "Option::is_none")]
    enabled: Option<bool>,
    #[serde(rename = "apiKey", skip_serializing_if = "Option::is_none")]
    api_key: Option<String>,
    #[serde(skip_serializing_if = "HashMap::is_empty")]
    env: HashMap<String, String>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SkillsUpdateResult {
    ok: bool,
    #[serde(rename = "skillKey")]
    skill_key: String,
    config: SkillConfigView,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SkillsInstallResult {
    ok: bool,
    #[serde(rename = "skillKey")]
    skill_key: String,
    name: String,
    #[serde(rename = "installId")]
    install_id: String,
    installed: bool,
    message: String,
}

impl SkillsRegistry {
    fn new() -> Self {
        let managed_skills_dir = default_codex_skills_dir().to_string_lossy().to_string();
        Self {
            state: Mutex::new(SkillsState {
                managed_skills_dir,
                entries: HashMap::new(),
                virtual_skills: HashMap::new(),
            }),
        }
    }

    async fn status(&self, workspace_dir: &str, _agent_id: &str) -> SkillsStatusReport {
        let snapshot = {
            let guard = self.state.lock().await;
            (
                guard.managed_skills_dir.clone(),
                guard.entries.clone(),
                guard.virtual_skills.clone(),
            )
        };
        let discovered = discover_skills(Path::new(&snapshot.0), &snapshot.1, &snapshot.2);
        let skills = discovered
            .into_iter()
            .map(|skill| {
                let cfg = snapshot
                    .1
                    .get(&skill.skill_key)
                    .cloned()
                    .unwrap_or_default();
                build_skill_status_entry(skill, cfg)
            })
            .collect::<Vec<_>>();
        SkillsStatusReport {
            workspace_dir: workspace_dir.to_owned(),
            managed_skills_dir: snapshot.0,
            skills,
        }
    }

    async fn bins(&self) -> Vec<String> {
        let snapshot = {
            let guard = self.state.lock().await;
            (
                guard.managed_skills_dir.clone(),
                guard.entries.clone(),
                guard.virtual_skills.clone(),
            )
        };
        let discovered = discover_skills(Path::new(&snapshot.0), &snapshot.1, &snapshot.2);
        let mut bins = Vec::new();
        for skill in discovered {
            bins.extend(skill.requirements.bins);
            for install in skill.install {
                bins.extend(install.bins);
            }
        }
        sort_and_dedup_strings(&mut bins);
        bins
    }

    async fn install(&self, params: SkillsInstallParams) -> SkillsInstallResult {
        let name = params.name.trim().to_owned();
        let install_id = params.install_id.trim().to_owned();
        let skill_key = skill_key_from_name(&name);
        let mut guard = self.state.lock().await;
        guard
            .virtual_skills
            .entry(skill_key.clone())
            .or_insert_with(|| VirtualSkillEntry {
                name: name.clone(),
                description: "User-managed skill".to_owned(),
            });
        SkillsInstallResult {
            ok: true,
            skill_key,
            name: name.clone(),
            install_id: install_id.clone(),
            installed: true,
            message: format!("Installed {name} ({install_id})"),
        }
    }

    async fn update(&self, params: SkillsUpdateParams) -> Result<SkillsUpdateResult, String> {
        let skill_key = normalize_optional_text(Some(params.skill_key), 128)
            .ok_or_else(|| "skillKey is required".to_owned())?;
        let mut guard = self.state.lock().await;
        let config_view = {
            let entry = guard
                .entries
                .entry(skill_key.clone())
                .or_insert_with(SkillConfigState::default);
            if let Some(enabled) = params.enabled {
                entry.enabled = Some(enabled);
            }
            if let Some(api_key) = params.api_key {
                let normalized = normalize_secret_input(&api_key);
                if normalized.is_empty() {
                    entry.api_key = None;
                } else {
                    entry.api_key = Some(normalized);
                }
            }
            if let Some(env) = params.env {
                for (raw_key, raw_value) in env {
                    let key = raw_key.trim();
                    if key.is_empty() {
                        continue;
                    }
                    let value = raw_value.trim();
                    if value.is_empty() {
                        entry.env.remove(key);
                    } else {
                        entry.env.insert(key.to_owned(), value.to_owned());
                    }
                }
            }
            SkillConfigView {
                enabled: entry.enabled,
                api_key: entry.api_key.clone(),
                env: entry.env.clone(),
            }
        };
        guard
            .virtual_skills
            .entry(skill_key.clone())
            .or_insert_with(|| VirtualSkillEntry {
                name: skill_key.clone(),
                description: "User-managed skill".to_owned(),
            });
        Ok(SkillsUpdateResult {
            ok: true,
            skill_key,
            config: config_view,
        })
    }
}

struct NodePairRegistry {
    state: Mutex<NodePairState>,
    runtime: Mutex<NodePairRuntimeState>,
}

#[derive(Debug, Clone, Default)]
struct NodePairState {
    pending_by_id: HashMap<String, NodePairPendingRequest>,
    paired_by_node_id: HashMap<String, PairedNodeEntry>,
}

#[derive(Debug, Clone)]
struct NodePairRuntimeState {
    store_path: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct NodePairStoreDiskState {
    version: u32,
    pending: Vec<NodePairPendingRequest>,
    paired: Vec<PairedNodeEntry>,
}

impl Default for NodePairStoreDiskState {
    fn default() -> Self {
        Self {
            version: 1,
            pending: Vec::new(),
            paired: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, serde::Serialize)]
struct NodePairRequestResult {
    status: &'static str,
    request: NodePairPendingRequest,
    created: bool,
}

#[derive(Debug, Clone, serde::Serialize)]
struct NodePairListResult {
    pending: Vec<NodePairPendingRequest>,
    paired: Vec<PairedNodeEntry>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct NodePairApproveResult {
    #[serde(rename = "requestId")]
    request_id: String,
    node: PairedNodeEntry,
}

#[derive(Debug, Clone, serde::Serialize)]
struct NodePairRejectResult {
    #[serde(rename = "requestId")]
    request_id: String,
    #[serde(rename = "nodeId")]
    node_id: String,
}

#[derive(Debug, Clone, serde::Serialize)]
struct NodePairVerifyResult {
    ok: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    node: Option<PairedNodeEntry>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct NodeRenameResult {
    #[serde(rename = "nodeId")]
    node_id: String,
    #[serde(rename = "displayName")]
    display_name: String,
}

#[derive(Debug, Clone, serde::Serialize)]
struct NodeInventoryEntry {
    #[serde(rename = "nodeId")]
    node_id: String,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    display_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    platform: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    version: Option<String>,
    #[serde(rename = "coreVersion", skip_serializing_if = "Option::is_none")]
    core_version: Option<String>,
    #[serde(rename = "uiVersion", skip_serializing_if = "Option::is_none")]
    ui_version: Option<String>,
    #[serde(rename = "deviceFamily", skip_serializing_if = "Option::is_none")]
    device_family: Option<String>,
    #[serde(rename = "modelIdentifier", skip_serializing_if = "Option::is_none")]
    model_identifier: Option<String>,
    #[serde(rename = "remoteIp", skip_serializing_if = "Option::is_none")]
    remote_ip: Option<String>,
    caps: Vec<String>,
    commands: Vec<String>,
    #[serde(rename = "pathEnv", skip_serializing_if = "Option::is_none")]
    path_env: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    permissions: Option<Value>,
    #[serde(rename = "connectedAtMs", skip_serializing_if = "Option::is_none")]
    connected_at_ms: Option<u64>,
    paired: bool,
    connected: bool,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct NodePairPendingRequest {
    #[serde(rename = "requestId")]
    request_id: String,
    #[serde(rename = "nodeId")]
    node_id: String,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    display_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    platform: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    version: Option<String>,
    #[serde(rename = "coreVersion", skip_serializing_if = "Option::is_none")]
    core_version: Option<String>,
    #[serde(rename = "uiVersion", skip_serializing_if = "Option::is_none")]
    ui_version: Option<String>,
    #[serde(rename = "deviceFamily", skip_serializing_if = "Option::is_none")]
    device_family: Option<String>,
    #[serde(rename = "modelIdentifier", skip_serializing_if = "Option::is_none")]
    model_identifier: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    caps: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    commands: Option<Vec<String>>,
    #[serde(rename = "remoteIp", skip_serializing_if = "Option::is_none")]
    remote_ip: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    silent: Option<bool>,
    #[serde(rename = "isRepair", skip_serializing_if = "Option::is_none")]
    is_repair: Option<bool>,
    ts: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct PairedNodeEntry {
    #[serde(rename = "nodeId")]
    node_id: String,
    token: String,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    display_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    platform: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    version: Option<String>,
    #[serde(rename = "coreVersion", skip_serializing_if = "Option::is_none")]
    core_version: Option<String>,
    #[serde(rename = "uiVersion", skip_serializing_if = "Option::is_none")]
    ui_version: Option<String>,
    #[serde(rename = "deviceFamily", skip_serializing_if = "Option::is_none")]
    device_family: Option<String>,
    #[serde(rename = "modelIdentifier", skip_serializing_if = "Option::is_none")]
    model_identifier: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    caps: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    commands: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    bins: Option<Vec<String>>,
    #[serde(rename = "remoteIp", skip_serializing_if = "Option::is_none")]
    remote_ip: Option<String>,
    #[serde(rename = "createdAtMs")]
    created_at_ms: u64,
    #[serde(rename = "approvedAtMs")]
    approved_at_ms: u64,
    #[serde(rename = "lastConnectedAtMs", skip_serializing_if = "Option::is_none")]
    last_connected_at_ms: Option<u64>,
}

#[derive(Debug, Clone, Default, serde::Deserialize)]
#[serde(default)]
struct NodePairRequestedEventPayload {
    #[serde(rename = "requestId", alias = "request_id")]
    request_id: Option<String>,
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: Option<String>,
    #[serde(rename = "displayName", alias = "display_name")]
    display_name: Option<String>,
    platform: Option<String>,
    version: Option<String>,
    #[serde(rename = "coreVersion", alias = "core_version")]
    core_version: Option<String>,
    #[serde(rename = "uiVersion", alias = "ui_version")]
    ui_version: Option<String>,
    #[serde(rename = "deviceFamily", alias = "device_family")]
    device_family: Option<String>,
    #[serde(rename = "modelIdentifier", alias = "model_identifier")]
    model_identifier: Option<String>,
    caps: Option<Vec<String>>,
    commands: Option<Vec<String>>,
    #[serde(rename = "remoteIp", alias = "remote_ip")]
    remote_ip: Option<String>,
    silent: Option<bool>,
    #[serde(rename = "isRepair", alias = "is_repair")]
    is_repair: Option<bool>,
    ts: Option<u64>,
}

#[derive(Debug, Clone, Default, serde::Deserialize)]
#[serde(default)]
struct NodePairResolvedEventPayload {
    #[serde(rename = "requestId", alias = "request_id")]
    request_id: Option<String>,
}

impl NodePairRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(NodePairState::default()),
            runtime: Mutex::new(NodePairRuntimeState {
                store_path: NODE_PAIR_STORE_PATH.to_owned(),
            }),
        }
    }

    async fn apply_runtime_config(&self, runtime: NodePairRuntimeConfig) -> Result<(), String> {
        let target_store_path = runtime
            .store_path
            .and_then(|value| normalize_optional_text(Some(value), 2048))
            .unwrap_or_else(|| NODE_PAIR_STORE_PATH.to_owned());

        let current_store_path = { self.runtime.lock().await.store_path.clone() };
        if current_store_path == target_store_path {
            return Ok(());
        }

        let loaded = load_node_pair_store_disk_state(&target_store_path)?;
        let mut next_state = NodePairState::default();

        for pending in loaded.pending {
            let Some(request_id) = normalize_optional_text(Some(pending.request_id.clone()), 128)
            else {
                continue;
            };
            let Some(node_id) = normalize_optional_text(Some(pending.node_id.clone()), 128) else {
                continue;
            };
            let mut normalized = pending;
            normalized.request_id = request_id.clone();
            normalized.node_id = node_id;
            next_state.pending_by_id.insert(request_id, normalized);
        }

        for paired in loaded.paired {
            let Some(node_id) = normalize_optional_text(Some(paired.node_id.clone()), 128) else {
                continue;
            };
            let mut normalized = paired;
            normalized.node_id = node_id.clone();
            next_state.paired_by_node_id.insert(node_id, normalized);
        }

        prune_oldest_node_pending(&mut next_state.pending_by_id, 512);
        prune_oldest_node_pairs(&mut next_state.paired_by_node_id, 2_048);

        {
            let mut guard = self.state.lock().await;
            *guard = next_state.clone();
        }
        {
            let mut runtime_guard = self.runtime.lock().await;
            runtime_guard.store_path = target_store_path.clone();
        }
        persist_node_pair_store_disk_state(&target_store_path, &next_state)?;
        Ok(())
    }

    async fn persist_state_snapshot(&self, state: NodePairState) -> Result<(), String> {
        let store_path = { self.runtime.lock().await.store_path.clone() };
        persist_node_pair_store_disk_state(&store_path, &state)
    }

    async fn request(
        &self,
        params: NodePairRequestParams,
    ) -> Result<NodePairRequestResult, String> {
        let Some(node_id) = normalize_optional_text(Some(params.node_id), 128) else {
            return Err("invalid node.pair.request params: nodeId required".to_owned());
        };
        let display_name = normalize_optional_text(params.display_name, 128);
        let platform = normalize_optional_text(params.platform, 128);
        let version = normalize_optional_text(params.version, 128);
        let core_version = normalize_optional_text(params.core_version, 128);
        let ui_version = normalize_optional_text(params.ui_version, 128);
        let device_family = normalize_optional_text(params.device_family, 128);
        let model_identifier = normalize_optional_text(params.model_identifier, 128);
        let caps_values = normalize_string_list(params.caps, 128, 128);
        let caps = (!caps_values.is_empty()).then_some(caps_values);
        let command_values = normalize_string_list(params.commands, 256, 160);
        let commands = if command_values.is_empty() {
            let inferred = infer_node_pair_default_commands(
                platform.as_deref(),
                device_family.as_deref(),
                caps.as_deref(),
            );
            (!inferred.is_empty()).then_some(inferred)
        } else {
            Some(command_values)
        };
        let remote_ip = normalize_optional_text(params.remote_ip, 128);
        let now = now_ms();
        let mut guard = self.state.lock().await;
        if let Some(existing) = guard
            .pending_by_id
            .values()
            .find(|entry| entry.node_id == node_id)
            .cloned()
        {
            return Ok(NodePairRequestResult {
                status: "pending",
                request: existing,
                created: false,
            });
        }
        let request = NodePairPendingRequest {
            request_id: next_node_pair_request_id(),
            node_id: node_id.clone(),
            display_name,
            platform,
            version,
            core_version,
            ui_version,
            device_family,
            model_identifier,
            caps,
            commands,
            remote_ip,
            silent: params.silent,
            is_repair: Some(guard.paired_by_node_id.contains_key(&node_id)),
            ts: now,
        };
        guard
            .pending_by_id
            .insert(request.request_id.clone(), request.clone());
        prune_oldest_node_pending(&mut guard.pending_by_id, 512);
        let snapshot = guard.clone();
        drop(guard);
        self.persist_state_snapshot(snapshot).await?;
        Ok(NodePairRequestResult {
            status: "pending",
            request,
            created: true,
        })
    }

    async fn list(&self) -> NodePairListResult {
        let guard = self.state.lock().await;
        let mut pending = guard
            .pending_by_id
            .values()
            .cloned()
            .collect::<Vec<NodePairPendingRequest>>();
        pending.sort_by(|a, b| {
            b.ts.cmp(&a.ts)
                .then_with(|| a.request_id.cmp(&b.request_id))
        });
        let mut paired = guard
            .paired_by_node_id
            .values()
            .cloned()
            .collect::<Vec<PairedNodeEntry>>();
        paired.sort_by(|a, b| {
            b.approved_at_ms
                .cmp(&a.approved_at_ms)
                .then_with(|| a.node_id.cmp(&b.node_id))
        });
        NodePairListResult { pending, paired }
    }

    async fn approve(&self, request_id: &str) -> Option<NodePairApproveResult> {
        let mut guard = self.state.lock().await;
        let request = guard.pending_by_id.remove(request_id)?;
        let now = now_ms();
        let existing = guard.paired_by_node_id.get(&request.node_id).cloned();
        let node = PairedNodeEntry {
            node_id: request.node_id.clone(),
            token: next_node_pair_token(&request.node_id),
            display_name: request.display_name,
            platform: request.platform,
            version: request.version,
            core_version: request.core_version,
            ui_version: request.ui_version,
            device_family: request.device_family,
            model_identifier: request.model_identifier,
            caps: request.caps,
            commands: request.commands,
            bins: None,
            remote_ip: request.remote_ip,
            created_at_ms: existing.as_ref().map_or(now, |value| value.created_at_ms),
            approved_at_ms: now,
            last_connected_at_ms: existing.and_then(|value| value.last_connected_at_ms),
        };
        guard
            .paired_by_node_id
            .insert(node.node_id.clone(), node.clone());
        prune_oldest_node_pairs(&mut guard.paired_by_node_id, 2_048);
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
        Some(NodePairApproveResult {
            request_id: request_id.to_owned(),
            node,
        })
    }

    async fn reject(&self, request_id: &str) -> Option<NodePairRejectResult> {
        let mut guard = self.state.lock().await;
        let request = guard.pending_by_id.remove(request_id)?;
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
        Some(NodePairRejectResult {
            request_id: request_id.to_owned(),
            node_id: request.node_id,
        })
    }

    async fn verify(&self, node_id: &str, token: &str) -> NodePairVerifyResult {
        let normalized_node_id = node_id.trim();
        if normalized_node_id.is_empty() || token.trim().is_empty() {
            return NodePairVerifyResult {
                ok: false,
                node: None,
            };
        }
        let guard = self.state.lock().await;
        let Some(node) = guard.paired_by_node_id.get(normalized_node_id).cloned() else {
            return NodePairVerifyResult {
                ok: false,
                node: None,
            };
        };
        if node.token == token {
            NodePairVerifyResult {
                ok: true,
                node: Some(node),
            }
        } else {
            NodePairVerifyResult {
                ok: false,
                node: None,
            }
        }
    }

    async fn rename(&self, node_id: &str, display_name: &str) -> Option<NodeRenameResult> {
        let normalized_node_id = node_id.trim();
        if normalized_node_id.is_empty() {
            return None;
        }
        let trimmed_name = display_name.trim();
        if trimmed_name.is_empty() {
            return None;
        }
        let mut guard = self.state.lock().await;
        let node = guard.paired_by_node_id.get_mut(normalized_node_id)?;
        node.display_name = Some(trimmed_name.to_owned());
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
        Some(NodeRenameResult {
            node_id: normalized_node_id.to_owned(),
            display_name: trimmed_name.to_owned(),
        })
    }

    async fn list_nodes(&self) -> Vec<NodeInventoryEntry> {
        let guard = self.state.lock().await;
        let mut nodes = guard
            .paired_by_node_id
            .values()
            .map(node_inventory_from_paired)
            .collect::<Vec<_>>();
        nodes.sort_by(|a, b| {
            if a.connected != b.connected {
                return if a.connected {
                    std::cmp::Ordering::Less
                } else {
                    std::cmp::Ordering::Greater
                };
            }
            let a_key = a.display_name.as_ref().map_or_else(
                || a.node_id.to_ascii_lowercase(),
                |value| value.to_ascii_lowercase(),
            );
            let b_key = b.display_name.as_ref().map_or_else(
                || b.node_id.to_ascii_lowercase(),
                |value| value.to_ascii_lowercase(),
            );
            a_key.cmp(&b_key).then_with(|| a.node_id.cmp(&b.node_id))
        });
        nodes
    }

    async fn describe_node(&self, node_id: &str) -> Option<NodeInventoryEntry> {
        let normalized_node_id = node_id.trim();
        if normalized_node_id.is_empty() {
            return None;
        }
        let guard = self.state.lock().await;
        let node = guard.paired_by_node_id.get(normalized_node_id)?;
        Some(node_inventory_from_paired(node))
    }

    async fn paired_node(&self, node_id: &str) -> Option<PairedNodeEntry> {
        let normalized_node_id = node_id.trim();
        if normalized_node_id.is_empty() {
            return None;
        }
        let guard = self.state.lock().await;
        guard.paired_by_node_id.get(normalized_node_id).cloned()
    }

    async fn ingest_pair_requested(&self, payload: Value) {
        let Ok(event) = serde_json::from_value::<NodePairRequestedEventPayload>(payload) else {
            return;
        };
        let Some(request_id) = normalize_optional_text(event.request_id, 128) else {
            return;
        };
        let Some(node_id) = normalize_optional_text(event.node_id, 128) else {
            return;
        };
        let request = NodePairPendingRequest {
            request_id: request_id.clone(),
            node_id: node_id.clone(),
            display_name: normalize_optional_text(event.display_name, 128),
            platform: normalize_optional_text(event.platform, 128),
            version: normalize_optional_text(event.version, 128),
            core_version: normalize_optional_text(event.core_version, 128),
            ui_version: normalize_optional_text(event.ui_version, 128),
            device_family: normalize_optional_text(event.device_family, 128),
            model_identifier: normalize_optional_text(event.model_identifier, 128),
            caps: {
                let values = normalize_string_list(event.caps, 128, 128);
                (!values.is_empty()).then_some(values)
            },
            commands: {
                let values = normalize_string_list(event.commands, 256, 160);
                (!values.is_empty()).then_some(values)
            },
            remote_ip: normalize_optional_text(event.remote_ip, 128),
            silent: event.silent,
            is_repair: event.is_repair,
            ts: event.ts.unwrap_or_else(now_ms),
        };
        let mut guard = self.state.lock().await;
        guard
            .pending_by_id
            .retain(|key, pending| key == &request_id || pending.node_id != node_id);
        guard.pending_by_id.insert(request_id, request);
        prune_oldest_node_pending(&mut guard.pending_by_id, 512);
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
    }

    async fn ingest_pair_resolved(&self, payload: Value) {
        let Ok(event) = serde_json::from_value::<NodePairResolvedEventPayload>(payload) else {
            return;
        };
        let Some(request_id) = normalize_optional_text(event.request_id, 128) else {
            return;
        };
        let mut guard = self.state.lock().await;
        let _ = guard.pending_by_id.remove(&request_id);
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
    }
}

fn node_inventory_from_paired(node: &PairedNodeEntry) -> NodeInventoryEntry {
    NodeInventoryEntry {
        node_id: node.node_id.clone(),
        display_name: node.display_name.clone(),
        platform: node.platform.clone(),
        version: node.version.clone(),
        core_version: node.core_version.clone(),
        ui_version: node.ui_version.clone(),
        device_family: node.device_family.clone(),
        model_identifier: node.model_identifier.clone(),
        remote_ip: node.remote_ip.clone(),
        caps: node.caps.clone().unwrap_or_default(),
        commands: node.commands.clone().unwrap_or_default(),
        path_env: None,
        permissions: None,
        connected_at_ms: node.last_connected_at_ms,
        paired: true,
        connected: false,
    }
}

fn prune_oldest_node_pending(
    pending_by_id: &mut HashMap<String, NodePairPendingRequest>,
    max_pending: usize,
) {
    while pending_by_id.len() > max_pending {
        let Some(oldest_key) = pending_by_id
            .iter()
            .min_by_key(|(_, pending)| pending.ts)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = pending_by_id.remove(&oldest_key);
    }
}

fn prune_oldest_node_pairs(
    paired_by_node_id: &mut HashMap<String, PairedNodeEntry>,
    max_pairs: usize,
) {
    while paired_by_node_id.len() > max_pairs {
        let Some(oldest_key) = paired_by_node_id
            .iter()
            .min_by_key(|(_, node)| node.approved_at_ms)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = paired_by_node_id.remove(&oldest_key);
    }
}

fn next_node_pair_request_id() -> String {
    let sequence = NODE_PAIR_REQUEST_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("node-pair-{}-{sequence}", now_ms())
}

fn next_node_pair_token(node_id: &str) -> String {
    use sha2::{Digest, Sha256};
    let sequence = NODE_TOKEN_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    let mut hasher = Sha256::new();
    hasher.update(node_id.as_bytes());
    hasher.update(now_ms().to_le_bytes());
    hasher.update(sequence.to_le_bytes());
    let digest = format!("{:x}", hasher.finalize());
    format!("ntk_{}", &digest[..48])
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum NodeCommandPolicyFailure {
    CommandRequired,
    CommandNotAllowlisted,
    NodeDidNotDeclareCommands,
    CommandNotDeclaredByNode,
}

impl NodeCommandPolicyFailure {
    fn reason(self) -> &'static str {
        match self {
            NodeCommandPolicyFailure::CommandRequired => "command required",
            NodeCommandPolicyFailure::CommandNotAllowlisted => "command not allowlisted",
            NodeCommandPolicyFailure::NodeDidNotDeclareCommands => "node did not declare commands",
            NodeCommandPolicyFailure::CommandNotDeclaredByNode => "command not declared by node",
        }
    }
}

fn normalize_node_platform_id(platform: Option<&str>, device_family: Option<&str>) -> &'static str {
    let platform_raw = platform
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 128))
        .map(|value| normalize(&value))
        .unwrap_or_default();
    if platform_raw.starts_with("ios") {
        return "ios";
    }
    if platform_raw.starts_with("android") {
        return "android";
    }
    if platform_raw.starts_with("mac") || platform_raw.starts_with("darwin") {
        return "macos";
    }
    if platform_raw.starts_with("win") {
        return "windows";
    }
    if platform_raw.starts_with("linux") {
        return "linux";
    }
    let family_raw = device_family
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 128))
        .map(|value| normalize(&value))
        .unwrap_or_default();
    if family_raw.contains("iphone") || family_raw.contains("ipad") || family_raw.contains("ios") {
        return "ios";
    }
    if family_raw.contains("android") {
        return "android";
    }
    if family_raw.contains("mac") {
        return "macos";
    }
    if family_raw.contains("windows") {
        return "windows";
    }
    if family_raw.contains("linux") {
        return "linux";
    }
    "unknown"
}

fn node_allowlist_insert_many(allowlist: &mut HashSet<String>, commands: &[&str]) {
    for command in commands {
        let normalized = normalize(command);
        if !normalized.is_empty() {
            allowlist.insert(normalized);
        }
    }
}

fn resolve_node_command_allowlist(
    policy: &NodeCommandPolicyConfig,
    platform: Option<&str>,
    device_family: Option<&str>,
) -> HashSet<String> {
    let platform_id = normalize_node_platform_id(platform, device_family);
    let mut allowlist = HashSet::new();
    match platform_id {
        "ios" => {
            node_allowlist_insert_many(&mut allowlist, NODE_CANVAS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CAMERA_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_LOCATION_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_DEVICE_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CONTACTS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CALENDAR_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_REMINDERS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_PHOTOS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_MOTION_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_IOS_SYSTEM_COMMANDS);
        }
        "android" => {
            node_allowlist_insert_many(&mut allowlist, NODE_CANVAS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CAMERA_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_LOCATION_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_DEVICE_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CONTACTS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CALENDAR_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_REMINDERS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_PHOTOS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_MOTION_COMMANDS);
        }
        "macos" => {
            node_allowlist_insert_many(&mut allowlist, NODE_CANVAS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CAMERA_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_LOCATION_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_DEVICE_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CONTACTS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CALENDAR_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_REMINDERS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_PHOTOS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_MOTION_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_SYSTEM_COMMANDS);
        }
        "linux" | "windows" => {
            node_allowlist_insert_many(&mut allowlist, NODE_SYSTEM_COMMANDS);
        }
        _ => {
            node_allowlist_insert_many(&mut allowlist, NODE_CANVAS_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_CAMERA_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_LOCATION_COMMANDS);
            node_allowlist_insert_many(&mut allowlist, NODE_SYSTEM_COMMANDS);
        }
    }

    // Keep high-risk command defaults blocked unless explicitly opted in.
    for command in NODE_DEFAULT_DANGEROUS_COMMANDS {
        let normalized = normalize(command);
        if !normalized.is_empty() {
            allowlist.remove(&normalized);
        }
    }

    for command in &policy.allow_commands {
        let normalized = normalize(command);
        if !normalized.is_empty() {
            allowlist.insert(normalized);
        }
    }
    for command in &policy.deny_commands {
        let normalized = normalize(command);
        if !normalized.is_empty() {
            allowlist.remove(&normalized);
        }
    }
    allowlist
}

fn node_capability_command_allowlist(caps: &[String]) -> HashSet<String> {
    let mut allowlist = HashSet::new();
    for cap in caps {
        match normalize(cap).as_str() {
            "browser" => node_allowlist_insert_many(&mut allowlist, &["browser.proxy"]),
            "canvas" | "a2ui" => node_allowlist_insert_many(&mut allowlist, NODE_CANVAS_COMMANDS),
            "camera" => node_allowlist_insert_many(&mut allowlist, NODE_CAMERA_COMMANDS),
            "location" | "gps" => {
                node_allowlist_insert_many(&mut allowlist, NODE_LOCATION_COMMANDS)
            }
            "device" => node_allowlist_insert_many(&mut allowlist, NODE_DEVICE_COMMANDS),
            "contacts" => node_allowlist_insert_many(&mut allowlist, NODE_CONTACTS_COMMANDS),
            "calendar" => node_allowlist_insert_many(&mut allowlist, NODE_CALENDAR_COMMANDS),
            "reminders" => node_allowlist_insert_many(&mut allowlist, NODE_REMINDERS_COMMANDS),
            "photos" | "photo" => node_allowlist_insert_many(&mut allowlist, NODE_PHOTOS_COMMANDS),
            "motion" | "fitness" | "activity" => {
                node_allowlist_insert_many(&mut allowlist, NODE_MOTION_COMMANDS)
            }
            "system" | "exec" => node_allowlist_insert_many(&mut allowlist, NODE_SYSTEM_COMMANDS),
            _ => {}
        }
    }
    allowlist
}

fn infer_node_pair_default_commands(
    platform: Option<&str>,
    device_family: Option<&str>,
    caps: Option<&[String]>,
) -> Vec<String> {
    let base = resolve_node_command_allowlist(
        &NodeCommandPolicyConfig::default(),
        platform,
        device_family,
    );
    let mut inferred = if let Some(caps) = caps {
        if caps.is_empty() {
            base
        } else {
            let cap_allowlist = node_capability_command_allowlist(caps);
            if cap_allowlist.is_empty() {
                base
            } else {
                base.intersection(&cap_allowlist)
                    .cloned()
                    .collect::<HashSet<_>>()
            }
        }
    } else {
        base
    };

    // Keep dangerous commands opt-in only even when a broad capability is declared.
    for command in NODE_DEFAULT_DANGEROUS_COMMANDS {
        let normalized = normalize(command);
        if !normalized.is_empty() {
            inferred.remove(&normalized);
        }
    }

    let mut commands = inferred.into_iter().collect::<Vec<_>>();
    commands.sort();
    commands
}

fn node_command_declared(declared_commands: &[String], command: &str) -> bool {
    declared_commands
        .iter()
        .any(|declared| declared.eq_ignore_ascii_case(command))
}

fn check_node_command_allowed(
    command: &str,
    declared_commands: Option<&[String]>,
    allowlist: &HashSet<String>,
) -> Result<(), NodeCommandPolicyFailure> {
    let Some(command_trimmed) = normalize_optional_text(Some(command.to_owned()), 160) else {
        return Err(NodeCommandPolicyFailure::CommandRequired);
    };
    let command_normalized = normalize(&command_trimmed);
    if !allowlist.contains(&command_normalized) {
        return Err(NodeCommandPolicyFailure::CommandNotAllowlisted);
    }
    let Some(declared_commands) = declared_commands else {
        return Err(NodeCommandPolicyFailure::NodeDidNotDeclareCommands);
    };
    if declared_commands.is_empty() {
        return Err(NodeCommandPolicyFailure::NodeDidNotDeclareCommands);
    }
    if !node_command_declared(declared_commands, &command_trimmed) {
        return Err(NodeCommandPolicyFailure::CommandNotDeclaredByNode);
    }
    Ok(())
}

fn node_command_allowed(
    node: &PairedNodeEntry,
    command: &str,
    policy: &NodeCommandPolicyConfig,
) -> Result<(), NodeCommandPolicyFailure> {
    let allowlist = resolve_node_command_allowlist(
        policy,
        node.platform.as_deref(),
        node.device_family.as_deref(),
    );
    check_node_command_allowed(command, node.commands.as_deref(), &allowlist)
}

fn node_inventory_command_allowed(
    node: &NodeInventoryEntry,
    command: &str,
    policy: &NodeCommandPolicyConfig,
) -> Result<(), NodeCommandPolicyFailure> {
    let allowlist = resolve_node_command_allowlist(
        policy,
        node.platform.as_deref(),
        node.device_family.as_deref(),
    );
    check_node_command_allowed(command, Some(&node.commands), &allowlist)
}

fn node_inventory_browser_capable(node: &NodeInventoryEntry) -> bool {
    node.caps
        .iter()
        .any(|cap| cap.eq_ignore_ascii_case("browser"))
        || node
            .commands
            .iter()
            .any(|command| command.eq_ignore_ascii_case("browser.proxy"))
}

fn node_caps_include_local_host_hint(caps: &[String]) -> bool {
    caps.iter().any(|cap| {
        LOCAL_NODE_CAP_HINTS
            .iter()
            .any(|hint| cap.eq_ignore_ascii_case(hint))
    })
}

fn node_id_list_contains(local_node_ids: &[String], node_id: &str) -> bool {
    local_node_ids
        .iter()
        .any(|allowed| allowed.eq_ignore_ascii_case(node_id))
}

fn paired_node_supports_local_host_runtime(
    node: &PairedNodeEntry,
    runtime: &NodeHostRuntimeConfig,
) -> bool {
    if node_id_list_contains(&runtime.local_node_ids, &node.node_id) {
        return true;
    }
    node.caps
        .as_ref()
        .is_some_and(|caps| node_caps_include_local_host_hint(caps))
}

fn inventory_node_supports_local_host_runtime(
    node: &NodeInventoryEntry,
    runtime: &NodeHostRuntimeConfig,
) -> bool {
    node_id_list_contains(&runtime.local_node_ids, &node.node_id)
        || node_caps_include_local_host_hint(&node.caps)
}

fn local_node_command_ok(payload: Value) -> LocalNodeCommandExecution {
    LocalNodeCommandExecution {
        ok: true,
        payload_json: serde_json::to_string(&payload).ok(),
        payload: Some(payload),
        error: None,
    }
}

fn local_node_command_error(code: &str, message: String) -> LocalNodeCommandExecution {
    LocalNodeCommandExecution {
        ok: false,
        payload: None,
        payload_json: None,
        error: Some(NodeInvokeResultError {
            code: Some(code.to_owned()),
            message: Some(message),
        }),
    }
}

fn parse_local_node_host_external_response(parsed_stdout: Value) -> LocalNodeCommandExecution {
    if let Some(object) = parsed_stdout.as_object() {
        let ok = object.get("ok").and_then(Value::as_bool).unwrap_or(true);
        if ok {
            if let Some(payload) = object.get("payload").cloned() {
                return local_node_command_ok(payload);
            }
            return local_node_command_ok(parsed_stdout);
        }
        let error = object.get("error").and_then(Value::as_object);
        return LocalNodeCommandExecution {
            ok: false,
            payload_json: serde_json::to_string(&parsed_stdout).ok(),
            payload: object
                .get("payload")
                .cloned()
                .or_else(|| Some(parsed_stdout.clone())),
            error: Some(NodeInvokeResultError {
                code: error
                    .and_then(|value| value.get("code"))
                    .and_then(Value::as_str)
                    .map(ToOwned::to_owned)
                    .or_else(|| Some("LOCAL_EXTERNAL_HOST_ERROR".to_owned())),
                message: error
                    .and_then(|value| value.get("message"))
                    .and_then(Value::as_str)
                    .map(ToOwned::to_owned)
                    .or_else(|| Some("external host runtime returned ok=false".to_owned())),
            }),
        };
    }
    local_node_command_ok(parsed_stdout)
}

fn resolve_node_host_external_runtime_command(
    runtime: &NodeHostRuntimeConfig,
    command: &str,
    platform: Option<&str>,
    device_family: Option<&str>,
) -> Option<NodeHostExternalCommand> {
    let normalized = normalize(command);
    let platform_key = normalize_node_platform_id(platform, device_family).to_owned();
    if let Some(platform_override) = runtime.external_platforms.get(&platform_key) {
        if let Some(mapped) = platform_override.external_commands.get(&normalized) {
            return Some(mapped.clone());
        }
    }
    if let Some(mapped) = runtime.external_commands.get(&normalized) {
        return Some(mapped.clone());
    }
    if let Some(platform_override) = runtime.external_platforms.get(&platform_key) {
        if let Some(command) = platform_override.external_command.as_deref() {
            return Some(NodeHostExternalCommand {
                command: command.to_owned(),
                args: platform_override.external_args.clone(),
            });
        }
    }
    runtime
        .external_command
        .as_ref()
        .cloned()
        .map(|command| NodeHostExternalCommand {
            command,
            args: runtime.external_args.clone(),
        })
}

async fn local_node_host_execute_external_command(
    node_id: &str,
    command: &str,
    params: Option<&Value>,
    runtime: &NodeHostRuntimeConfig,
    platform: Option<&str>,
    device_family: Option<&str>,
) -> LocalNodeCommandExecution {
    let Some(external_runtime) =
        resolve_node_host_external_runtime_command(runtime, command, platform, device_family)
    else {
        return local_node_command_error(
            "LOCAL_EXTERNAL_HOST_UNAVAILABLE",
            "external host runtime command is not configured".to_owned(),
        );
    };
    let request_payload = json!({
        "nodeId": node_id,
        "command": command,
        "params": params.cloned().unwrap_or_else(|| json!({})),
        "timeoutMs": runtime.system_run_timeout_ms,
        "ts": now_ms(),
    });
    let request_json = match serde_json::to_string(&request_payload) {
        Ok(json) => json,
        Err(err) => {
            return local_node_command_error(
                "LOCAL_EXTERNAL_HOST_INVALID_REQUEST",
                format!("failed to serialize external host request: {err}"),
            );
        }
    };

    let mut process = TokioCommand::new(&external_runtime.command);
    if !external_runtime.args.is_empty() {
        process.args(&external_runtime.args);
    }
    process
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .env("OPENCLAW_NODE_HOST_REQUEST", &request_json)
        .env("OPENCLAW_NODE_HOST_NODE_ID", node_id)
        .env("OPENCLAW_NODE_HOST_COMMAND", command)
        .env(
            "OPENCLAW_NODE_HOST_RUNTIME_COMMAND",
            &external_runtime.command,
        );

    let mut child = match process.spawn() {
        Ok(child) => child,
        Err(err) => {
            return local_node_command_error(
                "LOCAL_EXTERNAL_HOST_SPAWN_FAILED",
                format!(
                    "failed spawning external host runtime command {}: {err}",
                    external_runtime.command
                ),
            );
        }
    };

    if let Some(mut stdin) = child.stdin.take() {
        let request_bytes = request_json.into_bytes();
        if let Err(err) = tokio::io::AsyncWriteExt::write_all(&mut stdin, &request_bytes).await {
            return local_node_command_error(
                "LOCAL_EXTERNAL_HOST_IO",
                format!("failed writing external host request stdin: {err}"),
            );
        }
    }

    let timeout_ms = runtime.system_run_timeout_ms.clamp(500, 120_000);
    let output =
        match tokio::time::timeout(Duration::from_millis(timeout_ms), child.wait_with_output())
            .await
        {
            Ok(Ok(output)) => output,
            Ok(Err(err)) => {
                return local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_IO",
                    format!("external host runtime execution failed: {err}"),
                );
            }
            Err(_) => {
                return local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_TIMEOUT",
                    format!("external host runtime timed out after {timeout_ms}ms"),
                );
            }
        };

    let stdout_text = String::from_utf8_lossy(&output.stdout).trim().to_owned();
    let stderr_text = String::from_utf8_lossy(&output.stderr).trim().to_owned();
    if stdout_text.is_empty() {
        let message = if stderr_text.is_empty() {
            "external host runtime returned empty stdout".to_owned()
        } else {
            format!("external host runtime stderr: {stderr_text}")
        };
        return local_node_command_error("LOCAL_EXTERNAL_HOST_EMPTY", message);
    }

    let parsed_stdout: Value = match serde_json::from_str(&stdout_text) {
        Ok(value) => value,
        Err(err) => {
            return local_node_command_error(
                "LOCAL_EXTERNAL_HOST_INVALID_JSON",
                format!("external host runtime returned invalid JSON: {err}"),
            );
        }
    };

    if output.status.success() {
        return parse_local_node_host_external_response(parsed_stdout);
    }

    let exit_code = output
        .status
        .code()
        .map(|value| value.to_string())
        .unwrap_or_else(|| "unknown".to_owned());
    local_node_command_error(
        "LOCAL_EXTERNAL_HOST_EXIT",
        if stderr_text.is_empty() {
            format!("external host runtime exited with status {exit_code}")
        } else {
            format!("external host runtime exited with status {exit_code}: {stderr_text}")
        },
    )
}

enum LocalNodeHostSystemRunExecMode {
    Shell(String),
    Argv(Vec<String>),
}

struct LocalNodeHostSystemRunPlan {
    display_command: String,
    raw_command: Option<String>,
    argv: Option<Vec<String>>,
    mode: LocalNodeHostSystemRunExecMode,
    cwd: Option<String>,
    timeout_ms: u64,
    env: Vec<(String, String)>,
    ignored_env_keys: Vec<String>,
    needs_screen_recording: Option<bool>,
}

async fn local_node_host_execute_system_run(
    node_id: &str,
    params: Option<&Value>,
    runtime: &NodeHostRuntimeConfig,
) -> LocalNodeCommandExecution {
    if !runtime.allow_system_run {
        return local_node_command_error(
            "LOCAL_SYSTEM_RUN_DISABLED",
            "system.run is disabled for local host runtime".to_owned(),
        );
    }
    let plan = match build_local_node_host_system_run_plan(params, runtime) {
        Ok(plan) => plan,
        Err(message) => {
            return local_node_command_error("LOCAL_SYSTEM_RUN_INVALID", message);
        }
    };
    let mut command = match &plan.mode {
        LocalNodeHostSystemRunExecMode::Shell(raw_command) => {
            if cfg!(windows) {
                let mut cmd = TokioCommand::new("cmd");
                cmd.arg("/C").arg(raw_command);
                cmd
            } else {
                let mut cmd = TokioCommand::new("sh");
                cmd.arg("-lc").arg(raw_command);
                cmd
            }
        }
        LocalNodeHostSystemRunExecMode::Argv(argv) => {
            let mut cmd = TokioCommand::new(&argv[0]);
            if argv.len() > 1 {
                cmd.args(&argv[1..]);
            }
            cmd
        }
    };
    if let Some(cwd) = &plan.cwd {
        command.current_dir(cwd);
    }
    for (key, value) in &plan.env {
        command.env(key, value);
    }
    command
        .stdin(Stdio::null())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());
    let output = match tokio::time::timeout(
        Duration::from_millis(plan.timeout_ms),
        command.output(),
    )
    .await
    {
        Ok(Ok(output)) => output,
        Ok(Err(err)) => {
            return local_node_command_error(
                "LOCAL_SYSTEM_RUN_FAILED",
                format!("system.run execution failed: {err}"),
            );
        }
        Err(_) => {
            return local_node_command_error(
                "LOCAL_SYSTEM_RUN_TIMEOUT",
                format!("system.run timed out after {}ms", plan.timeout_ms),
            );
        }
    };
    let stdout = truncate_text(
        &String::from_utf8_lossy(&output.stdout),
        LOCAL_NODE_HOST_SYSTEM_RUN_OUTPUT_MAX_CHARS,
    );
    let stderr = truncate_text(
        &String::from_utf8_lossy(&output.stderr),
        LOCAL_NODE_HOST_SYSTEM_RUN_OUTPUT_MAX_CHARS,
    );
    let payload = json!({
        "ok": output.status.success(),
        "nodeId": node_id,
        "command": plan.display_command,
        "rawCommand": plan.raw_command,
        "argv": plan.argv,
        "cwd": plan.cwd,
        "stdout": stdout,
        "stderr": stderr,
        "exitCode": output.status.code(),
        "timeoutMs": plan.timeout_ms,
        "envCount": plan.env.len(),
        "ignoredEnvKeys": plan.ignored_env_keys,
        "needsScreenRecording": plan.needs_screen_recording,
        "source": "local-host-runtime"
    });
    if output.status.success() {
        local_node_command_ok(payload)
    } else {
        let exit_code = output
            .status
            .code()
            .map(|value| value.to_string())
            .unwrap_or_else(|| "unknown".to_owned());
        LocalNodeCommandExecution {
            ok: false,
            payload_json: serde_json::to_string(&payload).ok(),
            payload: Some(payload.clone()),
            error: Some(NodeInvokeResultError {
                code: Some("LOCAL_SYSTEM_RUN_EXIT_NONZERO".to_owned()),
                message: Some(format!("system.run exited with status {exit_code}")),
            }),
        }
    }
}

fn build_local_node_host_system_run_plan(
    params: Option<&Value>,
    runtime: &NodeHostRuntimeConfig,
) -> Result<LocalNodeHostSystemRunPlan, String> {
    let Some(object) = params.and_then(Value::as_object) else {
        return Err("system.run requires params.command".to_owned());
    };
    let raw_command = object
        .get("rawCommand")
        .or_else(|| object.get("raw_command"))
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 4_096));
    let (display_command, mode, argv, allowlist_head, shell_text) =
        match object.get("command").or_else(|| object.get("cmd")) {
            Some(Value::String(raw)) => {
                if raw_command.is_some() {
                    return Err("rawCommand requires params.command".to_owned());
                }
                let Some(command_text) = normalize_optional_text(Some(raw.to_owned()), 4_096)
                else {
                    return Err("system.run command is empty".to_owned());
                };
                let Some(head) = local_node_host_system_run_head_token(&command_text) else {
                    return Err("system.run command is empty".to_owned());
                };
                (
                    command_text.clone(),
                    LocalNodeHostSystemRunExecMode::Shell(command_text.clone()),
                    None,
                    head,
                    Some(command_text),
                )
            }
            Some(Value::Array(items)) => {
                let argv = parse_local_node_host_system_run_argv(items)?;
                let inferred = infer_local_node_host_system_run_text_from_argv(&argv);
                if let Some(raw) = &raw_command {
                    if raw != &inferred {
                        return Err("INVALID_REQUEST: rawCommand does not match command".to_owned());
                    }
                }
                let display_command = raw_command.clone().unwrap_or_else(|| inferred.clone());
                let (allowlist_head, shell_text) =
                    match extract_local_node_host_shell_command_from_argv(&argv) {
                        Some(shell_command) => {
                            let Some(head) = local_node_host_system_run_head_token(&shell_command)
                            else {
                                return Err("system.run command is empty".to_owned());
                            };
                            (head, Some(shell_command))
                        }
                        None => {
                            let Some(head) = local_node_host_system_run_argv_head(&argv) else {
                                return Err("system.run command is empty".to_owned());
                            };
                            (head, None)
                        }
                    };
                (
                    display_command,
                    LocalNodeHostSystemRunExecMode::Argv(argv.clone()),
                    Some(argv),
                    allowlist_head,
                    shell_text,
                )
            }
            _ => return Err("system.run requires params.command".to_owned()),
        };
    if let Some(shell_command) = &shell_text {
        if shell_command
            .chars()
            .any(|ch| matches!(ch, '&' | '|' | ';' | '>' | '<' | '`' | '\n' | '\r'))
        {
            return Err("system.run command contains blocked shell metacharacters".to_owned());
        }
    }
    if !LOCAL_NODE_HOST_SYSTEM_RUN_ALLOWLIST
        .iter()
        .any(|allowed| allowed.eq_ignore_ascii_case(&allowlist_head))
    {
        return Err(format!(
            "system.run command not allowed by local host runtime allowlist: {allowlist_head}"
        ));
    }
    let cwd = object
        .get("cwd")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 2_048));
    let timeout_ms = object
        .get("timeoutMs")
        .or_else(|| object.get("timeout_ms"))
        .or_else(|| object.get("commandTimeoutMs"))
        .or_else(|| object.get("command_timeout_ms"))
        .or_else(|| object.get("commandTimeout"))
        .or_else(|| object.get("command_timeout"))
        .and_then(config_value_as_u64)
        .unwrap_or(runtime.system_run_timeout_ms)
        .clamp(500, 120_000);
    let (env, ignored_env_keys) = parse_local_node_host_system_run_env(object);
    let needs_screen_recording = object
        .get("needsScreenRecording")
        .or_else(|| object.get("needs_screen_recording"))
        .and_then(Value::as_bool);
    Ok(LocalNodeHostSystemRunPlan {
        display_command,
        raw_command,
        argv,
        mode,
        cwd,
        timeout_ms,
        env,
        ignored_env_keys,
        needs_screen_recording,
    })
}

fn parse_local_node_host_system_run_argv(items: &[Value]) -> Result<Vec<String>, String> {
    let mut argv = Vec::new();
    for item in items {
        let Some(raw) = item.as_str() else {
            continue;
        };
        let Some(arg) =
            normalize_optional_text(Some(raw.to_owned()), LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ARG_LEN)
        else {
            continue;
        };
        argv.push(arg);
        if argv.len() >= LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ARGV_ITEMS {
            break;
        }
    }
    if argv.is_empty() {
        return Err("system.run requires params.command".to_owned());
    }
    Ok(argv)
}

fn local_node_host_system_run_head_token(command: &str) -> Option<String> {
    let raw_head = command.split_whitespace().next()?;
    let normalized = raw_head.trim();
    if normalized.is_empty() {
        return None;
    }
    let base = Path::new(normalized)
        .file_name()
        .map(|value| value.to_string_lossy().to_string())
        .unwrap_or_else(|| normalized.to_owned());
    normalize_optional_text(Some(base), 160).map(|value| value.to_ascii_lowercase())
}

fn local_node_host_system_run_argv_head(argv: &[String]) -> Option<String> {
    let first = argv.first()?;
    let base = Path::new(first)
        .file_name()
        .map(|value| value.to_string_lossy().to_string())
        .unwrap_or_else(|| first.to_owned());
    normalize_optional_text(Some(base), 160).map(|value| value.to_ascii_lowercase())
}

fn extract_local_node_host_shell_command_from_argv(argv: &[String]) -> Option<String> {
    let token0 = argv.first()?.trim();
    let base0 = Path::new(token0)
        .file_name()
        .map(|value| value.to_string_lossy().to_string())
        .unwrap_or_else(|| token0.to_owned())
        .to_ascii_lowercase();
    if matches!(base0.as_str(), "sh" | "bash" | "zsh" | "dash" | "ksh")
        && matches!(argv.get(1).map(String::as_str), Some("-c") | Some("-lc"))
    {
        return argv
            .get(2)
            .and_then(|value| normalize_optional_text(Some(value.clone()), 4_096));
    }
    if matches!(base0.as_str(), "cmd" | "cmd.exe") {
        let index = argv
            .iter()
            .position(|value| value.trim().eq_ignore_ascii_case("/c"))?;
        return argv
            .get(index + 1)
            .and_then(|value| normalize_optional_text(Some(value.clone()), 4_096));
    }
    None
}

fn infer_local_node_host_system_run_text_from_argv(argv: &[String]) -> String {
    if let Some(shell_command) = extract_local_node_host_shell_command_from_argv(argv) {
        return shell_command;
    }
    argv.iter()
        .map(|arg| {
            if arg.chars().any(|ch| ch.is_whitespace() || ch == '"') {
                format!("\"{}\"", arg.replace('"', "\\\""))
            } else {
                arg.clone()
            }
        })
        .collect::<Vec<_>>()
        .join(" ")
}

fn parse_local_node_host_system_run_env(
    object: &serde_json::Map<String, Value>,
) -> (Vec<(String, String)>, Vec<String>) {
    let mut env = Vec::new();
    let mut ignored = Vec::new();
    let Some(value) = object.get("env") else {
        return (env, ignored);
    };
    match value {
        Value::Object(map) => {
            for (raw_key, raw_value) in map {
                let Some(value_text) = raw_value.as_str().and_then(|raw| {
                    normalize_optional_text(
                        Some(raw.to_owned()),
                        LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ENV_VALUE_LEN,
                    )
                }) else {
                    continue;
                };
                push_local_node_host_system_run_env_entry(
                    &mut env,
                    &mut ignored,
                    raw_key,
                    &value_text,
                );
            }
        }
        Value::Array(items) => {
            for item in items {
                let Some(entry) = item.as_str() else {
                    continue;
                };
                let Some((raw_key, raw_value)) = entry.split_once('=') else {
                    continue;
                };
                let Some(value_text) = normalize_optional_text(
                    Some(raw_value.to_owned()),
                    LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ENV_VALUE_LEN,
                ) else {
                    continue;
                };
                push_local_node_host_system_run_env_entry(
                    &mut env,
                    &mut ignored,
                    raw_key,
                    &value_text,
                );
                if env.len() >= LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ENV_ITEMS {
                    break;
                }
            }
        }
        _ => {}
    }
    (env, ignored)
}

fn push_local_node_host_system_run_env_entry(
    env: &mut Vec<(String, String)>,
    ignored: &mut Vec<String>,
    raw_key: &str,
    raw_value: &str,
) {
    if env.len() >= LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ENV_ITEMS {
        return;
    }
    let Some(key) = normalize_optional_text(
        Some(raw_key.to_owned()),
        LOCAL_NODE_HOST_SYSTEM_RUN_MAX_ENV_KEY_LEN,
    ) else {
        return;
    };
    if key.eq_ignore_ascii_case("PATH") {
        if !ignored
            .iter()
            .any(|entry| entry.eq_ignore_ascii_case("PATH"))
        {
            ignored.push("PATH".to_owned());
        }
        return;
    }
    let mut chars = key.chars();
    let Some(first) = chars.next() else {
        return;
    };
    if !(first.is_ascii_alphabetic() || first == '_') {
        return;
    }
    if !chars.all(|ch| ch.is_ascii_alphanumeric() || ch == '_') {
        return;
    }
    if env
        .iter()
        .any(|(existing_key, _)| existing_key.eq_ignore_ascii_case(&key))
    {
        return;
    }
    env.push((key, raw_value.to_owned()));
}

fn local_node_host_execute_system_which(
    node_id: &str,
    params: Option<&Value>,
) -> LocalNodeCommandExecution {
    let bins = extract_local_node_host_system_which_bins(params);
    if bins.is_empty() {
        return local_node_command_error(
            "LOCAL_SYSTEM_WHICH_INVALID",
            "system.which requires params.bins (string or array)".to_owned(),
        );
    }
    let mut found = serde_json::Map::new();
    for bin in bins {
        if let Some(path) = resolve_local_node_host_executable_path(&bin) {
            found.insert(bin, Value::String(path));
        }
    }
    local_node_command_ok(json!({
        "ok": true,
        "nodeId": node_id,
        "bins": Value::Object(found),
        "source": "local-host-runtime"
    }))
}

fn extract_local_node_host_system_which_bins(params: Option<&Value>) -> Vec<String> {
    let Some(object) = params.and_then(Value::as_object) else {
        return Vec::new();
    };
    let mut out = Vec::new();

    if let Some(value) = object.get("bins").or_else(|| object.get("bin")) {
        match value {
            Value::Array(items) => {
                for item in items {
                    if let Some(raw) = item.as_str() {
                        push_local_node_host_system_which_bin(&mut out, raw);
                        if out.len() >= LOCAL_NODE_HOST_SYSTEM_WHICH_MAX_BINS {
                            break;
                        }
                    }
                }
            }
            Value::String(raw) => push_local_node_host_system_which_bin(&mut out, raw),
            _ => {}
        }
    }
    out
}

fn push_local_node_host_system_which_bin(out: &mut Vec<String>, raw: &str) {
    let Some(bin) = normalize_optional_text(
        Some(raw.to_owned()),
        LOCAL_NODE_HOST_SYSTEM_WHICH_MAX_BIN_LEN,
    ) else {
        return;
    };
    if out.iter().any(|existing: &String| existing == &bin) {
        return;
    }
    out.push(bin);
}

fn resolve_local_node_host_executable_path(bin: &str) -> Option<String> {
    let candidate = PathBuf::from(bin);
    if candidate.is_absolute() || bin.contains('/') || bin.contains('\\') {
        if candidate.is_file() {
            return Some(display_local_node_host_path(candidate));
        }
        return None;
    }
    let path_env = env::var_os("PATH")?;
    let search_paths = env::split_paths(&path_env).collect::<Vec<_>>();
    if cfg!(windows) {
        let mut extensions = local_node_host_windows_path_extensions();
        if !extensions.iter().any(|ext| ext.is_empty()) {
            extensions.insert(0, String::new());
        }
        let bin_lower = bin.to_ascii_lowercase();
        for directory in search_paths {
            for ext in &extensions {
                let needs_ext = !ext.is_empty() && !bin_lower.ends_with(ext.as_str());
                let file_name = if needs_ext {
                    format!("{bin}{ext}")
                } else {
                    bin.to_owned()
                };
                let candidate = directory.join(file_name);
                if candidate.is_file() {
                    return Some(display_local_node_host_path(candidate));
                }
            }
        }
        return None;
    }
    for directory in search_paths {
        let candidate = directory.join(bin);
        if candidate.is_file() {
            return Some(display_local_node_host_path(candidate));
        }
    }
    None
}

fn local_node_host_windows_path_extensions() -> Vec<String> {
    let default = vec![
        ".exe".to_owned(),
        ".cmd".to_owned(),
        ".bat".to_owned(),
        ".com".to_owned(),
    ];
    let Some(raw) = env::var_os("PATHEXT") else {
        return default;
    };
    let Some(text) = raw.to_str() else {
        return default;
    };
    let mut out = Vec::new();
    for value in text.split(';') {
        let normalized = value.trim().to_ascii_lowercase();
        if normalized.is_empty() {
            continue;
        }
        if !normalized.starts_with('.') {
            continue;
        }
        if out.iter().any(|existing: &String| existing == &normalized) {
            continue;
        }
        out.push(normalized);
    }
    if out.is_empty() {
        default
    } else {
        out
    }
}

fn display_local_node_host_path(path: PathBuf) -> String {
    match path.canonicalize() {
        Ok(canonical) => canonical.to_string_lossy().to_string(),
        Err(_) => path.to_string_lossy().to_string(),
    }
}

fn local_node_host_execute_system_notify(
    node_id: &str,
    params: Option<&Value>,
) -> LocalNodeCommandExecution {
    let params_obj = params.and_then(Value::as_object);
    let title = params_obj
        .and_then(|obj| {
            obj.get("title")
                .or_else(|| obj.get("subject"))
                .or_else(|| obj.get("summary"))
        })
        .and_then(Value::as_str)
        .and_then(|raw| {
            normalize_optional_text(
                Some(raw.to_owned()),
                LOCAL_NODE_HOST_SYSTEM_NOTIFY_TITLE_MAX_CHARS,
            )
        })
        .unwrap_or_else(|| "OpenClaw".to_owned());
    let body = params_obj
        .and_then(|obj| {
            obj.get("body")
                .or_else(|| obj.get("message"))
                .or_else(|| obj.get("text"))
        })
        .and_then(Value::as_str)
        .and_then(|raw| {
            normalize_optional_text(
                Some(raw.to_owned()),
                LOCAL_NODE_HOST_SYSTEM_NOTIFY_BODY_MAX_CHARS,
            )
        })
        .unwrap_or_default();
    let level = params_obj
        .and_then(|obj| obj.get("level"))
        .and_then(Value::as_str)
        .and_then(|raw| {
            normalize_optional_text(
                Some(raw.to_owned()),
                LOCAL_NODE_HOST_SYSTEM_NOTIFY_LEVEL_MAX_CHARS,
            )
        })
        .unwrap_or_else(|| "info".to_owned());
    let priority = params_obj
        .and_then(|obj| obj.get("priority"))
        .and_then(Value::as_str)
        .and_then(|raw| {
            normalize_optional_text(
                Some(raw.to_owned()),
                LOCAL_NODE_HOST_SYSTEM_NOTIFY_PRIORITY_MAX_CHARS,
            )
        })
        .unwrap_or_else(|| "active".to_owned());
    let delivery = params_obj
        .and_then(|obj| obj.get("delivery"))
        .and_then(Value::as_str)
        .and_then(|raw| {
            normalize_optional_text(
                Some(raw.to_owned()),
                LOCAL_NODE_HOST_SYSTEM_NOTIFY_DELIVERY_MAX_CHARS,
            )
        })
        .unwrap_or_else(|| "auto".to_owned());
    let notification_id = next_local_node_notify_id();
    local_node_command_ok(json!({
        "ok": true,
        "nodeId": node_id,
        "notificationId": notification_id,
        "title": title,
        "body": body,
        "level": level,
        "priority": priority,
        "delivery": delivery,
        "deliveredAtMs": now_ms(),
        "source": "local-host-runtime"
    }))
}

fn next_local_node_notify_id() -> String {
    let sequence = NODE_NOTIFY_SEQUENCE.fetch_add(1, Ordering::Relaxed) + 1;
    format!("notify-{}-{sequence}", now_ms())
}

fn local_node_host_duration_ms_from_params(params: Option<&Value>, default: u64, max: u64) -> u64 {
    let Some(object) = params.and_then(Value::as_object) else {
        return default.clamp(1, max);
    };
    let duration_ms = object
        .get("durationMs")
        .or_else(|| object.get("duration_ms"))
        .and_then(config_value_as_u64)
        .or_else(|| {
            object
                .get("seconds")
                .and_then(config_value_as_u64)
                .map(|seconds| seconds.saturating_mul(1_000))
        })
        .unwrap_or(default);
    duration_ms.clamp(1_000, max)
}

fn local_node_host_include_audio_from_params(params: Option<&Value>) -> bool {
    let Some(object) = params.and_then(Value::as_object) else {
        return true;
    };
    if let Some(include_audio) = object
        .get("includeAudio")
        .or_else(|| object.get("include_audio"))
        .and_then(Value::as_bool)
    {
        return include_audio;
    }
    if let Some(no_audio) = object
        .get("noAudio")
        .or_else(|| object.get("no_audio"))
        .and_then(Value::as_bool)
    {
        return !no_audio;
    }
    true
}

fn normalize_browser_node_key(value: &str) -> String {
    value
        .trim()
        .to_ascii_lowercase()
        .chars()
        .filter(char::is_ascii_alphanumeric)
        .collect()
}

fn resolve_browser_node(
    nodes: &[NodeInventoryEntry],
    requested: &str,
) -> Result<Option<NodeInventoryEntry>, String> {
    let query = requested.trim();
    if query.is_empty() {
        return Ok(None);
    }
    let normalized_query = normalize_browser_node_key(query);
    let mut matches = nodes
        .iter()
        .filter(|node| {
            if node.node_id == query {
                return true;
            }
            if node
                .remote_ip
                .as_deref()
                .is_some_and(|remote_ip| remote_ip == query)
            {
                return true;
            }
            if node.display_name.as_deref().is_some_and(|display_name| {
                normalize_browser_node_key(display_name) == normalized_query
            }) {
                return true;
            }
            query.len() >= 6 && node.node_id.starts_with(query)
        })
        .cloned()
        .collect::<Vec<_>>();
    if matches.len() == 1 {
        return Ok(matches.pop());
    }
    if matches.is_empty() {
        return Ok(None);
    }
    let candidates = matches
        .iter()
        .map(|node| {
            node.display_name
                .clone()
                .or_else(|| node.remote_ip.clone())
                .unwrap_or_else(|| node.node_id.clone())
        })
        .collect::<Vec<_>>()
        .join(", ");
    Err(format!("ambiguous node: {query} (matches: {candidates})"))
}

fn resolve_browser_node_target(
    browser_nodes: &[NodeInventoryEntry],
    requested: Option<&str>,
) -> Result<Option<NodeInventoryEntry>, String> {
    if browser_nodes.is_empty() {
        return Ok(None);
    }
    if let Some(requested) = requested {
        return match resolve_browser_node(browser_nodes, requested)? {
            Some(node) => Ok(Some(node)),
            None => Err(format!(
                "Configured browser node not connected: {}",
                requested.trim()
            )),
        };
    }
    if browser_nodes.len() == 1 {
        return Ok(browser_nodes.first().cloned());
    }
    Ok(None)
}

struct NodeHostRuntimeRegistry {
    state: Mutex<NodeHostRuntimeState>,
}

#[derive(Default)]
struct NodeHostRuntimeState {
    sessions: HashMap<String, NodeHostRuntimeSession>,
}

#[derive(Clone)]
struct NodeHostRuntimeSession {
    command: String,
    args: Vec<String>,
    sender: mpsc::Sender<NodeHostRuntimeRequest>,
    created_at_ms: u64,
    last_used_at_ms: u64,
}

struct NodeHostRuntimeRequest {
    request_json: String,
    request_timeout_ms: u64,
    respond_to: oneshot::Sender<LocalNodeCommandExecution>,
}

impl NodeHostRuntimeRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(NodeHostRuntimeState::default()),
        }
    }

    async fn execute_external_command(
        &self,
        node_id: &str,
        command: &str,
        params: Option<&Value>,
        runtime: &NodeHostRuntimeConfig,
        platform: Option<&str>,
        device_family: Option<&str>,
    ) -> LocalNodeCommandExecution {
        let Some(external_runtime) =
            resolve_node_host_external_runtime_command(runtime, command, platform, device_family)
        else {
            return local_node_command_error(
                "LOCAL_EXTERNAL_HOST_UNAVAILABLE",
                "external host runtime command is not configured".to_owned(),
            );
        };
        if !runtime.external_persistent {
            return local_node_host_execute_external_command(
                node_id,
                command,
                params,
                runtime,
                platform,
                device_family,
            )
            .await;
        }
        let request_payload = json!({
            "nodeId": node_id,
            "command": command,
            "params": params.cloned().unwrap_or_else(|| json!({})),
            "timeoutMs": runtime.system_run_timeout_ms,
            "ts": now_ms(),
        });
        let request_json = match serde_json::to_string(&request_payload) {
            Ok(json) => json,
            Err(err) => {
                return local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_INVALID_REQUEST",
                    format!("failed to serialize external host request: {err}"),
                );
            }
        };
        let session_key = node_host_external_runtime_session_key(&external_runtime);
        let sender = self
            .acquire_or_spawn_session(
                &session_key,
                external_runtime,
                runtime.external_queue_capacity,
                runtime.external_idle_timeout_ms,
            )
            .await;
        let request_timeout_ms = runtime.system_run_timeout_ms.clamp(500, 120_000);
        let (respond_to, waiter) = oneshot::channel();
        let request = NodeHostRuntimeRequest {
            request_json,
            request_timeout_ms,
            respond_to,
        };
        match sender.try_send(request) {
            Ok(()) => {}
            Err(mpsc::error::TrySendError::Full(_)) => {
                return local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_QUEUE_FULL",
                    "persistent external host runtime queue is full".to_owned(),
                );
            }
            Err(mpsc::error::TrySendError::Closed(_)) => {
                self.remove_session(&session_key).await;
                return local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_IO",
                    "persistent external host runtime session closed".to_owned(),
                );
            }
        }
        match tokio::time::timeout(
            Duration::from_millis(request_timeout_ms.saturating_add(500)),
            waiter,
        )
        .await
        {
            Ok(Ok(result)) => result,
            Ok(Err(_)) => {
                self.remove_session(&session_key).await;
                local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_IO",
                    "persistent external host runtime dropped response channel".to_owned(),
                )
            }
            Err(_) => {
                self.remove_session(&session_key).await;
                local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_TIMEOUT",
                    format!("external host runtime timed out after {request_timeout_ms}ms"),
                )
            }
        }
    }

    async fn acquire_or_spawn_session(
        &self,
        session_key: &str,
        external_runtime: NodeHostExternalCommand,
        queue_capacity: usize,
        idle_timeout_ms: u64,
    ) -> mpsc::Sender<NodeHostRuntimeRequest> {
        let now = now_ms();
        let mut guard = self.state.lock().await;
        if let Some(existing) = guard.sessions.get_mut(session_key) {
            if !existing.sender.is_closed()
                && existing.command == external_runtime.command
                && existing.args == external_runtime.args
            {
                existing.last_used_at_ms = now;
                return existing.sender.clone();
            }
            let _ = guard.sessions.remove(session_key);
        }
        let (sender, receiver) = mpsc::channel(queue_capacity.clamp(1, 1_024));
        spawn_node_host_external_runtime_session_task(
            external_runtime.clone(),
            receiver,
            idle_timeout_ms.clamp(1_000, 600_000),
        );
        guard.sessions.insert(
            session_key.to_owned(),
            NodeHostRuntimeSession {
                command: external_runtime.command,
                args: external_runtime.args,
                sender: sender.clone(),
                created_at_ms: now,
                last_used_at_ms: now,
            },
        );
        prune_node_host_runtime_sessions(
            &mut guard.sessions,
            LOCAL_NODE_HOST_EXTERNAL_MAX_SESSIONS,
        );
        sender
    }

    async fn remove_session(&self, session_key: &str) {
        if session_key.trim().is_empty() {
            return;
        }
        let mut guard = self.state.lock().await;
        let _ = guard.sessions.remove(session_key);
    }

    #[cfg(test)]
    async fn active_session_count(&self) -> usize {
        let guard = self.state.lock().await;
        guard.sessions.len()
    }
}

fn node_host_external_runtime_session_key(runtime: &NodeHostExternalCommand) -> String {
    let mut key = runtime.command.trim().to_owned();
    for arg in &runtime.args {
        key.push('\u{1f}');
        key.push_str(arg.trim());
    }
    normalize(&key)
}

fn prune_node_host_runtime_sessions(
    sessions: &mut HashMap<String, NodeHostRuntimeSession>,
    max_sessions: usize,
) {
    let closed_keys = sessions
        .iter()
        .filter_map(|(key, entry)| {
            if entry.sender.is_closed() {
                Some(key.clone())
            } else {
                None
            }
        })
        .collect::<Vec<_>>();
    for key in closed_keys {
        let _ = sessions.remove(&key);
    }
    while sessions.len() > max_sessions {
        let Some(oldest_key) = sessions
            .iter()
            .min_by_key(|(_, entry)| (entry.last_used_at_ms, entry.created_at_ms))
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = sessions.remove(&oldest_key);
    }
}

fn spawn_node_host_external_runtime_session_task(
    external_runtime: NodeHostExternalCommand,
    mut receiver: mpsc::Receiver<NodeHostRuntimeRequest>,
    idle_timeout_ms: u64,
) {
    tokio::spawn(async move {
        let mut process = TokioCommand::new(&external_runtime.command);
        if !external_runtime.args.is_empty() {
            process.args(&external_runtime.args);
        }
        process
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::null())
            .env("OPENCLAW_NODE_HOST_MODE", "persistent")
            .env(
                "OPENCLAW_NODE_HOST_RUNTIME_COMMAND",
                &external_runtime.command,
            );

        let mut child = match process.spawn() {
            Ok(child) => child,
            Err(err) => {
                drain_node_host_runtime_requests_with_error(
                    &mut receiver,
                    "LOCAL_EXTERNAL_HOST_SPAWN_FAILED",
                    format!(
                        "failed spawning persistent external host runtime command {}: {err}",
                        external_runtime.command
                    ),
                );
                return;
            }
        };
        let Some(mut stdin) = child.stdin.take() else {
            drain_node_host_runtime_requests_with_error(
                &mut receiver,
                "LOCAL_EXTERNAL_HOST_IO",
                "persistent external host runtime missing stdin pipe".to_owned(),
            );
            let _ = child.start_kill();
            let _ = child.wait().await;
            return;
        };
        let Some(stdout) = child.stdout.take() else {
            drain_node_host_runtime_requests_with_error(
                &mut receiver,
                "LOCAL_EXTERNAL_HOST_IO",
                "persistent external host runtime missing stdout pipe".to_owned(),
            );
            let _ = child.start_kill();
            let _ = child.wait().await;
            return;
        };

        let mut stdout_reader = BufReader::new(stdout);
        let idle_timeout = Duration::from_millis(idle_timeout_ms);
        loop {
            let request = match tokio::time::timeout(idle_timeout, receiver.recv()).await {
                Ok(Some(request)) => request,
                Ok(None) | Err(_) => break,
            };

            if let Err(err) =
                write_persistent_node_host_request(&mut stdin, &request.request_json).await
            {
                let _ = request.respond_to.send(local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_IO",
                    format!("failed writing external host request stdin: {err}"),
                ));
                drain_node_host_runtime_requests_with_error(
                    &mut receiver,
                    "LOCAL_EXTERNAL_HOST_IO",
                    "persistent external host runtime write failed".to_owned(),
                );
                break;
            }

            let response =
                read_persistent_node_host_response(&mut stdout_reader, request.request_timeout_ms)
                    .await;
            let _ = request.respond_to.send(response);
        }

        let _ = child.start_kill();
        let _ = child.wait().await;
    });
}

async fn write_persistent_node_host_request(
    stdin: &mut tokio::process::ChildStdin,
    request_json: &str,
) -> Result<(), std::io::Error> {
    stdin.write_all(request_json.as_bytes()).await?;
    stdin.write_all(b"\n").await?;
    stdin.flush().await?;
    Ok(())
}

async fn read_persistent_node_host_response<R>(
    stdout_reader: &mut R,
    timeout_ms: u64,
) -> LocalNodeCommandExecution
where
    R: tokio::io::AsyncBufRead + Unpin,
{
    let mut line = String::new();
    let timeout_ms = timeout_ms.clamp(500, 120_000);
    let mut parse_attempts = 0usize;
    loop {
        line.clear();
        let read = match tokio::time::timeout(
            Duration::from_millis(timeout_ms),
            stdout_reader.read_line(&mut line),
        )
        .await
        {
            Ok(Ok(read)) => read,
            Ok(Err(err)) => {
                return local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_IO",
                    format!("failed reading external host response: {err}"),
                );
            }
            Err(_) => {
                return local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_TIMEOUT",
                    format!("external host runtime timed out after {timeout_ms}ms"),
                );
            }
        };
        if read == 0 {
            return local_node_command_error(
                "LOCAL_EXTERNAL_HOST_IO",
                "external host runtime closed stdout".to_owned(),
            );
        }
        let trimmed = line.trim();
        if trimmed.is_empty() {
            parse_attempts = parse_attempts.saturating_add(1);
            if parse_attempts >= 8 {
                return local_node_command_error(
                    "LOCAL_EXTERNAL_HOST_EMPTY",
                    "external host runtime returned empty stdout".to_owned(),
                );
            }
            continue;
        }
        if trimmed.len() > LOCAL_NODE_HOST_EXTERNAL_RESPONSE_LINE_MAX_CHARS {
            return local_node_command_error(
                "LOCAL_EXTERNAL_HOST_INVALID_JSON",
                "external host runtime response line exceeded size limit".to_owned(),
            );
        }
        let parsed_stdout: Value = match serde_json::from_str(trimmed) {
            Ok(value) => value,
            Err(err) => {
                parse_attempts = parse_attempts.saturating_add(1);
                if parse_attempts >= 8 {
                    return local_node_command_error(
                        "LOCAL_EXTERNAL_HOST_INVALID_JSON",
                        format!("external host runtime returned invalid JSON: {err}"),
                    );
                }
                continue;
            }
        };
        return parse_local_node_host_external_response(parsed_stdout);
    }
}

fn drain_node_host_runtime_requests_with_error(
    receiver: &mut mpsc::Receiver<NodeHostRuntimeRequest>,
    code: &str,
    message: String,
) {
    while let Ok(pending) = receiver.try_recv() {
        let _ = pending
            .respond_to
            .send(local_node_command_error(code, message.clone()));
    }
}

struct NodeRuntimeRegistry {
    state: Mutex<NodeRuntimeState>,
}

#[derive(Default)]
struct NodeRuntimeState {
    pending_invokes: HashMap<String, NodeInvokePendingEntry>,
    invoke_waiters: HashMap<String, oneshot::Sender<NodeInvokeCompletion>>,
    recent_results: VecDeque<Value>,
    recent_events: VecDeque<Value>,
}

#[derive(Debug, Clone)]
struct NodeInvokePendingEntry {
    id: String,
    node_id: String,
    command: String,
    idempotency_key: String,
    created_at_ms: u64,
    timeout_ms: Option<u64>,
}

#[derive(Debug)]
struct NodeInvokeCompletion {
    ok: bool,
    payload: Option<Value>,
    payload_json: Option<String>,
    error: Option<NodeInvokeResultError>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum NodeInvokeCompleteResult {
    Completed,
    Ignored,
    NodeMismatch,
}

impl NodeRuntimeRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(NodeRuntimeState::default()),
        }
    }

    async fn begin_invoke(
        &self,
        node_id: &str,
        command: &str,
        timeout_ms: Option<u64>,
        idempotency_key: &str,
    ) -> String {
        let now = now_ms();
        let invoke_id = next_node_invoke_id();
        let entry = NodeInvokePendingEntry {
            id: invoke_id.clone(),
            node_id: node_id.to_owned(),
            command: command.to_owned(),
            idempotency_key: idempotency_key.to_owned(),
            created_at_ms: now,
            timeout_ms,
        };
        let mut guard = self.state.lock().await;
        guard.pending_invokes.insert(invoke_id.clone(), entry);
        let dropped = prune_oldest_node_invoke_pending(&mut guard.pending_invokes, 4_096);
        for dropped_id in dropped {
            let _ = guard.invoke_waiters.remove(&dropped_id);
        }
        invoke_id
    }

    async fn begin_invoke_with_wait(
        &self,
        node_id: &str,
        command: &str,
        timeout_ms: Option<u64>,
        idempotency_key: &str,
    ) -> (String, oneshot::Receiver<NodeInvokeCompletion>) {
        let now = now_ms();
        let invoke_id = next_node_invoke_id();
        let entry = NodeInvokePendingEntry {
            id: invoke_id.clone(),
            node_id: node_id.to_owned(),
            command: command.to_owned(),
            idempotency_key: idempotency_key.to_owned(),
            created_at_ms: now,
            timeout_ms,
        };
        let (tx, rx) = oneshot::channel();
        let mut guard = self.state.lock().await;
        guard.pending_invokes.insert(invoke_id.clone(), entry);
        guard.invoke_waiters.insert(invoke_id.clone(), tx);
        let dropped = prune_oldest_node_invoke_pending(&mut guard.pending_invokes, 4_096);
        for dropped_id in dropped {
            let _ = guard.invoke_waiters.remove(&dropped_id);
        }
        (invoke_id, rx)
    }

    async fn cancel_invoke(&self, invoke_id: &str) {
        let normalized = invoke_id.trim();
        if normalized.is_empty() {
            return;
        }
        let mut guard = self.state.lock().await;
        let _ = guard.pending_invokes.remove(normalized);
        let _ = guard.invoke_waiters.remove(normalized);
    }

    async fn complete_invoke(&self, params: NodeInvokeResultParams) -> NodeInvokeCompleteResult {
        let mut guard = self.state.lock().await;
        let Some(pending) = guard.pending_invokes.remove(&params.id) else {
            let _ = guard.invoke_waiters.remove(&params.id);
            return NodeInvokeCompleteResult::Ignored;
        };
        if !pending.node_id.eq_ignore_ascii_case(&params.node_id) {
            guard.pending_invokes.insert(pending.id.clone(), pending);
            return NodeInvokeCompleteResult::NodeMismatch;
        }
        let payload_json = params.payload_json.or_else(|| {
            params
                .payload
                .as_ref()
                .and_then(|value| serde_json::to_string(value).ok())
        });
        let completion = NodeInvokeCompletion {
            ok: params.ok,
            payload: params.payload.clone(),
            payload_json: payload_json.clone(),
            error: params.error.clone(),
        };
        if let Some(waiter) = guard.invoke_waiters.remove(&params.id) {
            let _ = waiter.send(completion);
        }
        guard.recent_results.push_back(json!({
            "id": params.id,
            "nodeId": params.node_id,
            "ok": params.ok,
            "payloadJSON": payload_json,
            "errorCode": params.error.as_ref().and_then(|value| value.code.clone()),
            "errorMessage": params.error.as_ref().and_then(|value| value.message.clone()),
            "ts": now_ms(),
            "command": pending.command,
            "idempotencyKey": pending.idempotency_key,
            "invokeCreatedAtMs": pending.created_at_ms,
            "timeoutMs": pending.timeout_ms
        }));
        while guard.recent_results.len() > 1_024 {
            let _ = guard.recent_results.pop_front();
        }
        NodeInvokeCompleteResult::Completed
    }

    async fn record_event(&self, event: String, payload_json: Option<String>) {
        let mut guard = self.state.lock().await;
        guard.recent_events.push_back(json!({
            "event": event,
            "payloadJSON": payload_json,
            "ts": now_ms()
        }));
        while guard.recent_events.len() > 1_024 {
            let _ = guard.recent_events.pop_front();
        }
    }

    #[cfg(test)]
    async fn last_event(&self) -> Option<Value> {
        let guard = self.state.lock().await;
        guard.recent_events.back().cloned()
    }

    #[cfg(test)]
    async fn event_count(&self) -> usize {
        let guard = self.state.lock().await;
        guard.recent_events.len()
    }

    #[cfg(test)]
    async fn latest_pending_invoke_id(&self) -> Option<String> {
        let guard = self.state.lock().await;
        guard
            .pending_invokes
            .values()
            .max_by_key(|entry| (entry.created_at_ms, &entry.id))
            .map(|entry| entry.id.clone())
    }
}

struct ApnsRegistrationRegistry {
    state: Mutex<HashMap<String, ApnsRegistrationEntry>>,
}

#[derive(Debug, Clone)]
struct ApnsRegistrationEntry {
    node_id: String,
    token: String,
    topic: String,
    environment: String,
    updated_at_ms: u64,
}

impl ApnsRegistrationRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(HashMap::new()),
        }
    }

    async fn upsert(&self, registration: ApnsRegistrationEntry) {
        let mut guard = self.state.lock().await;
        guard.insert(normalize(&registration.node_id), registration);
        while guard.len() > 4_096 {
            let Some(oldest_key) = guard
                .iter()
                .min_by_key(|(_, entry)| entry.updated_at_ms)
                .map(|(key, _)| key.clone())
            else {
                break;
            };
            let _ = guard.remove(&oldest_key);
        }
    }

    async fn get(&self, node_id: &str) -> Option<ApnsRegistrationEntry> {
        let normalized = normalize(node_id);
        if normalized.is_empty() {
            return None;
        }
        let guard = self.state.lock().await;
        guard.get(&normalized).cloned()
    }

    #[cfg(test)]
    async fn count(&self) -> usize {
        let guard = self.state.lock().await;
        guard.len()
    }
}

#[derive(Debug, Clone, serde::Serialize)]
struct ApnsPushAlertResult {
    ok: bool,
    status: u16,
    #[serde(rename = "apnsId", skip_serializing_if = "Option::is_none")]
    apns_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    reason: Option<String>,
    #[serde(rename = "tokenSuffix")]
    token_suffix: String,
    topic: String,
    environment: String,
}

fn prune_oldest_node_invoke_pending(
    pending_invokes: &mut HashMap<String, NodeInvokePendingEntry>,
    max_pending: usize,
) -> Vec<String> {
    let mut dropped = Vec::new();
    while pending_invokes.len() > max_pending {
        let Some(oldest_key) = pending_invokes
            .iter()
            .min_by_key(|(_, entry)| entry.created_at_ms)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = pending_invokes.remove(&oldest_key);
        dropped.push(oldest_key);
    }
    dropped
}

fn next_node_invoke_id() -> String {
    let sequence = NODE_INVOKE_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("node-invoke-{}-{sequence}", now_ms())
}

fn next_browser_proxy_idempotency_key(node_id: &str) -> String {
    let sequence = BROWSER_PROXY_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    let normalized_node = normalize(node_id);
    format!("browser-proxy-{}-{}-{sequence}", now_ms(), normalized_node)
}

fn next_canvas_present_idempotency_key(node_id: &str) -> String {
    let sequence = CANVAS_PRESENT_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    let normalized_node = normalize(node_id);
    format!("canvas-present-{}-{}-{sequence}", now_ms(), normalized_node)
}

struct ExecApprovalsRegistry {
    state: Mutex<ExecApprovalsState>,
}

#[derive(Debug, Clone)]
struct ExecApprovalsState {
    global: ExecApprovalsSnapshotState,
    node_by_id: HashMap<String, ExecApprovalsSnapshotState>,
}

#[derive(Debug, Clone)]
struct ExecApprovalsSnapshotState {
    path: String,
    exists: bool,
    file: Value,
    hash: String,
    updated_at_ms: u64,
}

impl ExecApprovalsSnapshotState {
    fn default_global() -> Self {
        Self::new(
            EXEC_APPROVALS_GLOBAL_PATH.to_owned(),
            default_exec_approvals_file(),
            true,
        )
    }

    fn default_for_node(node_id: &str) -> Self {
        Self::new(
            format!("memory://nodes/{node_id}/exec-approvals.json"),
            default_exec_approvals_file(),
            true,
        )
    }

    fn new(path: String, file: Value, exists: bool) -> Self {
        Self {
            path,
            exists,
            hash: hash_json_value(&file),
            file,
            updated_at_ms: now_ms(),
        }
    }
}

impl ExecApprovalsRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(ExecApprovalsState {
                global: ExecApprovalsSnapshotState::default_global(),
                node_by_id: HashMap::new(),
            }),
        }
    }

    async fn get_global(&self) -> Value {
        let guard = self.state.lock().await;
        exec_approvals_snapshot_payload(&guard.global)
    }

    async fn set_global(&self, file: Value, base_hash: Option<String>) -> Result<Value, String> {
        let mut guard = self.state.lock().await;
        require_exec_approvals_base_hash(base_hash, &guard.global)?;
        let next_file = normalize_exec_approvals_file(file, Some(&guard.global.file));
        guard.global.file = next_file;
        guard.global.hash = hash_json_value(&guard.global.file);
        guard.global.exists = true;
        guard.global.updated_at_ms = now_ms();
        Ok(exec_approvals_snapshot_payload(&guard.global))
    }

    async fn get_node(&self, node_id: &str) -> Value {
        let mut guard = self.state.lock().await;
        let snapshot = guard
            .node_by_id
            .entry(node_id.to_owned())
            .or_insert_with(|| ExecApprovalsSnapshotState::default_for_node(node_id));
        snapshot.updated_at_ms = now_ms();
        let payload = exec_approvals_snapshot_payload(snapshot);
        prune_oldest_exec_approvals_nodes(&mut guard.node_by_id, MAX_EXEC_APPROVALS_NODE_SNAPSHOTS);
        payload
    }

    async fn set_node(
        &self,
        node_id: &str,
        file: Value,
        base_hash: Option<String>,
    ) -> Result<Value, String> {
        let mut guard = self.state.lock().await;
        let payload = {
            let snapshot = guard
                .node_by_id
                .entry(node_id.to_owned())
                .or_insert_with(|| ExecApprovalsSnapshotState::default_for_node(node_id));
            require_exec_approvals_base_hash(base_hash, snapshot)?;
            let next_file = normalize_exec_approvals_file(file, Some(&snapshot.file));
            snapshot.file = next_file;
            snapshot.hash = hash_json_value(&snapshot.file);
            snapshot.exists = true;
            snapshot.updated_at_ms = now_ms();
            exec_approvals_snapshot_payload(snapshot)
        };
        prune_oldest_exec_approvals_nodes(&mut guard.node_by_id, MAX_EXEC_APPROVALS_NODE_SNAPSHOTS);
        Ok(payload)
    }
}

fn exec_approvals_snapshot_payload(snapshot: &ExecApprovalsSnapshotState) -> Value {
    let mut file = snapshot.file.clone();
    if let Some(map) = file.as_object_mut() {
        let socket_path = map
            .get("socket")
            .and_then(Value::as_object)
            .and_then(|socket| socket.get("path"))
            .and_then(Value::as_str)
            .and_then(|value| normalize_optional_text(Some(value.to_owned()), 1_024));
        match socket_path {
            Some(path) => {
                map.insert("socket".to_owned(), json!({ "path": path }));
            }
            None => {
                map.remove("socket");
            }
        }
    }
    json!({
        "path": snapshot.path,
        "exists": snapshot.exists,
        "hash": snapshot.hash,
        "file": file
    })
}

fn require_exec_approvals_base_hash(
    base_hash: Option<String>,
    snapshot: &ExecApprovalsSnapshotState,
) -> Result<(), String> {
    if !snapshot.exists {
        return Ok(());
    }
    let Some(snapshot_hash) = normalize_optional_text(Some(snapshot.hash.clone()), 128) else {
        return Err(
            "exec approvals base hash unavailable; re-run exec.approvals.get and retry".to_owned(),
        );
    };
    let Some(base_hash) = normalize_optional_text(base_hash, 128) else {
        return Err(
            "exec approvals base hash required; re-run exec.approvals.get and retry".to_owned(),
        );
    };
    if !base_hash.eq_ignore_ascii_case(&snapshot_hash) {
        return Err(
            "exec approvals changed since last load; re-run exec.approvals.get and retry"
                .to_owned(),
        );
    }
    Ok(())
}

fn normalize_exec_approvals_file(incoming: Value, current: Option<&Value>) -> Value {
    let mut normalized = if incoming.is_object() {
        incoming
    } else {
        json!({})
    };

    let current_socket = current
        .and_then(|value| value.get("socket"))
        .and_then(Value::as_object);
    let current_socket_path = current_socket
        .and_then(|socket| socket.get("path"))
        .and_then(Value::as_str)
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 1_024));
    let current_token = current_socket
        .and_then(|socket| socket.get("token"))
        .and_then(Value::as_str)
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 512));

    let Some(map) = normalized.as_object_mut() else {
        return default_exec_approvals_file();
    };
    map.insert("version".to_owned(), json!(1));
    if !matches!(map.get("agents"), Some(Value::Object(_))) {
        map.insert("agents".to_owned(), json!({}));
    }

    let incoming_socket = map.get("socket").and_then(Value::as_object);
    let socket_path = incoming_socket
        .and_then(|socket| socket.get("path"))
        .and_then(Value::as_str)
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 1_024))
        .or(current_socket_path)
        .unwrap_or_else(|| EXEC_APPROVALS_SOCKET_PATH.to_owned());
    let token = incoming_socket
        .and_then(|socket| socket.get("token"))
        .and_then(Value::as_str)
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 512))
        .or(current_token)
        .unwrap_or_else(next_exec_approvals_token);
    map.insert(
        "socket".to_owned(),
        json!({
            "path": socket_path,
            "token": token
        }),
    );

    normalized
}

fn default_exec_approvals_file() -> Value {
    json!({
        "version": 1,
        "socket": {
            "path": EXEC_APPROVALS_SOCKET_PATH,
            "token": next_exec_approvals_token()
        },
        "agents": {}
    })
}

fn next_exec_approvals_token() -> String {
    use sha2::{Digest, Sha256};
    let sequence = EXEC_APPROVAL_TOKEN_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    let mut hasher = Sha256::new();
    hasher.update(now_ms().to_le_bytes());
    hasher.update(sequence.to_le_bytes());
    let digest = format!("{:x}", hasher.finalize());
    format!("eat_{}", &digest[..48])
}

fn prune_oldest_exec_approvals_nodes(
    node_by_id: &mut HashMap<String, ExecApprovalsSnapshotState>,
    max_snapshots: usize,
) {
    while node_by_id.len() > max_snapshots {
        let Some(oldest_key) = node_by_id
            .iter()
            .min_by_key(|(_, snapshot)| snapshot.updated_at_ms)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = node_by_id.remove(&oldest_key);
    }
}

struct ExecApprovalRegistry {
    state: Arc<Mutex<ExecApprovalState>>,
}

#[derive(Default)]
struct ExecApprovalState {
    pending_by_id: HashMap<String, ExecApprovalPendingEntry>,
}

struct ExecApprovalPendingEntry {
    created_at_ms: u64,
    expires_at_ms: u64,
    decision: Option<String>,
    resolved_at_ms: Option<u64>,
    waiters: Vec<oneshot::Sender<Option<String>>>,
}

struct ExecApprovalCreateResult {
    id: String,
    created_at_ms: u64,
    expires_at_ms: u64,
    receiver: oneshot::Receiver<Option<String>>,
}

enum ExecApprovalWaitOutcome {
    Missing,
    Ready {
        decision: Option<String>,
        created_at_ms: u64,
        expires_at_ms: u64,
    },
    Pending {
        receiver: oneshot::Receiver<Option<String>>,
        created_at_ms: u64,
        expires_at_ms: u64,
    },
}

impl ExecApprovalRegistry {
    fn new() -> Self {
        Self {
            state: Arc::new(Mutex::new(ExecApprovalState::default())),
        }
    }

    async fn create(
        &self,
        timeout_ms: u64,
        explicit_id: Option<String>,
    ) -> Result<ExecApprovalCreateResult, String> {
        let timeout_ms = timeout_ms.max(1);
        let id = explicit_id.unwrap_or_else(next_exec_approval_id);
        let now = now_ms();
        let expires_at_ms = now.saturating_add(timeout_ms);
        let (sender, receiver) = oneshot::channel();

        {
            let mut guard = self.state.lock().await;
            if guard.pending_by_id.contains_key(&id) {
                return Err("approval id already pending".to_owned());
            }
            guard.pending_by_id.insert(
                id.clone(),
                ExecApprovalPendingEntry {
                    created_at_ms: now,
                    expires_at_ms,
                    decision: None,
                    resolved_at_ms: None,
                    waiters: vec![sender],
                },
            );
            prune_oldest_exec_approval_pending(&mut guard.pending_by_id, MAX_EXEC_APPROVAL_PENDING);
        }

        let state = Arc::clone(&self.state);
        let timeout_id = id.clone();
        tokio::spawn(async move {
            tokio::time::sleep(Duration::from_millis(timeout_ms)).await;
            let (waiters, resolved_at_ms) = {
                let mut guard = state.lock().await;
                let Some(entry) = guard.pending_by_id.get_mut(&timeout_id) else {
                    return;
                };
                if entry.resolved_at_ms.is_some() {
                    return;
                }
                let resolved_at_ms = now_ms();
                entry.resolved_at_ms = Some(resolved_at_ms);
                entry.decision = None;
                (std::mem::take(&mut entry.waiters), resolved_at_ms)
            };
            for waiter in waiters {
                let _ = waiter.send(None);
            }
            spawn_exec_approval_grace_cleanup(state, timeout_id, resolved_at_ms);
        });

        Ok(ExecApprovalCreateResult {
            id,
            created_at_ms: now,
            expires_at_ms,
            receiver,
        })
    }

    async fn wait_decision(&self, id: &str) -> ExecApprovalWaitOutcome {
        let mut guard = self.state.lock().await;
        let Some(entry) = guard.pending_by_id.get_mut(id) else {
            return ExecApprovalWaitOutcome::Missing;
        };
        if entry.resolved_at_ms.is_some() {
            return ExecApprovalWaitOutcome::Ready {
                decision: entry.decision.clone(),
                created_at_ms: entry.created_at_ms,
                expires_at_ms: entry.expires_at_ms,
            };
        }
        let (sender, receiver) = oneshot::channel();
        entry.waiters.push(sender);
        ExecApprovalWaitOutcome::Pending {
            receiver,
            created_at_ms: entry.created_at_ms,
            expires_at_ms: entry.expires_at_ms,
        }
    }

    async fn resolve(&self, id: &str, decision: String) -> bool {
        let (waiters, resolved_at_ms) = {
            let mut guard = self.state.lock().await;
            let Some(entry) = guard.pending_by_id.get_mut(id) else {
                return false;
            };
            if entry.resolved_at_ms.is_some() {
                return false;
            }
            let resolved_at_ms = now_ms();
            entry.decision = Some(decision.clone());
            entry.resolved_at_ms = Some(resolved_at_ms);
            (std::mem::take(&mut entry.waiters), resolved_at_ms)
        };

        for waiter in waiters {
            let _ = waiter.send(Some(decision.clone()));
        }
        spawn_exec_approval_grace_cleanup(Arc::clone(&self.state), id.to_owned(), resolved_at_ms);
        true
    }
}

fn spawn_exec_approval_grace_cleanup(
    state: Arc<Mutex<ExecApprovalState>>,
    id: String,
    resolved_at_ms: u64,
) {
    tokio::spawn(async move {
        tokio::time::sleep(Duration::from_millis(EXEC_APPROVAL_RESOLVED_GRACE_MS)).await;
        let mut guard = state.lock().await;
        let should_remove = guard
            .pending_by_id
            .get(&id)
            .and_then(|entry| entry.resolved_at_ms)
            .map(|entry_resolved_at_ms| entry_resolved_at_ms == resolved_at_ms)
            .unwrap_or(false);
        if should_remove {
            let _ = guard.pending_by_id.remove(&id);
        }
    });
}

fn prune_oldest_exec_approval_pending(
    pending_by_id: &mut HashMap<String, ExecApprovalPendingEntry>,
    max_pending: usize,
) {
    while pending_by_id.len() > max_pending {
        let Some(oldest_key) = pending_by_id
            .iter()
            .min_by_key(|(_, entry)| (entry.resolved_at_ms.is_none(), entry.created_at_ms))
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let Some(removed) = pending_by_id.remove(&oldest_key) else {
            continue;
        };
        for waiter in removed.waiters {
            let _ = waiter.send(None);
        }
    }
}

fn next_exec_approval_id() -> String {
    let sequence = EXEC_APPROVAL_ID_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("approval-{}-{sequence}", now_ms())
}

fn next_chat_inject_message_id() -> String {
    let sequence = CHAT_INJECT_ID_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("msg-{}-{sequence}", now_ms())
}

fn next_send_message_id() -> String {
    let sequence = SEND_MESSAGE_ID_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("send-{}-{sequence}", now_ms())
}

fn next_poll_id() -> String {
    let sequence = POLL_ID_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("poll-{}-{sequence}", now_ms())
}

fn next_tts_audio_path(extension: &str) -> String {
    let sequence = TTS_AUDIO_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("memory://tts/audio-{}-{sequence}{extension}", now_ms())
}

struct TtsAudioBlob {
    bytes: Vec<u8>,
    duration_ms: u64,
    sample_rate_hz: u32,
    provider_used: String,
    source: &'static str,
}

async fn synthesize_tts_audio_blob_with_provider(
    text: &str,
    output_format: &str,
    preferred_provider: &str,
    profile: RuntimeFeatureProfile,
) -> TtsAudioBlob {
    for provider in tts_provider_order(preferred_provider, profile) {
        if provider == "kittentts" {
            if let Some(blob) = try_synthesize_tts_audio_blob_kittentts(text, output_format).await {
                return blob;
            }
            continue;
        }
        if let Some(api_key) = tts_provider_api_key(provider) {
            if let Some(blob) =
                try_synthesize_tts_audio_blob_remote(provider, &api_key, text, output_format).await
            {
                return blob;
            }
        }
    }
    let normalized = normalize(preferred_provider);
    let (bytes, duration_ms, sample_rate_hz) =
        synthesize_tts_audio_blob_simulated(text, output_format);
    TtsAudioBlob {
        bytes,
        duration_ms,
        sample_rate_hz,
        provider_used: if normalized.is_empty() {
            "edge".to_owned()
        } else {
            normalized
        },
        source: "simulated",
    }
}

fn kittentts_binary_path() -> Option<String> {
    env::var(TTS_KITTENTTS_BIN_ENV)
        .ok()
        .and_then(|value| normalize_optional_text(Some(value), 2_048))
}

fn kittentts_binary_available() -> bool {
    kittentts_binary_path().is_some()
}

fn kittentts_extra_args() -> Vec<String> {
    env::var(TTS_KITTENTTS_ARGS_ENV)
        .ok()
        .and_then(|value| normalize_optional_text(Some(value), 2_048))
        .map(|value| {
            value
                .split_whitespace()
                .take(32)
                .map(|item| item.to_owned())
                .collect::<Vec<_>>()
        })
        .unwrap_or_default()
}

fn tts_provider_api_key(provider: &str) -> Option<String> {
    match normalize(provider).as_str() {
        "openai" => env::var(TTS_OPENAI_API_KEY_ENV).ok(),
        "elevenlabs" => env::var(TTS_ELEVENLABS_API_KEY_ENV).ok(),
        _ => None,
    }
    .map(|value| value.trim().to_owned())
    .filter(|value| !value.is_empty())
}

async fn try_synthesize_tts_audio_blob_kittentts(
    text: &str,
    output_format: &str,
) -> Option<TtsAudioBlob> {
    let binary = kittentts_binary_path()?;
    let mut command = TokioCommand::new(binary);
    command
        .arg("--format")
        .arg(if output_format.eq_ignore_ascii_case("opus") {
            "opus"
        } else {
            "mp3"
        });
    for arg in kittentts_extra_args() {
        command.arg(arg);
    }
    command
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    let mut child = command.spawn().ok()?;
    if let Some(mut stdin) = child.stdin.take() {
        if stdin.write_all(text.as_bytes()).await.is_err() {
            return None;
        }
    }
    let output = child.wait_with_output().await.ok()?;
    if !output.status.success() || output.stdout.is_empty() {
        return None;
    }
    let duration_ms = estimate_tts_duration_ms(text, output.stdout.len());
    Some(TtsAudioBlob {
        bytes: output.stdout,
        duration_ms,
        sample_rate_hz: 24_000,
        provider_used: "kittentts".to_owned(),
        source: "offline-local",
    })
}

async fn try_synthesize_tts_audio_blob_remote(
    provider: &str,
    api_key: &str,
    text: &str,
    output_format: &str,
) -> Option<TtsAudioBlob> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(TTS_PROVIDER_HTTP_TIMEOUT_SECS))
        .build()
        .ok()?;
    let provider = normalize(provider);
    match provider.as_str() {
        "openai" => {
            let format = if output_format.eq_ignore_ascii_case("opus") {
                "opus"
            } else {
                "mp3"
            };
            let response = client
                .post("https://api.openai.com/v1/audio/speech")
                .bearer_auth(api_key)
                .json(&json!({
                    "model": TTS_OPENAI_DEFAULT_MODEL,
                    "voice": TTS_OPENAI_DEFAULT_VOICE,
                    "input": text,
                    "format": format
                }))
                .send()
                .await
                .ok()?;
            if !response.status().is_success() {
                return None;
            }
            let bytes = response.bytes().await.ok()?.to_vec();
            if bytes.is_empty() {
                return None;
            }
            let duration_ms = estimate_tts_duration_ms(text, bytes.len());
            Some(TtsAudioBlob {
                bytes,
                duration_ms,
                sample_rate_hz: 24_000,
                provider_used: "openai".to_owned(),
                source: "remote",
            })
        }
        "elevenlabs" => {
            let voice_id = env::var(TTS_ELEVENLABS_VOICE_ID_ENV)
                .ok()
                .and_then(|value| {
                    let trimmed = value.trim();
                    if trimmed.is_empty() {
                        None
                    } else {
                        Some(trimmed.to_owned())
                    }
                })
                .unwrap_or_else(|| TTS_ELEVENLABS_DEFAULT_VOICE_ID.to_owned());
            let response = client
                .post(format!(
                    "https://api.elevenlabs.io/v1/text-to-speech/{voice_id}"
                ))
                .header("xi-api-key", api_key)
                .header("Accept", "audio/mpeg")
                .json(&json!({
                    "text": text,
                    "model_id": TTS_ELEVENLABS_DEFAULT_MODEL,
                    "output_format": "mp3_44100_128"
                }))
                .send()
                .await
                .ok()?;
            if !response.status().is_success() {
                return None;
            }
            let bytes = response.bytes().await.ok()?.to_vec();
            if bytes.is_empty() {
                return None;
            }
            let duration_ms = estimate_tts_duration_ms(text, bytes.len());
            Some(TtsAudioBlob {
                bytes,
                duration_ms,
                sample_rate_hz: 44_100,
                provider_used: "elevenlabs".to_owned(),
                source: "remote",
            })
        }
        _ => None,
    }
}

fn estimate_tts_duration_ms(text: &str, bytes: usize) -> u64 {
    let chars = text.chars().count() as u64;
    let bytes_bias = (bytes as u64 / 16).clamp(0, 8_000);
    (chars * 40 + bytes_bias).clamp(350, 30_000)
}

fn synthesize_tts_audio_blob_simulated(text: &str, output_format: &str) -> (Vec<u8>, u64, u32) {
    use sha2::{Digest, Sha256};

    let sample_rate_hz = 24_000_u32;
    let duration_ms = ((text.chars().count() as u64) * 45).clamp(400, 15_000);
    let frame_count = ((duration_ms * sample_rate_hz as u64) / 1_000).max(128) as usize;
    let mut bytes = Vec::with_capacity(frame_count.min(4_096) + 16);
    let header = if output_format.eq_ignore_ascii_case("opus") {
        b"OPUSSIM\0"
    } else {
        b"MP3SIM\0\0"
    };
    bytes.extend_from_slice(header);

    let mut hasher = Sha256::new();
    hasher.update(text.as_bytes());
    hasher.update(output_format.as_bytes());
    let digest = hasher.finalize();
    while bytes.len() < frame_count.min(4_096) + header.len() {
        bytes.extend_from_slice(&digest);
    }
    bytes.truncate(frame_count.min(4_096) + header.len());
    (bytes, duration_ms, sample_rate_hz)
}

fn is_supported_tts_provider(provider: &str) -> bool {
    matches!(provider, "openai" | "elevenlabs" | "kittentts" | "edge")
}

fn tts_provider_order(primary: &str, profile: RuntimeFeatureProfile) -> Vec<&'static str> {
    let normalized = normalize(primary);
    let mut order = match profile {
        RuntimeFeatureProfile::Core => vec!["openai", "elevenlabs", "edge"],
        RuntimeFeatureProfile::Edge => vec!["openai", "elevenlabs", "kittentts", "edge"],
    };
    if normalized == "kittentts" && !order.contains(&"kittentts") {
        order.push("kittentts");
    }
    if let Some(index) = order.iter().position(|candidate| *candidate == normalized) {
        order.swap(0, index);
    }
    order
}

fn tts_fallback_providers(primary: &str, profile: RuntimeFeatureProfile) -> Vec<String> {
    tts_provider_order(primary, profile)
        .into_iter()
        .skip(1)
        .map(str::to_owned)
        .collect()
}

fn normalize_voicewake_triggers(values: &[Value]) -> Vec<String> {
    let mut cleaned = Vec::new();
    for value in values {
        let Some(trigger) = value.as_str() else {
            continue;
        };
        let trimmed = trigger.trim();
        if trimmed.is_empty() {
            continue;
        }
        let normalized = trimmed.chars().take(64).collect::<String>();
        if normalized.is_empty() {
            continue;
        }
        cleaned.push(normalized);
        if cleaned.len() >= 32 {
            break;
        }
    }
    if cleaned.is_empty() {
        return DEFAULT_VOICEWAKE_TRIGGERS
            .iter()
            .map(|value| (*value).to_owned())
            .collect();
    }
    cleaned
}

fn derive_outbound_session_key(channel: &str, to: &str) -> String {
    let channel_key = normalize(channel);
    let target_key = normalize_outbound_target_segment(to);
    format!("agent:main:{channel_key}:out:{target_key}")
}

fn normalize_outbound_target_segment(target: &str) -> String {
    let mut normalized = String::new();
    let mut last_was_dash = false;
    for ch in target.trim().to_ascii_lowercase().chars() {
        if ch.is_ascii_alphanumeric() || matches!(ch, ':' | '_' | '+' | '-') {
            normalized.push(ch);
            last_was_dash = false;
            continue;
        }
        if !last_was_dash {
            normalized.push('-');
            last_was_dash = true;
        }
    }
    while normalized.ends_with('-') {
        normalized.pop();
    }
    if normalized.is_empty() {
        return "target".to_owned();
    }
    if normalized.len() > 96 {
        normalized.truncate(96);
    }
    normalized
}

#[derive(Debug, Clone, Default)]
struct DeliveryContextHints {
    channel: Option<String>,
    to: Option<String>,
    account_id: Option<String>,
    thread_id: Option<String>,
}

impl DeliveryContextHints {
    fn is_empty(&self) -> bool {
        self.channel.is_none()
            && self.to.is_none()
            && self.account_id.is_none()
            && self.thread_id.is_none()
    }
}

fn extract_delivery_context_hints(raw: &Value) -> DeliveryContextHints {
    const CHANNEL_KEYS: &[&str] = &[
        "channel",
        "channelName",
        "channel_name",
        "platform",
        "provider",
    ];
    const TO_KEYS: &[&str] = &["to", "recipient", "target", "peer", "chatId", "chat_id"];
    const ACCOUNT_KEYS: &[&str] = &[
        "accountId",
        "account_id",
        "fromAccountId",
        "from_account_id",
        "channelAccountId",
        "channel_account_id",
        "defaultAccountId",
        "default_account_id",
    ];
    const THREAD_KEYS: &[&str] = &["threadId", "thread_id", "topicId", "topic_id"];
    let channel = find_delivery_hint_string(raw, CHANNEL_KEYS)
        .and_then(|value| normalize_channel_id(Some(&value)).or_else(|| Some(normalize(&value))));
    let to = find_delivery_hint_string(raw, TO_KEYS)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty());
    let account_id = find_delivery_hint_string(raw, ACCOUNT_KEYS)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty());
    let thread_id = find_delivery_hint_string(raw, THREAD_KEYS)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty());
    DeliveryContextHints {
        channel,
        to,
        account_id,
        thread_id,
    }
}

fn find_delivery_hint_string(root: &Value, keys: &[&str]) -> Option<String> {
    match root {
        Value::Object(map) => {
            for key in keys {
                if let Some(value) = map.get(*key) {
                    match value {
                        Value::String(text) => {
                            let trimmed = text.trim();
                            if !trimmed.is_empty() {
                                return Some(trimmed.to_owned());
                            }
                        }
                        Value::Number(number) => return Some(number.to_string()),
                        Value::Bool(boolean) => return Some(boolean.to_string()),
                        _ => {}
                    }
                }
            }
            map.values()
                .find_map(|value| find_delivery_hint_string(value, keys))
        }
        Value::Array(items) => items
            .iter()
            .find_map(|value| find_delivery_hint_string(value, keys)),
        _ => None,
    }
}

struct ChatRegistry {
    state: Arc<Mutex<ChatState>>,
}

#[derive(Default)]
struct ChatState {
    runs_by_id: HashMap<String, ChatRunEntry>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ChatRunStatus {
    InFlight,
    Completed,
    Aborted,
}

#[derive(Debug, Clone)]
struct ChatRunEntry {
    session_key: String,
    status: ChatRunStatus,
    started_at_ms: u64,
    updated_at_ms: u64,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ChatRunStartOutcome {
    Started,
    InFlight,
    Completed,
    Aborted,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ChatAbortRunOutcome {
    NotFound,
    SessionMismatch,
    Aborted,
}

impl ChatRegistry {
    fn new() -> Self {
        Self {
            state: Arc::new(Mutex::new(ChatState::default())),
        }
    }

    async fn start_run(
        &self,
        session_key: &str,
        run_id: &str,
        timeout_ms: u64,
    ) -> ChatRunStartOutcome {
        let mut guard = self.state.lock().await;
        if let Some(existing) = guard.runs_by_id.get(run_id) {
            return match existing.status {
                ChatRunStatus::InFlight => ChatRunStartOutcome::InFlight,
                ChatRunStatus::Completed => ChatRunStartOutcome::Completed,
                ChatRunStatus::Aborted => ChatRunStartOutcome::Aborted,
            };
        }
        let now = now_ms();
        guard.runs_by_id.insert(
            run_id.to_owned(),
            ChatRunEntry {
                session_key: session_key.to_owned(),
                status: ChatRunStatus::InFlight,
                started_at_ms: now,
                updated_at_ms: now,
            },
        );
        prune_oldest_chat_runs(&mut guard.runs_by_id, MAX_CHAT_RUNS);
        drop(guard);

        let state = Arc::clone(&self.state);
        let complete_run_id = run_id.to_owned();
        let delay_ms = CHAT_RUN_COMPLETE_DELAY_MS.min(timeout_ms.max(1));
        tokio::spawn(async move {
            tokio::time::sleep(Duration::from_millis(delay_ms)).await;
            let mut guard = state.lock().await;
            let Some(entry) = guard.runs_by_id.get_mut(&complete_run_id) else {
                return;
            };
            if entry.status == ChatRunStatus::InFlight {
                entry.status = ChatRunStatus::Completed;
                entry.updated_at_ms = now_ms();
            }
        });

        ChatRunStartOutcome::Started
    }

    async fn abort_run(&self, session_key: &str, run_id: &str) -> ChatAbortRunOutcome {
        let mut guard = self.state.lock().await;
        let Some(entry) = guard.runs_by_id.get_mut(run_id) else {
            return ChatAbortRunOutcome::NotFound;
        };
        if !entry.session_key.eq_ignore_ascii_case(session_key) {
            return ChatAbortRunOutcome::SessionMismatch;
        }
        if entry.status != ChatRunStatus::InFlight {
            return ChatAbortRunOutcome::NotFound;
        }
        entry.status = ChatRunStatus::Aborted;
        entry.updated_at_ms = now_ms();
        ChatAbortRunOutcome::Aborted
    }

    async fn abort_session(&self, session_key: &str) -> Vec<String> {
        let mut guard = self.state.lock().await;
        let mut aborted = Vec::new();
        for (run_id, entry) in &mut guard.runs_by_id {
            if !entry.session_key.eq_ignore_ascii_case(session_key) {
                continue;
            }
            if entry.status != ChatRunStatus::InFlight {
                continue;
            }
            entry.status = ChatRunStatus::Aborted;
            entry.updated_at_ms = now_ms();
            aborted.push(run_id.clone());
        }
        aborted.sort();
        aborted
    }
}

fn prune_oldest_chat_runs(runs_by_id: &mut HashMap<String, ChatRunEntry>, max_runs: usize) {
    while runs_by_id.len() > max_runs {
        let Some(oldest_key) = runs_by_id
            .iter()
            .min_by_key(|(_, entry)| (entry.status == ChatRunStatus::InFlight, entry.started_at_ms))
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = runs_by_id.remove(&oldest_key);
    }
}

struct SendRegistry {
    state: Mutex<SendState>,
}

#[derive(Debug, Clone)]
enum SendRegistryError {
    Invalid(String),
}

struct SendState {
    store_path: String,
    ttl_ms: u64,
    max_entries: usize,
    cached_by_id: HashMap<String, SendCacheEntry>,
}

#[derive(Debug, Clone)]
struct SendCacheEntry {
    payload: Value,
    created_at_ms: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(default)]
struct SendStoreDiskState {
    version: u32,
    #[serde(rename = "ttlMs")]
    ttl_ms: u64,
    #[serde(rename = "maxEntries")]
    max_entries: usize,
    entries: Vec<SendStoreDiskEntry>,
}

impl Default for SendStoreDiskState {
    fn default() -> Self {
        Self {
            version: 1,
            ttl_ms: DEFAULT_SEND_CACHE_TTL_MS,
            max_entries: MAX_SEND_CACHE_ENTRIES,
            entries: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct SendStoreDiskEntry {
    #[serde(rename = "idempotencyKey")]
    idempotency_key: String,
    payload: Value,
    #[serde(rename = "createdAtMs")]
    created_at_ms: u64,
}

impl SendRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(SendState {
                store_path: SEND_CACHE_STORE_PATH.to_owned(),
                ttl_ms: DEFAULT_SEND_CACHE_TTL_MS,
                max_entries: MAX_SEND_CACHE_ENTRIES,
                cached_by_id: HashMap::new(),
            }),
        }
    }

    async fn apply_runtime_config(
        &self,
        runtime: SendRuntimeConfig,
    ) -> Result<(), SendRegistryError> {
        let mut guard = self.state.lock().await;
        let mut changed = false;
        if let Some(path) = runtime.store_path {
            if guard.store_path != path {
                let loaded = load_send_store_disk_state(&path)?;
                guard.store_path = path;
                guard.cached_by_id = loaded
                    .entries
                    .into_iter()
                    .filter_map(|entry| {
                        let key = normalize_optional_text(Some(entry.idempotency_key), 256)?;
                        Some((
                            key,
                            SendCacheEntry {
                                payload: entry.payload,
                                created_at_ms: entry.created_at_ms,
                            },
                        ))
                    })
                    .collect::<HashMap<_, _>>();
                if runtime.ttl_ms.is_none() {
                    guard.ttl_ms = loaded.ttl_ms.max(1_000);
                }
                if runtime.max_entries.is_none() {
                    guard.max_entries = loaded.max_entries.max(32);
                }
                changed = true;
            }
        }
        if let Some(ttl_ms) = runtime.ttl_ms {
            let ttl_ms = ttl_ms.max(1_000);
            if guard.ttl_ms != ttl_ms {
                guard.ttl_ms = ttl_ms;
                changed = true;
            }
        }
        if let Some(max_entries) = runtime.max_entries {
            let max_entries = max_entries.max(32);
            if guard.max_entries != max_entries {
                guard.max_entries = max_entries;
                changed = true;
            }
        }
        let before_len = guard.cached_by_id.len();
        prune_send_cache_for_limits(&mut guard, now_ms());
        if guard.cached_by_id.len() != before_len {
            changed = true;
        }
        if changed {
            persist_send_store_disk_state(&guard)?;
        }
        Ok(())
    }

    async fn get(&self, idempotency_key: &str) -> Option<Value> {
        let mut guard = self.state.lock().await;
        prune_send_cache_for_limits(&mut guard, now_ms());
        guard
            .cached_by_id
            .get(idempotency_key)
            .map(|entry| entry.payload.clone())
    }

    async fn set(&self, idempotency_key: String, payload: Value) -> Result<(), SendRegistryError> {
        let mut guard = self.state.lock().await;
        guard.cached_by_id.insert(
            idempotency_key,
            SendCacheEntry {
                payload,
                created_at_ms: now_ms(),
            },
        );
        prune_send_cache_for_limits(&mut guard, now_ms());
        persist_send_store_disk_state(&guard)
    }
}

fn prune_oldest_send_cache(cached_by_id: &mut HashMap<String, SendCacheEntry>, max_entries: usize) {
    while cached_by_id.len() > max_entries {
        let Some(oldest_key) = cached_by_id
            .iter()
            .min_by_key(|(_, entry)| entry.created_at_ms)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = cached_by_id.remove(&oldest_key);
    }
}

fn prune_send_cache_for_limits(state: &mut SendState, now: u64) {
    state
        .cached_by_id
        .retain(|_, entry| now.saturating_sub(entry.created_at_ms) <= state.ttl_ms);
    prune_oldest_send_cache(&mut state.cached_by_id, state.max_entries);
}

struct ChannelRuntimeRegistry {
    state: Mutex<ChannelRuntimeState>,
    runtime: Mutex<ChannelRuntimeRuntimeState>,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
struct ChannelRuntimeState {
    by_channel: HashMap<String, HashMap<String, ChannelAccountRuntime>>,
    default_account_by_channel: HashMap<String, String>,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
struct ChannelAccountRuntime {
    name: Option<String>,
    enabled: Option<bool>,
    configured: Option<bool>,
    linked: Option<bool>,
    running: Option<bool>,
    connected: Option<bool>,
    reconnect_attempts: Option<u64>,
    last_connected_at: Option<u64>,
    last_error: Option<String>,
    last_start_at: Option<u64>,
    last_stop_at: Option<u64>,
    last_inbound_at: Option<u64>,
    last_outbound_at: Option<u64>,
    last_reaction_at: Option<u64>,
    last_edit_at: Option<u64>,
    last_delete_at: Option<u64>,
    last_thread_at: Option<u64>,
    last_probe_at: Option<u64>,
    mode: Option<String>,
    dm_policy: Option<String>,
    allow_from: Option<Vec<String>>,
    token_source: Option<String>,
    bot_token_source: Option<String>,
    app_token_source: Option<String>,
    base_url: Option<String>,
    allow_unmentioned_groups: Option<bool>,
    cli_path: Option<Value>,
    db_path: Option<Value>,
    port: Option<u64>,
    probe: Option<Value>,
    audit: Option<Value>,
    application: Option<Value>,
}

#[derive(Debug, Clone)]
struct ChannelRuntimeRuntimeState {
    store_path: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct ChannelRuntimeStoreDiskState {
    version: u32,
    state: ChannelRuntimeState,
}

impl Default for ChannelRuntimeStoreDiskState {
    fn default() -> Self {
        Self {
            version: 1,
            state: ChannelRuntimeState::default(),
        }
    }
}

impl ChannelRuntimeRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(ChannelRuntimeState::default()),
            runtime: Mutex::new(ChannelRuntimeRuntimeState {
                store_path: CHANNEL_RUNTIME_STORE_PATH.to_owned(),
            }),
        }
    }

    async fn apply_runtime_config(&self, runtime: ChannelRuntimeConfig) -> Result<(), String> {
        let target_store_path = runtime
            .store_path
            .and_then(|value| normalize_optional_text(Some(value), 2048))
            .unwrap_or_else(|| CHANNEL_RUNTIME_STORE_PATH.to_owned());

        let current_store_path = { self.runtime.lock().await.store_path.clone() };
        if current_store_path == target_store_path {
            return Ok(());
        }

        let loaded = load_channel_runtime_store_disk_state(&target_store_path)?;
        let normalized_state = normalize_channel_runtime_state(loaded.state);

        {
            let mut guard = self.state.lock().await;
            *guard = normalized_state.clone();
        }
        {
            let mut runtime_guard = self.runtime.lock().await;
            runtime_guard.store_path = target_store_path.clone();
        }
        persist_channel_runtime_store_disk_state(&target_store_path, &normalized_state)?;
        Ok(())
    }

    async fn persist_state_snapshot(&self, state: ChannelRuntimeState) -> Result<(), String> {
        let store_path = { self.runtime.lock().await.store_path.clone() };
        persist_channel_runtime_store_disk_state(&store_path, &state)
    }

    async fn accounts_for_channel(&self, channel: &str) -> Vec<(String, ChannelAccountRuntime)> {
        let normalized_channel = canonicalize_runtime_channel_id(channel);
        let guard = self.state.lock().await;
        let Some(accounts) = guard.by_channel.get(&normalized_channel) else {
            return Vec::new();
        };
        let mut entries = accounts
            .iter()
            .map(|(account_id, runtime)| (account_id.clone(), runtime.clone()))
            .collect::<Vec<_>>();
        entries.sort_by(|(left, _), (right, _)| left.cmp(right));
        entries
    }

    async fn default_account_for_channel(&self, channel: &str) -> Option<String> {
        let normalized_channel = canonicalize_runtime_channel_id(channel);
        let guard = self.state.lock().await;
        guard
            .default_account_by_channel
            .get(&normalized_channel)
            .cloned()
    }

    async fn mark_outbound(&self, channel: &str, account_id: &str, ts: u64) {
        let mut guard = self.state.lock().await;
        let account = guard.account_mut(channel, account_id);
        account.last_outbound_at = Some(ts);
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
    }

    async fn mark_logout(&self, channel: &str, account_id: &str, ts: u64) -> bool {
        let mut guard = self.state.lock().await;
        let channel_id = canonicalize_runtime_channel_id(channel);
        let account_id = normalize_account_id(account_id);
        let Some(accounts) = guard.by_channel.get_mut(&channel_id) else {
            return false;
        };
        let resolved_account_id = if accounts.contains_key(&account_id) {
            account_id
        } else if let Some(existing) = accounts
            .keys()
            .find(|candidate| candidate.eq_ignore_ascii_case(&account_id))
            .cloned()
        {
            existing
        } else {
            return false;
        };
        let Some(account) = accounts.get_mut(&resolved_account_id) else {
            return false;
        };
        let was_active = account.running.unwrap_or(false) || account.connected.unwrap_or(false);
        account.connected = Some(false);
        account.running = Some(false);
        account.last_stop_at = Some(ts);
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
        was_active
    }

    async fn ingest_event(
        &self,
        event: &str,
        payload: &Value,
        channel_capabilities: &[ChannelCapabilities],
    ) {
        let known_channels = channel_capabilities
            .iter()
            .map(|capability| capability.name)
            .collect::<Vec<_>>();
        let inferred_channel = infer_channel_from_event(event, &known_channels);
        let inferred_payload_channel = infer_channel_from_payload(payload);
        let lifecycle_event = classify_channel_lifecycle_event(event);
        let mut guard = self.state.lock().await;

        if let Some(lifecycle_event) = lifecycle_event {
            if let Some(channel) = inferred_channel
                .as_deref()
                .or(inferred_payload_channel.as_deref())
            {
                let account_id =
                    infer_runtime_account_id(payload).unwrap_or_else(|| "default".to_owned());
                apply_channel_lifecycle_event(
                    &mut guard,
                    channel,
                    account_id.as_str(),
                    lifecycle_event,
                    payload,
                );
                guard.set_default_account(channel, account_id.as_str());
            }
        }

        if let Some(activity_event) = classify_channel_activity_event(event) {
            if let Some(channel) = inferred_channel
                .as_deref()
                .or(inferred_payload_channel.as_deref())
            {
                let account_id =
                    infer_runtime_account_id(payload).unwrap_or_else(|| "default".to_owned());
                let account = guard.account_mut(channel, account_id.as_str());
                let ts = now_ms();
                match activity_event {
                    ChannelActivityEvent::Inbound => {
                        account.last_inbound_at = Some(ts);
                    }
                    ChannelActivityEvent::Outbound => {
                        account.last_outbound_at = Some(ts);
                    }
                    ChannelActivityEvent::Reaction => {
                        account.last_reaction_at = Some(ts);
                    }
                    ChannelActivityEvent::Edit => {
                        account.last_edit_at = Some(ts);
                    }
                    ChannelActivityEvent::Delete => {
                        account.last_delete_at = Some(ts);
                    }
                    ChannelActivityEvent::Thread => {
                        account.last_thread_at = Some(ts);
                    }
                }
                account.connected = account.connected.or(Some(true));
                account.running = account.running.or(Some(true));
                guard.set_default_account(channel, account_id.as_str());
            }
        }

        if let Some(map) = payload.as_object() {
            if let Some(channels_value) = map.get("channels") {
                if let Some(channels_map) = channels_value.as_object() {
                    for (channel_id, runtime_value) in channels_map {
                        let canonical = canonicalize_runtime_channel_id(channel_id);
                        ingest_runtime_entry(&mut guard, canonical.as_str(), runtime_value, None);
                    }
                }
            }
            if let Some(channel_accounts_value) = map
                .get("channelAccounts")
                .or_else(|| map.get("channel_accounts"))
            {
                if let Some(channel_accounts_map) = channel_accounts_value.as_object() {
                    for (channel_id, accounts_value) in channel_accounts_map {
                        let canonical = canonicalize_runtime_channel_id(channel_id);
                        ingest_accounts_value(&mut guard, canonical.as_str(), accounts_value, None);
                    }
                }
            }
            if let Some(default_account_value) = map
                .get("channelDefaultAccountId")
                .or_else(|| map.get("channel_default_account_id"))
            {
                if let Some(default_account_map) = default_account_value.as_object() {
                    for (channel_id, account_id_value) in default_account_map {
                        if let Some(account_id) = value_as_account_id(account_id_value) {
                            let canonical = canonicalize_runtime_channel_id(channel_id);
                            guard.set_default_account(canonical.as_str(), account_id.as_str());
                        }
                    }
                }
            }
            if let Some(channel) = inferred_payload_channel
                .as_deref()
                .or(inferred_channel.as_deref())
            {
                if let Some(account_id) = map
                    .get("defaultAccountId")
                    .or_else(|| map.get("default_account_id"))
                    .and_then(value_as_account_id)
                {
                    guard.set_default_account(channel, account_id.as_str());
                }
            }
        }

        if payload.as_object().is_some() {
            if let Some(channel) = inferred_payload_channel.or(inferred_channel) {
                ingest_runtime_entry(&mut guard, channel.as_str(), payload, None);
            }
        }
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
    }
}

impl ChannelRuntimeState {
    fn account_mut(&mut self, channel: &str, account_id: &str) -> &mut ChannelAccountRuntime {
        let channel_id = canonicalize_runtime_channel_id(channel);
        let account_id = normalize_account_id(account_id);
        self.by_channel
            .entry(channel_id)
            .or_default()
            .entry(account_id)
            .or_default()
    }

    fn set_default_account(&mut self, channel: &str, account_id: &str) {
        let channel_id = canonicalize_runtime_channel_id(channel);
        let account_id = normalize_account_id(account_id);
        self.default_account_by_channel
            .insert(channel_id, account_id);
    }
}

fn normalize_channel_runtime_state(state: ChannelRuntimeState) -> ChannelRuntimeState {
    let mut normalized = ChannelRuntimeState::default();
    let mut channels = state.by_channel.into_iter().collect::<Vec<_>>();
    channels.sort_by(|(left, _), (right, _)| left.cmp(right));

    for (channel_id, accounts) in channels {
        let canonical_channel = canonicalize_runtime_channel_id(channel_id.as_str());
        let entry = normalized.by_channel.entry(canonical_channel).or_default();
        let mut account_entries = accounts.into_iter().collect::<Vec<_>>();
        account_entries.sort_by(|(left, _), (right, _)| left.cmp(right));
        for (account_id, runtime) in account_entries {
            entry.insert(normalize_account_id(account_id.as_str()), runtime);
        }
    }

    let mut defaults = state
        .default_account_by_channel
        .into_iter()
        .collect::<Vec<_>>();
    defaults.sort_by(|(left, _), (right, _)| left.cmp(right));
    for (channel_id, account_id) in defaults {
        let canonical_channel = canonicalize_runtime_channel_id(channel_id.as_str());
        if normalized.by_channel.contains_key(&canonical_channel) {
            normalized
                .default_account_by_channel
                .insert(canonical_channel, normalize_account_id(account_id.as_str()));
        }
    }

    normalized
}

fn ingest_runtime_entry(
    state: &mut ChannelRuntimeState,
    channel: &str,
    runtime_value: &Value,
    account_hint: Option<&str>,
) {
    let Some(runtime_map) = runtime_value.as_object() else {
        return;
    };
    let has_inline_runtime_fields = runtime_map_has_inline_runtime_fields(runtime_map);
    if let Some(default_account_id) = runtime_map
        .get("defaultAccountId")
        .or_else(|| runtime_map.get("default_account_id"))
        .and_then(value_as_account_id)
    {
        state.set_default_account(channel, default_account_id.as_str());
    }
    if let Some(accounts_value) = runtime_map.get("accounts") {
        ingest_accounts_value(state, channel, accounts_value, account_hint);
        if !has_inline_runtime_fields {
            return;
        }
    }

    let account_id = runtime_map
        .get("accountId")
        .or_else(|| runtime_map.get("account_id"))
        .or_else(|| runtime_map.get("account"))
        .and_then(Value::as_str)
        .or(account_hint)
        .unwrap_or("default");
    let account = state.account_mut(channel, account_id);
    account.name = runtime_map
        .get("name")
        .or_else(|| runtime_map.get("displayName"))
        .or_else(|| runtime_map.get("display_name"))
        .and_then(Value::as_str)
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToOwned::to_owned)
        .or(account.name.clone());

    account.enabled = runtime_map
        .get("enabled")
        .and_then(json_value_as_bool)
        .or(account.enabled);
    account.configured = runtime_map
        .get("configured")
        .and_then(json_value_as_bool)
        .or(account.configured);
    account.linked = runtime_map
        .get("linked")
        .and_then(json_value_as_bool)
        .or(account.linked);
    account.running = runtime_map
        .get("running")
        .and_then(json_value_as_bool)
        .or(account.running);
    account.connected = runtime_map
        .get("connected")
        .and_then(json_value_as_bool)
        .or(account.connected);
    account.reconnect_attempts = runtime_map
        .get("reconnectAttempts")
        .or_else(|| runtime_map.get("reconnect_attempts"))
        .and_then(value_as_u64)
        .or(account.reconnect_attempts);
    account.last_connected_at = runtime_map
        .get("lastConnectedAt")
        .or_else(|| runtime_map.get("last_connected_at"))
        .and_then(value_as_u64)
        .or(account.last_connected_at);
    account.last_start_at = runtime_map
        .get("lastStartAt")
        .or_else(|| runtime_map.get("last_start_at"))
        .and_then(value_as_u64)
        .or(account.last_start_at);
    account.last_stop_at = runtime_map
        .get("lastStopAt")
        .or_else(|| runtime_map.get("last_stop_at"))
        .and_then(value_as_u64)
        .or(account.last_stop_at);
    account.last_inbound_at = runtime_map
        .get("lastInboundAt")
        .or_else(|| runtime_map.get("last_inbound_at"))
        .and_then(value_as_u64)
        .or(account.last_inbound_at);
    account.last_outbound_at = runtime_map
        .get("lastOutboundAt")
        .or_else(|| runtime_map.get("last_outbound_at"))
        .and_then(value_as_u64)
        .or(account.last_outbound_at);
    account.last_reaction_at = runtime_map
        .get("lastReactionAt")
        .or_else(|| runtime_map.get("last_reaction_at"))
        .and_then(value_as_u64)
        .or(account.last_reaction_at);
    account.last_edit_at = runtime_map
        .get("lastEditAt")
        .or_else(|| runtime_map.get("last_edit_at"))
        .and_then(value_as_u64)
        .or(account.last_edit_at);
    account.last_delete_at = runtime_map
        .get("lastDeleteAt")
        .or_else(|| runtime_map.get("last_delete_at"))
        .and_then(value_as_u64)
        .or(account.last_delete_at);
    account.last_thread_at = runtime_map
        .get("lastThreadAt")
        .or_else(|| runtime_map.get("last_thread_at"))
        .and_then(value_as_u64)
        .or(account.last_thread_at);
    account.last_probe_at = runtime_map
        .get("lastProbeAt")
        .or_else(|| runtime_map.get("last_probe_at"))
        .and_then(value_as_u64)
        .or(account.last_probe_at);
    account.last_error = runtime_map
        .get("lastError")
        .or_else(|| runtime_map.get("last_error"))
        .and_then(Value::as_str)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty())
        .or(account.last_error.clone());
    account.mode = runtime_map
        .get("mode")
        .and_then(Value::as_str)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty())
        .or(account.mode.clone());
    account.dm_policy = runtime_map
        .get("dmPolicy")
        .or_else(|| runtime_map.get("dm_policy"))
        .and_then(Value::as_str)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty())
        .or(account.dm_policy.clone());
    account.allow_from = runtime_map
        .get("allowFrom")
        .or_else(|| runtime_map.get("allow_from"))
        .and_then(value_as_string_list)
        .or(account.allow_from.clone());
    account.token_source = runtime_map
        .get("tokenSource")
        .or_else(|| runtime_map.get("token_source"))
        .and_then(Value::as_str)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty())
        .or(account.token_source.clone());
    account.bot_token_source = runtime_map
        .get("botTokenSource")
        .or_else(|| runtime_map.get("bot_token_source"))
        .and_then(Value::as_str)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty())
        .or(account.bot_token_source.clone());
    account.app_token_source = runtime_map
        .get("appTokenSource")
        .or_else(|| runtime_map.get("app_token_source"))
        .and_then(Value::as_str)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty())
        .or(account.app_token_source.clone());
    account.base_url = runtime_map
        .get("baseUrl")
        .or_else(|| runtime_map.get("base_url"))
        .and_then(Value::as_str)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty())
        .or(account.base_url.clone());
    account.allow_unmentioned_groups = runtime_map
        .get("allowUnmentionedGroups")
        .or_else(|| runtime_map.get("allow_unmentioned_groups"))
        .and_then(json_value_as_bool)
        .or(account.allow_unmentioned_groups);
    account.cli_path = runtime_map
        .get("cliPath")
        .or_else(|| runtime_map.get("cli_path"))
        .and_then(value_as_optional_path_value)
        .or(account.cli_path.clone());
    account.db_path = runtime_map
        .get("dbPath")
        .or_else(|| runtime_map.get("db_path"))
        .and_then(value_as_optional_path_value)
        .or(account.db_path.clone());
    account.port = runtime_map
        .get("port")
        .and_then(value_as_u64)
        .or(account.port);
    account.probe = runtime_map.get("probe").cloned().or(account.probe.clone());
    account.audit = runtime_map.get("audit").cloned().or(account.audit.clone());
    account.application = runtime_map
        .get("application")
        .cloned()
        .or(account.application.clone());
}

fn runtime_map_has_inline_runtime_fields(
    runtime_map: &serde_json::Map<String, serde_json::Value>,
) -> bool {
    runtime_map.contains_key("accountId")
        || runtime_map.contains_key("account_id")
        || runtime_map.contains_key("account")
        || runtime_map.contains_key("name")
        || runtime_map.contains_key("displayName")
        || runtime_map.contains_key("display_name")
        || runtime_map.contains_key("enabled")
        || runtime_map.contains_key("configured")
        || runtime_map.contains_key("linked")
        || runtime_map.contains_key("running")
        || runtime_map.contains_key("connected")
        || runtime_map.contains_key("reconnectAttempts")
        || runtime_map.contains_key("reconnect_attempts")
        || runtime_map.contains_key("lastConnectedAt")
        || runtime_map.contains_key("last_connected_at")
        || runtime_map.contains_key("lastStartAt")
        || runtime_map.contains_key("last_start_at")
        || runtime_map.contains_key("lastStopAt")
        || runtime_map.contains_key("last_stop_at")
        || runtime_map.contains_key("lastInboundAt")
        || runtime_map.contains_key("last_inbound_at")
        || runtime_map.contains_key("lastOutboundAt")
        || runtime_map.contains_key("last_outbound_at")
        || runtime_map.contains_key("lastReactionAt")
        || runtime_map.contains_key("last_reaction_at")
        || runtime_map.contains_key("lastEditAt")
        || runtime_map.contains_key("last_edit_at")
        || runtime_map.contains_key("lastDeleteAt")
        || runtime_map.contains_key("last_delete_at")
        || runtime_map.contains_key("lastThreadAt")
        || runtime_map.contains_key("last_thread_at")
        || runtime_map.contains_key("lastProbeAt")
        || runtime_map.contains_key("last_probe_at")
        || runtime_map.contains_key("lastError")
        || runtime_map.contains_key("last_error")
        || runtime_map.contains_key("mode")
        || runtime_map.contains_key("dmPolicy")
        || runtime_map.contains_key("dm_policy")
        || runtime_map.contains_key("allowFrom")
        || runtime_map.contains_key("allow_from")
        || runtime_map.contains_key("tokenSource")
        || runtime_map.contains_key("token_source")
        || runtime_map.contains_key("botTokenSource")
        || runtime_map.contains_key("bot_token_source")
        || runtime_map.contains_key("appTokenSource")
        || runtime_map.contains_key("app_token_source")
        || runtime_map.contains_key("baseUrl")
        || runtime_map.contains_key("base_url")
        || runtime_map.contains_key("allowUnmentionedGroups")
        || runtime_map.contains_key("allow_unmentioned_groups")
        || runtime_map.contains_key("cliPath")
        || runtime_map.contains_key("cli_path")
        || runtime_map.contains_key("dbPath")
        || runtime_map.contains_key("db_path")
        || runtime_map.contains_key("port")
        || runtime_map.contains_key("probe")
        || runtime_map.contains_key("audit")
        || runtime_map.contains_key("application")
}

fn ingest_accounts_value(
    state: &mut ChannelRuntimeState,
    channel: &str,
    accounts_value: &Value,
    account_hint: Option<&str>,
) {
    if let Some(accounts_array) = accounts_value.as_array() {
        for item in accounts_array {
            ingest_runtime_entry(state, channel, item, account_hint);
        }
        return;
    }
    if let Some(accounts_map) = accounts_value.as_object() {
        let mut ingested = false;
        for (account_id, runtime_value) in accounts_map {
            if runtime_value.is_object() {
                ingest_runtime_entry(state, channel, runtime_value, Some(account_id.as_str()));
                ingested = true;
            }
        }
        if !ingested {
            ingest_runtime_entry(state, channel, accounts_value, account_hint);
        }
    }
}

fn canonicalize_runtime_channel_id(channel: &str) -> String {
    normalize_channel_id(Some(channel)).unwrap_or_else(|| normalize(channel))
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ChannelLifecycleEvent {
    Connected,
    Disconnected,
    Reconnecting,
    Error,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ChannelActivityEvent {
    Inbound,
    Outbound,
    Reaction,
    Edit,
    Delete,
    Thread,
}

fn classify_channel_lifecycle_event(event: &str) -> Option<ChannelLifecycleEvent> {
    let normalized = normalize(event);
    let suffix = normalized.rsplit('.').next().unwrap_or(normalized.as_str());
    match suffix {
        "connected" | "ready" | "started" | "online" => Some(ChannelLifecycleEvent::Connected),
        "disconnected" | "stopped" | "offline" => Some(ChannelLifecycleEvent::Disconnected),
        "reconnecting" | "reconnect" | "retrying" => Some(ChannelLifecycleEvent::Reconnecting),
        "error" | "failed" | "failure" => Some(ChannelLifecycleEvent::Error),
        _ => None,
    }
}

fn classify_channel_activity_event(event: &str) -> Option<ChannelActivityEvent> {
    let normalized = normalize(event);
    let suffix = normalized.rsplit('.').next().unwrap_or(normalized.as_str());
    let normalized_suffix = suffix
        .chars()
        .filter(|ch| ch.is_ascii_alphanumeric())
        .collect::<String>();
    if let Some(classified) = classify_channel_activity_token(normalized_suffix.as_str()) {
        return Some(classified);
    }

    let compact = normalized
        .chars()
        .filter(|ch| ch.is_ascii_alphanumeric())
        .collect::<String>();
    if compact.is_empty() {
        return None;
    }

    if compact.contains("messagereceived")
        || compact.contains("incoming")
        || compact.contains("inbound")
        || compact.contains("received")
    {
        return Some(ChannelActivityEvent::Inbound);
    }
    if compact.contains("messagesent")
        || compact.contains("outbound")
        || compact.contains("delivered")
        || compact.contains("delivery")
        || compact.contains("acknowledged")
        || compact.contains("ack")
    {
        return Some(ChannelActivityEvent::Outbound);
    }
    if compact.contains("reaction") || compact.contains("reacted") {
        return Some(ChannelActivityEvent::Reaction);
    }
    if compact.contains("messageedit")
        || compact.contains("messageedited")
        || compact.contains("messageupdated")
        || compact.contains("edited")
    {
        return Some(ChannelActivityEvent::Edit);
    }
    if compact.contains("messagedelete")
        || compact.contains("messagedeleted")
        || compact.contains("messageremoved")
        || compact.contains("deleted")
    {
        return Some(ChannelActivityEvent::Delete);
    }
    if compact.contains("threadreply")
        || compact.contains("threadcreate")
        || compact.contains("threadcreated")
        || compact.contains("threadlist")
        || compact == "thread"
    {
        return Some(ChannelActivityEvent::Thread);
    }

    None
}

fn classify_channel_activity_token(token: &str) -> Option<ChannelActivityEvent> {
    match token {
        "message" | "inbound" | "incoming" | "received" | "recv" | "messagereceived" => {
            Some(ChannelActivityEvent::Inbound)
        }
        "outbound" | "sent" | "delivered" | "delivery" | "ack" | "acknowledged" | "messagesent" => {
            Some(ChannelActivityEvent::Outbound)
        }
        "reaction" | "react" | "reacted" | "reactionadded" | "reactionremoved" => {
            Some(ChannelActivityEvent::Reaction)
        }
        "edit" | "edited" | "messageedit" | "messageedited" | "updated" | "messageupdated" => {
            Some(ChannelActivityEvent::Edit)
        }
        "delete" | "deleted" | "messagedelete" | "messagedeleted" | "removed"
        | "messageremoved" => Some(ChannelActivityEvent::Delete),
        "thread" | "threadcreate" | "threadcreated" | "threadreply" | "threadreplied"
        | "threadlist" => Some(ChannelActivityEvent::Thread),
        _ => None,
    }
}

fn apply_channel_lifecycle_event(
    state: &mut ChannelRuntimeState,
    channel: &str,
    account_id: &str,
    lifecycle: ChannelLifecycleEvent,
    payload: &Value,
) {
    let account = state.account_mut(channel, account_id);
    let ts = now_ms();
    match lifecycle {
        ChannelLifecycleEvent::Connected => {
            account.connected = Some(true);
            account.running = Some(true);
            account.last_connected_at = Some(ts);
            account.last_start_at = account.last_start_at.or(Some(ts));
            account.last_error = None;
        }
        ChannelLifecycleEvent::Disconnected => {
            account.connected = Some(false);
            account.running = Some(false);
            account.last_stop_at = Some(ts);
        }
        ChannelLifecycleEvent::Reconnecting => {
            account.connected = Some(false);
            account.running = Some(true);
            account.reconnect_attempts = Some(account.reconnect_attempts.unwrap_or(0) + 1);
            account.last_stop_at = Some(ts);
            if let Some(last_error) = lifecycle_last_error(payload) {
                account.last_error = Some(last_error);
            }
        }
        ChannelLifecycleEvent::Error => {
            account.connected = Some(false);
            account.running = Some(false);
            account.last_stop_at = Some(ts);
            if let Some(last_error) = lifecycle_last_error(payload) {
                account.last_error = Some(last_error);
            }
        }
    }
}

fn lifecycle_last_error(payload: &Value) -> Option<String> {
    let map = payload.as_object()?;
    let value = map
        .get("error")
        .or_else(|| map.get("message"))
        .or_else(|| map.get("reason"))
        .or_else(|| map.get("details"))?;
    match value {
        Value::String(raw) => {
            let trimmed = raw.trim();
            (!trimmed.is_empty()).then_some(trimmed.to_owned())
        }
        Value::Null => None,
        _ => Some(value.to_string()),
    }
}

fn infer_channel_from_payload(payload: &Value) -> Option<String> {
    let map = payload.as_object()?;
    if let Some(channel) = infer_channel_from_payload_map(map) {
        return Some(channel);
    }
    for nested_key in ["meta", "context", "ctx", "runtime", "data", "source"] {
        let Some(nested) = map.get(nested_key).and_then(Value::as_object) else {
            continue;
        };
        if let Some(channel) = infer_channel_from_payload_map(nested) {
            return Some(channel);
        }
    }
    None
}

fn infer_channel_from_payload_map(map: &serde_json::Map<String, Value>) -> Option<String> {
    let raw = map
        .get("channel")
        .or_else(|| map.get("channelId"))
        .or_else(|| map.get("channel_id"))
        .or_else(|| map.get("provider"))
        .or_else(|| map.get("platform"))
        .or_else(|| map.get("channelName"))
        .or_else(|| map.get("channel_name"))
        .and_then(Value::as_str)?;
    normalize_channel_id(Some(raw)).or_else(|| Some(normalize(raw)))
}

fn infer_channel_from_event(event: &str, known_channels: &[&str]) -> Option<String> {
    let normalized_event = normalize(event);
    for segment in normalized_event.split('.') {
        let candidate = normalize_channel_id(Some(segment)).unwrap_or_else(|| segment.to_owned());
        if known_channels
            .iter()
            .any(|channel| channel.eq_ignore_ascii_case(&candidate))
        {
            return Some(candidate);
        }
    }
    None
}

fn infer_runtime_account_id(payload: &Value) -> Option<String> {
    let map = payload.as_object()?;
    if let Some(account_id) = map
        .get("accountId")
        .or_else(|| map.get("account_id"))
        .or_else(|| map.get("account"))
        .and_then(value_as_account_id)
    {
        return Some(account_id);
    }

    for nested_key in ["meta", "context", "ctx", "runtime", "data"] {
        let Some(nested) = map.get(nested_key).and_then(Value::as_object) else {
            continue;
        };
        if let Some(account_id) = nested
            .get("accountId")
            .or_else(|| nested.get("account_id"))
            .or_else(|| nested.get("account"))
            .and_then(value_as_account_id)
        {
            return Some(account_id);
        }
    }
    None
}

fn normalize_account_id(account_id: &str) -> String {
    let trimmed = account_id.trim();
    if trimmed.is_empty() {
        "default".to_owned()
    } else {
        trimmed.to_owned()
    }
}

fn value_as_u64(value: &Value) -> Option<u64> {
    match value {
        Value::Number(number) => number.as_u64(),
        Value::String(raw) => raw.trim().parse::<u64>().ok(),
        _ => None,
    }
}

fn value_as_account_id(value: &Value) -> Option<String> {
    match value {
        Value::String(raw) => {
            let trimmed = raw.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(trimmed.to_owned())
            }
        }
        Value::Number(number) => number
            .as_u64()
            .map(|n| n.to_string())
            .or_else(|| number.as_i64().map(|n| n.to_string())),
        _ => None,
    }
}

fn value_as_string_list(value: &Value) -> Option<Vec<String>> {
    if let Some(values) = value.as_array() {
        let items = values
            .iter()
            .filter_map(|item| item.as_str())
            .map(str::trim)
            .filter(|item| !item.is_empty())
            .map(ToOwned::to_owned)
            .collect::<Vec<_>>();
        return (!items.is_empty()).then_some(items);
    }
    if let Some(raw) = value.as_str() {
        let items = raw
            .split([',', '\n', ';'])
            .map(str::trim)
            .filter(|item| !item.is_empty())
            .map(ToOwned::to_owned)
            .collect::<Vec<_>>();
        return (!items.is_empty()).then_some(items);
    }
    None
}

fn value_as_optional_path_value(value: &Value) -> Option<Value> {
    match value {
        Value::Null => Some(Value::Null),
        Value::String(raw) => {
            let trimmed = raw.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(Value::String(trimmed.to_owned()))
            }
        }
        _ => None,
    }
}

fn resolve_default_account_id(
    runtime_accounts: &[(String, ChannelAccountRuntime)],
    hinted_default_account_id: Option<&str>,
) -> String {
    if let Some(hint) = hinted_default_account_id {
        if let Some((existing_account_id, _)) = runtime_accounts
            .iter()
            .find(|(candidate, _)| candidate.eq_ignore_ascii_case(hint))
        {
            return existing_account_id.clone();
        }
    }
    if let Some((default_account_id, _)) = runtime_accounts
        .iter()
        .find(|(account_id, _)| account_id.eq_ignore_ascii_case("default"))
    {
        return default_account_id.clone();
    }
    runtime_accounts
        .first()
        .map(|(account_id, _)| account_id.clone())
        .unwrap_or_else(|| "default".to_owned())
}

struct DeviceRegistry {
    state: Mutex<DevicePairState>,
    runtime: Mutex<DevicePairRuntimeState>,
}

#[derive(Debug, Clone, Default)]
struct DevicePairState {
    pending_by_id: HashMap<String, DevicePairPendingRequest>,
    paired_by_device_id: HashMap<String, PairedDeviceEntry>,
}

#[derive(Debug, Clone)]
struct DevicePairRuntimeState {
    store_path: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct DevicePairStoreDiskState {
    version: u32,
    pending: Vec<DevicePairPendingRequest>,
    paired: Vec<PairedDeviceEntry>,
}

impl Default for DevicePairStoreDiskState {
    fn default() -> Self {
        Self {
            version: 1,
            pending: Vec::new(),
            paired: Vec::new(),
        }
    }
}

#[derive(Debug, Clone, serde::Serialize)]
struct DevicePairListResult {
    pending: Vec<DevicePairPendingRequest>,
    paired: Vec<PairedDeviceView>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct DevicePairApproveResult {
    #[serde(rename = "requestId")]
    request_id: String,
    device: PairedDeviceView,
}

#[derive(Debug, Clone, serde::Serialize)]
struct DevicePairRejectResult {
    #[serde(rename = "requestId")]
    request_id: String,
    #[serde(rename = "deviceId")]
    device_id: String,
}

#[derive(Debug, Clone, serde::Serialize)]
struct DevicePairRemoveResult {
    #[serde(rename = "deviceId")]
    device_id: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct DevicePairPendingRequest {
    #[serde(rename = "requestId")]
    request_id: String,
    #[serde(rename = "deviceId")]
    device_id: String,
    #[serde(rename = "publicKey")]
    public_key: String,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    display_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    platform: Option<String>,
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    client_id: Option<String>,
    #[serde(rename = "clientMode", skip_serializing_if = "Option::is_none")]
    client_mode: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    role: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    roles: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    scopes: Option<Vec<String>>,
    #[serde(rename = "remoteIp", skip_serializing_if = "Option::is_none")]
    remote_ip: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    silent: Option<bool>,
    #[serde(rename = "isRepair", skip_serializing_if = "Option::is_none")]
    is_repair: Option<bool>,
    ts: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct PairedDeviceEntry {
    device_id: String,
    public_key: String,
    display_name: Option<String>,
    platform: Option<String>,
    client_id: Option<String>,
    client_mode: Option<String>,
    role: Option<String>,
    roles: Option<Vec<String>>,
    scopes: Option<Vec<String>>,
    remote_ip: Option<String>,
    tokens: HashMap<String, DeviceAuthTokenEntry>,
    created_at_ms: u64,
    approved_at_ms: u64,
}

#[derive(Debug, Clone, serde::Serialize)]
struct PairedDeviceView {
    #[serde(rename = "deviceId")]
    device_id: String,
    #[serde(rename = "publicKey")]
    public_key: String,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    display_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    platform: Option<String>,
    #[serde(rename = "clientId", skip_serializing_if = "Option::is_none")]
    client_id: Option<String>,
    #[serde(rename = "clientMode", skip_serializing_if = "Option::is_none")]
    client_mode: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    role: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    roles: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    scopes: Option<Vec<String>>,
    #[serde(rename = "remoteIp", skip_serializing_if = "Option::is_none")]
    remote_ip: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    tokens: Option<Vec<DeviceAuthTokenSummary>>,
    #[serde(rename = "createdAtMs")]
    created_at_ms: u64,
    #[serde(rename = "approvedAtMs")]
    approved_at_ms: u64,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct DeviceAuthTokenEntry {
    token: String,
    role: String,
    scopes: Vec<String>,
    created_at_ms: u64,
    rotated_at_ms: Option<u64>,
    revoked_at_ms: Option<u64>,
    last_used_at_ms: Option<u64>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct DeviceAuthTokenSummary {
    role: String,
    scopes: Vec<String>,
    #[serde(rename = "createdAtMs")]
    created_at_ms: u64,
    #[serde(rename = "rotatedAtMs", skip_serializing_if = "Option::is_none")]
    rotated_at_ms: Option<u64>,
    #[serde(rename = "revokedAtMs", skip_serializing_if = "Option::is_none")]
    revoked_at_ms: Option<u64>,
    #[serde(rename = "lastUsedAtMs", skip_serializing_if = "Option::is_none")]
    last_used_at_ms: Option<u64>,
}

#[derive(Debug, Clone, Default, serde::Deserialize)]
#[serde(default)]
struct DevicePairRequestedEventPayload {
    #[serde(rename = "requestId", alias = "request_id")]
    request_id: Option<String>,
    #[serde(rename = "deviceId", alias = "device_id")]
    device_id: Option<String>,
    #[serde(rename = "publicKey", alias = "public_key")]
    public_key: Option<String>,
    #[serde(rename = "displayName", alias = "display_name")]
    display_name: Option<String>,
    platform: Option<String>,
    #[serde(rename = "clientId", alias = "client_id")]
    client_id: Option<String>,
    #[serde(rename = "clientMode", alias = "client_mode")]
    client_mode: Option<String>,
    role: Option<String>,
    roles: Option<Vec<String>>,
    scopes: Option<Vec<String>>,
    #[serde(rename = "remoteIp", alias = "remote_ip")]
    remote_ip: Option<String>,
    silent: Option<bool>,
    #[serde(rename = "isRepair", alias = "is_repair")]
    is_repair: Option<bool>,
    ts: Option<u64>,
}

#[derive(Debug, Clone, Default, serde::Deserialize)]
#[serde(default)]
struct DevicePairResolvedEventPayload {
    #[serde(rename = "requestId", alias = "request_id")]
    request_id: Option<String>,
}

impl DeviceRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(DevicePairState::default()),
            runtime: Mutex::new(DevicePairRuntimeState {
                store_path: DEVICE_PAIR_STORE_PATH.to_owned(),
            }),
        }
    }

    async fn apply_runtime_config(&self, runtime: DevicePairRuntimeConfig) -> Result<(), String> {
        let target_store_path = runtime
            .store_path
            .and_then(|value| normalize_optional_text(Some(value), 2048))
            .unwrap_or_else(|| DEVICE_PAIR_STORE_PATH.to_owned());

        let current_store_path = { self.runtime.lock().await.store_path.clone() };
        if current_store_path == target_store_path {
            return Ok(());
        }

        let loaded = load_device_pair_store_disk_state(&target_store_path)?;
        let mut next_state = DevicePairState::default();

        for pending in loaded.pending {
            let Some(request_id) = normalize_optional_text(Some(pending.request_id.clone()), 128)
            else {
                continue;
            };
            let Some(device_id) = normalize_optional_text(Some(pending.device_id.clone()), 128)
            else {
                continue;
            };
            let Some(public_key) = normalize_optional_text(Some(pending.public_key.clone()), 1024)
            else {
                continue;
            };

            let role = normalize_optional_text(pending.role.clone(), 64);
            let mut roles = normalize_string_list(pending.roles.clone(), 32, 64);
            if let Some(role_value) = &role {
                if !roles
                    .iter()
                    .any(|existing| existing.eq_ignore_ascii_case(role_value))
                {
                    roles.push(role_value.clone());
                }
            }
            let scopes = normalize_device_auth_scopes(pending.scopes.clone());
            let mut normalized = pending;
            normalized.request_id = request_id.clone();
            normalized.device_id = device_id;
            normalized.public_key = public_key;
            normalized.display_name = normalize_optional_text(normalized.display_name, 128);
            normalized.platform = normalize_optional_text(normalized.platform, 128);
            normalized.client_id = normalize_optional_text(normalized.client_id, 128);
            normalized.client_mode = normalize_optional_text(normalized.client_mode, 128);
            normalized.role = role;
            normalized.roles = (!roles.is_empty()).then_some(roles);
            normalized.scopes = (!scopes.is_empty()).then_some(scopes);
            normalized.remote_ip = normalize_optional_text(normalized.remote_ip, 128);
            next_state.pending_by_id.insert(request_id, normalized);
        }

        for paired in loaded.paired {
            let Some(device_id) = normalize_optional_text(Some(paired.device_id.clone()), 128)
            else {
                continue;
            };
            let Some(public_key) = normalize_optional_text(Some(paired.public_key.clone()), 1024)
            else {
                continue;
            };

            let role = normalize_optional_text(paired.role.clone(), 64);
            let mut roles = normalize_string_list(paired.roles.clone(), 32, 64);
            if let Some(role_value) = &role {
                if !roles
                    .iter()
                    .any(|existing| existing.eq_ignore_ascii_case(role_value))
                {
                    roles.push(role_value.clone());
                }
            }
            let scopes = normalize_device_auth_scopes(paired.scopes.clone());

            let mut tokens = HashMap::new();
            for token in paired.tokens.values() {
                let Some(token_role) = normalize_optional_text(Some(token.role.clone()), 64) else {
                    continue;
                };
                let Some(token_value) = normalize_optional_text(Some(token.token.clone()), 1024)
                else {
                    continue;
                };
                let normalized_scopes = normalize_device_auth_scopes(Some(token.scopes.clone()));
                tokens.insert(
                    token_role.clone(),
                    DeviceAuthTokenEntry {
                        token: token_value,
                        role: token_role,
                        scopes: normalized_scopes,
                        created_at_ms: token.created_at_ms,
                        rotated_at_ms: token.rotated_at_ms,
                        revoked_at_ms: token.revoked_at_ms,
                        last_used_at_ms: token.last_used_at_ms,
                    },
                );
            }

            let normalized = PairedDeviceEntry {
                device_id: device_id.clone(),
                public_key,
                display_name: normalize_optional_text(paired.display_name, 128),
                platform: normalize_optional_text(paired.platform, 128),
                client_id: normalize_optional_text(paired.client_id, 128),
                client_mode: normalize_optional_text(paired.client_mode, 128),
                role,
                roles: (!roles.is_empty()).then_some(roles),
                scopes: (!scopes.is_empty()).then_some(scopes),
                remote_ip: normalize_optional_text(paired.remote_ip, 128),
                tokens,
                created_at_ms: paired.created_at_ms,
                approved_at_ms: paired.approved_at_ms,
            };
            next_state.paired_by_device_id.insert(device_id, normalized);
        }

        prune_oldest_pending(&mut next_state.pending_by_id, 512);
        prune_oldest_paired_devices(&mut next_state.paired_by_device_id, 2_048);

        {
            let mut guard = self.state.lock().await;
            *guard = next_state.clone();
        }
        {
            let mut runtime_guard = self.runtime.lock().await;
            runtime_guard.store_path = target_store_path.clone();
        }
        persist_device_pair_store_disk_state(&target_store_path, &next_state)?;
        Ok(())
    }

    async fn persist_state_snapshot(&self, state: DevicePairState) -> Result<(), String> {
        let store_path = { self.runtime.lock().await.store_path.clone() };
        persist_device_pair_store_disk_state(&store_path, &state)
    }

    async fn list(&self) -> DevicePairListResult {
        let guard = self.state.lock().await;
        let mut pending = guard
            .pending_by_id
            .values()
            .cloned()
            .collect::<Vec<DevicePairPendingRequest>>();
        pending.sort_by(|a, b| {
            b.ts.cmp(&a.ts)
                .then_with(|| a.request_id.cmp(&b.request_id))
        });

        let mut paired = guard
            .paired_by_device_id
            .values()
            .map(redact_paired_device)
            .collect::<Vec<PairedDeviceView>>();
        paired.sort_by(|a, b| {
            b.approved_at_ms
                .cmp(&a.approved_at_ms)
                .then_with(|| a.device_id.cmp(&b.device_id))
        });
        DevicePairListResult { pending, paired }
    }

    async fn ingest_pair_requested(&self, payload: Value) {
        let Ok(event) = serde_json::from_value::<DevicePairRequestedEventPayload>(payload) else {
            return;
        };
        let Some(request_id) = normalize_optional_text(event.request_id, 128) else {
            return;
        };
        let Some(device_id) = normalize_optional_text(event.device_id, 128) else {
            return;
        };
        let Some(public_key) = normalize_optional_text(event.public_key, 1024) else {
            return;
        };
        let role = normalize_optional_text(event.role, 64);
        let mut roles = normalize_string_list(event.roles, 32, 64);
        if let Some(role_value) = &role {
            if !roles
                .iter()
                .any(|existing| existing.eq_ignore_ascii_case(role_value))
            {
                roles.push(role_value.clone());
            }
        }
        let roles = (!roles.is_empty()).then_some(roles);
        let scopes = normalize_device_auth_scopes(event.scopes);
        let request = DevicePairPendingRequest {
            request_id: request_id.clone(),
            device_id: device_id.clone(),
            public_key,
            display_name: normalize_optional_text(event.display_name, 128),
            platform: normalize_optional_text(event.platform, 128),
            client_id: normalize_optional_text(event.client_id, 128),
            client_mode: normalize_optional_text(event.client_mode, 128),
            role,
            roles,
            scopes: (!scopes.is_empty()).then_some(scopes),
            remote_ip: normalize_optional_text(event.remote_ip, 128),
            silent: event.silent,
            is_repair: event.is_repair,
            ts: event.ts.unwrap_or_else(now_ms),
        };
        let mut guard = self.state.lock().await;
        guard
            .pending_by_id
            .retain(|key, pending| key == &request_id || pending.device_id != device_id);
        guard.pending_by_id.insert(request_id, request);
        prune_oldest_pending(&mut guard.pending_by_id, 512);
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
    }

    async fn ingest_pair_resolved(&self, payload: Value) {
        let Ok(event) = serde_json::from_value::<DevicePairResolvedEventPayload>(payload) else {
            return;
        };
        let Some(request_id) = normalize_optional_text(event.request_id, 128) else {
            return;
        };
        let mut guard = self.state.lock().await;
        let _ = guard.pending_by_id.remove(&request_id);
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
    }

    async fn approve(&self, request_id: &str) -> Option<DevicePairApproveResult> {
        let mut guard = self.state.lock().await;
        let pending = guard.pending_by_id.remove(request_id)?;
        let now = now_ms();
        let existing = guard.paired_by_device_id.get(&pending.device_id).cloned();
        let mut tokens = existing
            .as_ref()
            .map(|entry| entry.tokens.clone())
            .unwrap_or_default();

        if let Some(role) = pending.role.clone() {
            let scoped = normalize_device_auth_scopes(pending.scopes.clone());
            let existing_token = tokens.get(&role).cloned();
            tokens.insert(
                role.clone(),
                DeviceAuthTokenEntry {
                    token: next_device_auth_token(&pending.device_id, &role),
                    role,
                    scopes: scoped,
                    created_at_ms: existing_token
                        .as_ref()
                        .map_or(now, |token| token.created_at_ms),
                    rotated_at_ms: existing_token.as_ref().map(|_| now),
                    revoked_at_ms: None,
                    last_used_at_ms: existing_token.and_then(|token| token.last_used_at_ms),
                },
            );
        }

        let device = PairedDeviceEntry {
            device_id: pending.device_id.clone(),
            public_key: pending.public_key,
            display_name: pending.display_name,
            platform: pending.platform,
            client_id: pending.client_id,
            client_mode: pending.client_mode,
            role: pending.role,
            roles: merge_device_roles(existing.as_ref(), pending.roles.as_ref()),
            scopes: merge_device_scopes(existing.as_ref(), pending.scopes.as_ref()),
            remote_ip: pending.remote_ip,
            tokens,
            created_at_ms: existing.as_ref().map_or(now, |entry| entry.created_at_ms),
            approved_at_ms: now,
        };
        guard
            .paired_by_device_id
            .insert(device.device_id.clone(), device.clone());
        prune_oldest_paired_devices(&mut guard.paired_by_device_id, 2_048);
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
        Some(DevicePairApproveResult {
            request_id: request_id.to_owned(),
            device: redact_paired_device(&device),
        })
    }

    async fn reject(&self, request_id: &str) -> Option<DevicePairRejectResult> {
        let mut guard = self.state.lock().await;
        let pending = guard.pending_by_id.remove(request_id)?;
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
        Some(DevicePairRejectResult {
            request_id: request_id.to_owned(),
            device_id: pending.device_id,
        })
    }

    async fn remove(&self, device_id: &str) -> Option<DevicePairRemoveResult> {
        let normalized = device_id.trim();
        if normalized.is_empty() {
            return None;
        }
        let mut guard = self.state.lock().await;
        guard.paired_by_device_id.remove(normalized)?;
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
        Some(DevicePairRemoveResult {
            device_id: normalized.to_owned(),
        })
    }

    async fn rotate_token(
        &self,
        device_id: &str,
        role: &str,
        scopes: Option<Vec<String>>,
    ) -> Option<DeviceAuthTokenEntry> {
        let normalized_device_id = device_id.trim();
        if normalized_device_id.is_empty() {
            return None;
        }
        let normalized_role = role.trim();
        if normalized_role.is_empty() {
            return None;
        }
        let mut guard = self.state.lock().await;
        let device = guard.paired_by_device_id.get_mut(normalized_device_id)?;
        let existing = device.tokens.get(normalized_role).cloned();
        let requested_scopes = normalize_device_auth_scopes(scopes.clone().or_else(|| {
            existing
                .as_ref()
                .map(|token| token.scopes.clone())
                .or_else(|| device.scopes.clone())
        }));
        let now = now_ms();
        let next = DeviceAuthTokenEntry {
            token: next_device_auth_token(&device.device_id, normalized_role),
            role: normalized_role.to_owned(),
            scopes: requested_scopes.clone(),
            created_at_ms: existing.as_ref().map_or(now, |token| token.created_at_ms),
            rotated_at_ms: Some(now),
            revoked_at_ms: None,
            last_used_at_ms: existing.and_then(|token| token.last_used_at_ms),
        };
        device
            .tokens
            .insert(normalized_role.to_owned(), next.clone());
        if scopes.is_some() {
            device.scopes = Some(requested_scopes);
        }
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
        Some(next)
    }

    async fn revoke_token(&self, device_id: &str, role: &str) -> Option<DeviceAuthTokenEntry> {
        let normalized_device_id = device_id.trim();
        if normalized_device_id.is_empty() {
            return None;
        }
        let normalized_role = role.trim();
        if normalized_role.is_empty() {
            return None;
        }
        let mut guard = self.state.lock().await;
        let device = guard.paired_by_device_id.get_mut(normalized_device_id)?;
        let token = device.tokens.get(normalized_role).cloned()?;
        let revoked = DeviceAuthTokenEntry {
            revoked_at_ms: Some(now_ms()),
            ..token
        };
        device
            .tokens
            .insert(normalized_role.to_owned(), revoked.clone());
        let snapshot = guard.clone();
        drop(guard);
        let _ = self.persist_state_snapshot(snapshot).await;
        Some(revoked)
    }
}

fn redact_paired_device(device: &PairedDeviceEntry) -> PairedDeviceView {
    PairedDeviceView {
        device_id: device.device_id.clone(),
        public_key: device.public_key.clone(),
        display_name: device.display_name.clone(),
        platform: device.platform.clone(),
        client_id: device.client_id.clone(),
        client_mode: device.client_mode.clone(),
        role: device.role.clone(),
        roles: device.roles.clone(),
        scopes: device.scopes.clone(),
        remote_ip: device.remote_ip.clone(),
        tokens: summarize_device_tokens(&device.tokens),
        created_at_ms: device.created_at_ms,
        approved_at_ms: device.approved_at_ms,
    }
}

fn summarize_device_tokens(
    tokens: &HashMap<String, DeviceAuthTokenEntry>,
) -> Option<Vec<DeviceAuthTokenSummary>> {
    if tokens.is_empty() {
        return None;
    }
    let mut summaries = tokens
        .values()
        .map(|token| DeviceAuthTokenSummary {
            role: token.role.clone(),
            scopes: token.scopes.clone(),
            created_at_ms: token.created_at_ms,
            rotated_at_ms: token.rotated_at_ms,
            revoked_at_ms: token.revoked_at_ms,
            last_used_at_ms: token.last_used_at_ms,
        })
        .collect::<Vec<_>>();
    summaries.sort_by(|a, b| a.role.cmp(&b.role));
    Some(summaries)
}

fn merge_device_roles(
    existing: Option<&PairedDeviceEntry>,
    pending_roles: Option<&Vec<String>>,
) -> Option<Vec<String>> {
    let mut merged = Vec::new();
    if let Some(existing) = existing {
        if let Some(roles) = &existing.roles {
            for role in roles {
                push_unique_string_case_insensitive(&mut merged, role, 64);
            }
        }
        if let Some(role) = &existing.role {
            push_unique_string_case_insensitive(&mut merged, role, 64);
        }
    }
    if let Some(roles) = pending_roles {
        for role in roles {
            push_unique_string_case_insensitive(&mut merged, role, 64);
        }
    }
    (!merged.is_empty()).then_some(merged)
}

fn merge_device_scopes(
    existing: Option<&PairedDeviceEntry>,
    pending_scopes: Option<&Vec<String>>,
) -> Option<Vec<String>> {
    let mut merged = Vec::new();
    if let Some(existing) = existing {
        if let Some(scopes) = &existing.scopes {
            for scope in scopes {
                push_unique_string_case_insensitive(&mut merged, scope, 96);
            }
        }
    }
    if let Some(scopes) = pending_scopes {
        for scope in scopes {
            push_unique_string_case_insensitive(&mut merged, scope, 96);
        }
    }
    (!merged.is_empty()).then_some(merged)
}

fn normalize_device_auth_scopes(scopes: Option<Vec<String>>) -> Vec<String> {
    normalize_string_list(scopes, 64, 96)
}

fn push_unique_string_case_insensitive(target: &mut Vec<String>, raw: &str, max_len: usize) {
    let Some(value) = normalize_optional_text(Some(raw.to_owned()), max_len) else {
        return;
    };
    if target
        .iter()
        .any(|existing| existing.eq_ignore_ascii_case(&value))
    {
        return;
    }
    target.push(value);
}

fn prune_oldest_pending(
    pending_by_id: &mut HashMap<String, DevicePairPendingRequest>,
    max_pending: usize,
) {
    while pending_by_id.len() > max_pending {
        let Some(oldest_key) = pending_by_id
            .iter()
            .min_by_key(|(_, pending)| pending.ts)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = pending_by_id.remove(&oldest_key);
    }
}

fn prune_oldest_paired_devices(
    paired_by_device_id: &mut HashMap<String, PairedDeviceEntry>,
    max_devices: usize,
) {
    while paired_by_device_id.len() > max_devices {
        let Some(oldest_key) = paired_by_device_id
            .iter()
            .min_by_key(|(_, device)| device.approved_at_ms)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = paired_by_device_id.remove(&oldest_key);
    }
}

fn next_device_auth_token(device_id: &str, role: &str) -> String {
    use sha2::{Digest, Sha256};
    let sequence = DEVICE_TOKEN_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    let mut hasher = Sha256::new();
    hasher.update(device_id.as_bytes());
    hasher.update(role.as_bytes());
    hasher.update(now_ms().to_le_bytes());
    hasher.update(sequence.to_le_bytes());
    let digest = format!("{:x}", hasher.finalize());
    format!("dtk_{}", &digest[..48])
}

struct WebLoginRegistry {
    state: Mutex<WebLoginState>,
    runtime: Mutex<WebLoginRuntimeState>,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
struct WebLoginState {
    sessions: HashMap<String, WebLoginSession>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct WebLoginSession {
    #[serde(rename = "sessionId")]
    session_id: String,
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "accountId")]
    account_id: String,
    #[serde(rename = "startedAtMs")]
    started_at_ms: u64,
    #[serde(rename = "readyAtMs")]
    ready_at_ms: u64,
    #[serde(rename = "expiresAtMs")]
    expires_at_ms: u64,
    #[serde(rename = "qrDataUrl")]
    qr_data_url: String,
    verbose: bool,
}

#[derive(Debug, Clone)]
struct WebLoginRuntimeState {
    store_path: String,
}

#[derive(Debug, Clone)]
struct WebLoginStartInput {
    provider_id: String,
    account_id: String,
    force: bool,
    verbose: bool,
    timeout_ms: u64,
}

#[derive(Debug, Clone)]
struct WebLoginWaitInput {
    provider_id: String,
    account_id: String,
    timeout_ms: u64,
}

#[derive(Debug, Clone, serde::Serialize)]
struct WebLoginStartResult {
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "accountId")]
    account_id: String,
    #[serde(rename = "sessionId")]
    session_id: String,
    #[serde(rename = "startedAtMs")]
    started_at_ms: u64,
    #[serde(rename = "expiresAtMs")]
    expires_at_ms: u64,
    #[serde(rename = "qrDataUrl")]
    qr_data_url: String,
    message: String,
    verbose: bool,
}

#[derive(Debug, Clone, serde::Serialize)]
struct WebLoginWaitResult {
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "accountId")]
    account_id: String,
    connected: bool,
    message: String,
}

impl WebLoginRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(WebLoginState {
                sessions: HashMap::new(),
            }),
            runtime: Mutex::new(WebLoginRuntimeState {
                store_path: WEB_LOGIN_STORE_PATH.to_owned(),
            }),
        }
    }

    async fn apply_runtime_config(&self, runtime: WebLoginRuntimeConfig) -> Result<(), String> {
        let target_store_path = runtime
            .store_path
            .and_then(|value| normalize_optional_text(Some(value), 2048))
            .unwrap_or_else(|| WEB_LOGIN_STORE_PATH.to_owned());

        let current_store_path = { self.runtime.lock().await.store_path.clone() };
        if current_store_path == target_store_path {
            return Ok(());
        }

        let mut loaded = load_web_login_store_disk_state(&target_store_path)?;
        prune_oldest_web_login_sessions(&mut loaded.sessions, 64);
        {
            let mut guard = self.state.lock().await;
            *guard = loaded.clone();
        }
        {
            let mut runtime_guard = self.runtime.lock().await;
            runtime_guard.store_path = target_store_path.clone();
        }
        persist_web_login_store_disk_state(&target_store_path, &loaded)?;
        Ok(())
    }

    async fn persist_state_snapshot(&self, state: WebLoginState) -> Result<(), String> {
        let store_path = { self.runtime.lock().await.store_path.clone() };
        persist_web_login_store_disk_state(&store_path, &state)
    }

    async fn start(&self, input: WebLoginStartInput) -> WebLoginStartResult {
        let now = now_ms();
        let timeout_ms = input.timeout_ms.max(5_000);
        let key = format!(
            "{}:{}",
            normalize(&input.provider_id),
            normalize(&input.account_id)
        );
        let (result, snapshot) = {
            let mut guard = self.state.lock().await;
            if !input.force {
                if let Some(existing) = guard.sessions.get(&key) {
                    if now <= existing.expires_at_ms {
                        return WebLoginStartResult {
                            provider_id: existing.provider_id.clone(),
                            account_id: existing.account_id.clone(),
                            session_id: existing.session_id.clone(),
                            started_at_ms: existing.started_at_ms,
                            expires_at_ms: existing.expires_at_ms,
                            qr_data_url: existing.qr_data_url.clone(),
                            message: "QR already active. Scan it in WhatsApp -> Linked Devices."
                                .to_owned(),
                            verbose: existing.verbose,
                        };
                    }
                }
            }

            let session_id = next_web_login_session_id();
            let started_at_ms = now;
            let expires_at_ms = now.saturating_add(timeout_ms.max(60_000));
            let ready_at_ms = now.saturating_add(timeout_ms.min(3_000));
            let qr_data_url = format!(
                "data:image/png;base64,cnVzdC1wYXJpdHktd2ViLWxvZ2luLXNlc3Npb24t{}",
                session_id
            );
            let session = WebLoginSession {
                session_id: session_id.clone(),
                provider_id: input.provider_id.clone(),
                account_id: input.account_id.clone(),
                started_at_ms,
                ready_at_ms,
                expires_at_ms,
                qr_data_url: qr_data_url.clone(),
                verbose: input.verbose,
            };
            guard.sessions.insert(key, session);
            prune_oldest_web_login_sessions(&mut guard.sessions, 64);
            (
                WebLoginStartResult {
                    provider_id: input.provider_id,
                    account_id: input.account_id,
                    session_id,
                    started_at_ms,
                    expires_at_ms,
                    qr_data_url,
                    message: "Scan this QR in WhatsApp -> Linked Devices.".to_owned(),
                    verbose: input.verbose,
                },
                guard.clone(),
            )
        };
        let _ = self.persist_state_snapshot(snapshot).await;
        result
    }

    async fn wait(&self, input: WebLoginWaitInput) -> WebLoginWaitResult {
        let now = now_ms();
        let timeout_ms = input.timeout_ms.max(1_000);
        let key = format!(
            "{}:{}",
            normalize(&input.provider_id),
            normalize(&input.account_id)
        );
        let (result, snapshot) = {
            let mut guard = self.state.lock().await;
            let Some(session) = guard.sessions.get(&key).cloned() else {
                return WebLoginWaitResult {
                    provider_id: input.provider_id,
                    account_id: input.account_id,
                    connected: false,
                    message: "No active WhatsApp login in progress.".to_owned(),
                };
            };
            if now > session.expires_at_ms {
                let _ = guard.sessions.remove(&key);
                (
                    WebLoginWaitResult {
                        provider_id: input.provider_id,
                        account_id: input.account_id,
                        connected: false,
                        message: "The login QR expired. Ask me to generate a new one.".to_owned(),
                    },
                    Some(guard.clone()),
                )
            } else if now.saturating_add(timeout_ms) >= session.ready_at_ms {
                let _ = guard.sessions.remove(&key);
                (
                    WebLoginWaitResult {
                        provider_id: input.provider_id,
                        account_id: input.account_id,
                        connected: true,
                        message: "Linked! Channel account is ready.".to_owned(),
                    },
                    Some(guard.clone()),
                )
            } else {
                (
                    WebLoginWaitResult {
                        provider_id: input.provider_id,
                        account_id: input.account_id,
                        connected: false,
                        message:
                            "Still waiting for the QR scan. Let me know when you've scanned it."
                                .to_owned(),
                    },
                    None,
                )
            }
        };
        if let Some(snapshot) = snapshot {
            let _ = self.persist_state_snapshot(snapshot).await;
        }
        result
    }
}

fn prune_oldest_web_login_sessions(
    sessions: &mut HashMap<String, WebLoginSession>,
    max_sessions: usize,
) {
    while sessions.len() > max_sessions {
        let Some(oldest_key) = sessions
            .iter()
            .min_by_key(|(_, entry)| entry.started_at_ms)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = sessions.remove(&oldest_key);
    }
}

fn web_login_store_path_is_memory(path: &str) -> bool {
    normalize(path).starts_with("memory://")
}

fn load_web_login_store_disk_state(path: &str) -> Result<WebLoginState, String> {
    if web_login_store_path_is_memory(path) {
        return Ok(WebLoginState::default());
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(WebLoginState::default());
    }
    let raw = std::fs::read_to_string(&store_path).map_err(|err| {
        format!(
            "failed reading web login store {}: {err}",
            store_path.display()
        )
    })?;
    let parsed: WebLoginState = serde_json::from_str(&raw).map_err(|err| {
        format!(
            "failed parsing web login store {}: {err}",
            store_path.display()
        )
    })?;
    Ok(parsed)
}

fn persist_web_login_store_disk_state(path: &str, state: &WebLoginState) -> Result<(), String> {
    if web_login_store_path_is_memory(path) {
        return Ok(());
    }
    let payload = serde_json::to_string_pretty(state)
        .map_err(|err| format!("failed serializing web login store: {err}"))?;
    let store_path = PathBuf::from(path);
    if let Some(parent) = store_path.parent() {
        std::fs::create_dir_all(parent).map_err(|err| {
            format!(
                "failed creating web login store directory {}: {err}",
                parent.display()
            )
        })?;
    }
    let mut temp_path = store_path.clone();
    let temp_name = format!(
        ".{}.tmp",
        store_path
            .file_name()
            .and_then(|name| name.to_str())
            .unwrap_or("web-login-store")
    );
    temp_path.set_file_name(temp_name);
    std::fs::write(&temp_path, payload).map_err(|err| {
        format!(
            "failed writing web login temp store {}: {err}",
            temp_path.display()
        )
    })?;
    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        format!(
            "failed replacing web login store {}: {err}",
            store_path.display()
        )
    })
}

struct OAuthRegistry {
    state: Mutex<OAuthState>,
    runtime: Mutex<OAuthRuntimeState>,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
struct OAuthState {
    sessions: HashMap<String, OAuthSession>,
    credentials: HashMap<String, OAuthCredential>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct OAuthSession {
    #[serde(rename = "sessionId")]
    session_id: String,
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "accountId")]
    account_id: String,
    #[serde(rename = "profileId")]
    profile_id: String,
    #[serde(rename = "startedAtMs")]
    started_at_ms: u64,
    #[serde(rename = "readyAtMs")]
    ready_at_ms: u64,
    #[serde(rename = "expiresAtMs")]
    expires_at_ms: u64,
    #[serde(rename = "verificationUrl")]
    verification_url: String,
    #[serde(rename = "userCode")]
    user_code: String,
    #[serde(rename = "completedAtMs", skip_serializing_if = "Option::is_none")]
    completed_at_ms: Option<u64>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct OAuthCredential {
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "accountId")]
    account_id: String,
    #[serde(rename = "profileId")]
    profile_id: String,
    #[serde(rename = "accessToken", skip_serializing_if = "Option::is_none")]
    access_token: Option<String>,
    #[serde(rename = "refreshToken", skip_serializing_if = "Option::is_none")]
    refresh_token: Option<String>,
    #[serde(rename = "tokenType", skip_serializing_if = "Option::is_none")]
    token_type: Option<String>,
    #[serde(rename = "expiresAtMs", skip_serializing_if = "Option::is_none")]
    expires_at_ms: Option<u64>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    scopes: Vec<String>,
    source: String,
    #[serde(rename = "updatedAtMs")]
    updated_at_ms: u64,
}

#[derive(Debug, Clone)]
struct OAuthRuntimeState {
    store_path: String,
}

#[derive(Debug, Clone)]
struct OAuthStartInput {
    provider_id: String,
    account_id: String,
    timeout_ms: u64,
    force: bool,
}

#[derive(Debug, Clone)]
struct OAuthWaitInput {
    provider_id: Option<String>,
    account_id: Option<String>,
    session_id: Option<String>,
    timeout_ms: u64,
}

#[derive(Debug, Clone)]
struct OAuthCompleteInput {
    session_id: String,
    account_id: Option<String>,
    access_token: Option<String>,
    refresh_token: Option<String>,
    token_type: Option<String>,
    expires_at_ms: Option<u64>,
    scopes: Vec<String>,
    source: Option<String>,
}

#[derive(Debug, Clone)]
struct OAuthLogoutInput {
    provider_id: Option<String>,
    account_id: Option<String>,
    all: bool,
}

#[derive(Debug, Clone)]
struct OAuthImportInput {
    providers: Vec<String>,
    home_dir: Option<String>,
    codex_home: Option<String>,
    overwrite: bool,
}

#[derive(Debug, Clone, serde::Serialize)]
struct OAuthCredentialView {
    #[serde(rename = "accountId")]
    account_id: String,
    #[serde(rename = "profileId")]
    profile_id: String,
    source: String,
    #[serde(rename = "updatedAtMs")]
    updated_at_ms: u64,
    #[serde(rename = "expiresAtMs", skip_serializing_if = "Option::is_none")]
    expires_at_ms: Option<u64>,
    #[serde(rename = "accessTokenPreview", skip_serializing_if = "Option::is_none")]
    access_token_preview: Option<String>,
    #[serde(rename = "refreshTokenPresent")]
    refresh_token_present: bool,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    scopes: Vec<String>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct AuthOAuthProvidersResult {
    #[serde(rename = "generatedAtMs")]
    generated_at_ms: u64,
    providers: Vec<OAuthProviderView>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct OAuthProviderView {
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "displayName")]
    display_name: String,
    #[serde(rename = "verificationUrl")]
    verification_url: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    aliases: Vec<String>,
    #[serde(rename = "connectedAccounts")]
    connected_accounts: usize,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    accounts: Vec<OAuthCredentialView>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct OAuthStartResult {
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "accountId")]
    account_id: String,
    #[serde(rename = "profileId")]
    profile_id: String,
    #[serde(rename = "sessionId")]
    session_id: String,
    #[serde(rename = "startedAtMs")]
    started_at_ms: u64,
    #[serde(rename = "expiresAtMs")]
    expires_at_ms: u64,
    #[serde(rename = "verificationUrl")]
    verification_url: String,
    #[serde(rename = "userCode")]
    user_code: String,
    #[serde(rename = "pollIntervalMs")]
    poll_interval_ms: u64,
    message: String,
}

#[derive(Debug, Clone, serde::Serialize)]
struct OAuthWaitResult {
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "accountId")]
    account_id: String,
    #[serde(rename = "sessionId", skip_serializing_if = "Option::is_none")]
    session_id: Option<String>,
    connected: bool,
    #[serde(rename = "profileId", skip_serializing_if = "Option::is_none")]
    profile_id: Option<String>,
    status: String,
    message: String,
    #[serde(rename = "retryAfterMs", skip_serializing_if = "Option::is_none")]
    retry_after_ms: Option<u64>,
    #[serde(rename = "expiresAtMs", skip_serializing_if = "Option::is_none")]
    expires_at_ms: Option<u64>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct OAuthCompleteResult {
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "accountId")]
    account_id: String,
    #[serde(rename = "profileId")]
    profile_id: String,
    connected: bool,
    source: String,
    #[serde(rename = "updatedAtMs")]
    updated_at_ms: u64,
    #[serde(rename = "expiresAtMs", skip_serializing_if = "Option::is_none")]
    expires_at_ms: Option<u64>,
    #[serde(rename = "accessTokenPreview", skip_serializing_if = "Option::is_none")]
    access_token_preview: Option<String>,
    #[serde(rename = "refreshTokenPresent")]
    refresh_token_present: bool,
}

#[derive(Debug, Clone, serde::Serialize)]
struct OAuthLogoutResult {
    #[serde(rename = "providerId")]
    provider_id: String,
    #[serde(rename = "accountId", skip_serializing_if = "Option::is_none")]
    account_id: Option<String>,
    removed: usize,
    #[serde(rename = "revokedSessions")]
    revoked_sessions: usize,
}

#[derive(Debug, Clone, serde::Serialize)]
struct OAuthImportResult {
    #[serde(rename = "requestedCount")]
    requested_count: usize,
    #[serde(rename = "importedCount")]
    imported_count: usize,
    #[serde(rename = "skippedCount")]
    skipped_count: usize,
    results: Vec<OAuthImportProviderResult>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct OAuthImportProviderResult {
    #[serde(rename = "providerId")]
    provider_id: String,
    imported: bool,
    #[serde(rename = "accountId", skip_serializing_if = "Option::is_none")]
    account_id: Option<String>,
    #[serde(rename = "profileId", skip_serializing_if = "Option::is_none")]
    profile_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    source: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    reason: Option<String>,
}

#[derive(Debug, Clone)]
struct OAuthImportedCredential {
    provider_id: String,
    account_id: String,
    profile_id: String,
    source: String,
    access_token: Option<String>,
    refresh_token: Option<String>,
    token_type: Option<String>,
    expires_at_ms: Option<u64>,
    scopes: Vec<String>,
}

impl OAuthRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(OAuthState {
                sessions: HashMap::new(),
                credentials: HashMap::new(),
            }),
            runtime: Mutex::new(OAuthRuntimeState {
                store_path: OAUTH_STORE_PATH.to_owned(),
            }),
        }
    }

    async fn apply_runtime_config(&self, runtime: OAuthRuntimeConfig) -> Result<(), String> {
        let target_store_path = runtime
            .store_path
            .and_then(|value| normalize_optional_text(Some(value), 2048))
            .unwrap_or_else(|| OAUTH_STORE_PATH.to_owned());

        let current_store_path = { self.runtime.lock().await.store_path.clone() };
        if current_store_path == target_store_path {
            return Ok(());
        }

        let mut loaded = load_oauth_store_disk_state(&target_store_path)?;
        prune_oldest_oauth_sessions(&mut loaded.sessions, 128);
        prune_oldest_oauth_credentials(&mut loaded.credentials, 256);
        {
            let mut guard = self.state.lock().await;
            *guard = loaded.clone();
        }
        {
            let mut runtime_guard = self.runtime.lock().await;
            runtime_guard.store_path = target_store_path.clone();
        }
        persist_oauth_store_disk_state(&target_store_path, &loaded)?;
        Ok(())
    }

    async fn persist_state_snapshot(&self, state: OAuthState) -> Result<(), String> {
        let store_path = { self.runtime.lock().await.store_path.clone() };
        persist_oauth_store_disk_state(&store_path, &state)
    }

    async fn providers(&self) -> AuthOAuthProvidersResult {
        let guard = self.state.lock().await;
        let mut provider_ids = OAUTH_PROVIDER_CATALOG
            .iter()
            .map(|entry| entry.id.to_owned())
            .collect::<Vec<_>>();
        provider_ids.extend(
            guard
                .credentials
                .values()
                .map(|credential| credential.provider_id.clone()),
        );
        sort_and_dedup_strings(&mut provider_ids);

        let mut providers = Vec::new();
        for provider_id in provider_ids {
            let mut accounts = guard
                .credentials
                .values()
                .filter(|credential| credential.provider_id.eq_ignore_ascii_case(&provider_id))
                .map(oauth_credential_view_from_entry)
                .collect::<Vec<_>>();
            accounts.sort_by(|a, b| {
                let account = a.account_id.cmp(&b.account_id);
                if account != std::cmp::Ordering::Equal {
                    return account;
                }
                a.profile_id.cmp(&b.profile_id)
            });

            providers.push(OAuthProviderView {
                provider_id: provider_id.clone(),
                display_name: oauth_provider_display_name(&provider_id),
                verification_url: oauth_provider_verification_url(&provider_id),
                aliases: oauth_provider_aliases(&provider_id),
                connected_accounts: accounts.len(),
                accounts,
            });
        }
        providers.sort_by(|a, b| a.provider_id.cmp(&b.provider_id));

        AuthOAuthProvidersResult {
            generated_at_ms: now_ms(),
            providers,
        }
    }

    async fn start(&self, input: OAuthStartInput) -> Result<OAuthStartResult, String> {
        let provider_id = normalize_oauth_provider_id(&input.provider_id)
            .ok_or_else(|| "provider must be a non-empty string".to_owned())?;
        let account_id = normalize_optional_text(Some(input.account_id), 128)
            .ok_or_else(|| "accountId must be a non-empty string".to_owned())?;
        let key = oauth_state_key(&provider_id, &account_id);
        let now = now_ms();
        let timeout_ms = input.timeout_ms.clamp(15_000, 900_000);

        let (result, snapshot) = {
            let mut guard = self.state.lock().await;
            if !input.force {
                if let Some(existing) = guard.sessions.get(&key) {
                    if now <= existing.expires_at_ms {
                        return Ok(OAuthStartResult {
                            provider_id: existing.provider_id.clone(),
                            account_id: existing.account_id.clone(),
                            profile_id: existing.profile_id.clone(),
                            session_id: existing.session_id.clone(),
                            started_at_ms: existing.started_at_ms,
                            expires_at_ms: existing.expires_at_ms,
                            verification_url: existing.verification_url.clone(),
                            user_code: existing.user_code.clone(),
                            poll_interval_ms: 2_000,
                            message: "OAuth session already in progress.".to_owned(),
                        });
                    }
                }
            }

            let session_id = next_oauth_session_id();
            let profile_id = oauth_default_profile_id(&provider_id, &account_id);
            let started_at_ms = now;
            let ready_at_ms = now.saturating_add(timeout_ms.min(2_000));
            let expires_at_ms = now.saturating_add(timeout_ms);
            let verification_url = oauth_provider_verification_url(&provider_id);
            let session = OAuthSession {
                session_id: session_id.clone(),
                provider_id: provider_id.clone(),
                account_id: account_id.clone(),
                profile_id: profile_id.clone(),
                started_at_ms,
                ready_at_ms,
                expires_at_ms,
                verification_url: verification_url.clone(),
                user_code: oauth_user_code(&provider_id, &session_id),
                completed_at_ms: None,
            };
            let user_code = session.user_code.clone();
            guard.sessions.insert(key, session);
            prune_oldest_oauth_sessions(&mut guard.sessions, 128);
            (
                OAuthStartResult {
                    provider_id,
                    account_id,
                    profile_id,
                    session_id,
                    started_at_ms,
                    expires_at_ms,
                    verification_url,
                    user_code,
                    poll_interval_ms: 2_000,
                    message: "Open the verification URL and approve the device code.".to_owned(),
                },
                guard.clone(),
            )
        };
        let _ = self.persist_state_snapshot(snapshot).await;
        Ok(result)
    }

    async fn wait(&self, input: OAuthWaitInput) -> Result<OAuthWaitResult, String> {
        let now = now_ms();
        let timeout_ms = input.timeout_ms.max(1_000);
        let requested_provider = input
            .provider_id
            .and_then(|provider| normalize_oauth_provider_id(&provider));
        let requested_account = normalize_optional_text(input.account_id, 128);
        let requested_session_id = normalize_optional_text(input.session_id, 128);

        let (result, snapshot) = {
            let mut guard = self.state.lock().await;
            let (provider_id, account_id, session_id, session_key, session) =
                if let Some(session_id) = requested_session_id.clone() {
                    match guard
                        .sessions
                        .iter()
                        .find(|(_, session)| session.session_id.eq_ignore_ascii_case(&session_id))
                        .map(|(key, session)| (key.clone(), session.clone()))
                    {
                        Some((key, session)) => (
                            session.provider_id.clone(),
                            session.account_id.clone(),
                            Some(session.session_id.clone()),
                            Some(key),
                            Some(session),
                        ),
                        None => {
                            if let Some(provider_id) = requested_provider.clone() {
                                let account_id = requested_account
                                    .clone()
                                    .unwrap_or_else(|| "default".to_owned());
                                (provider_id, account_id, Some(session_id), None, None)
                            } else {
                                return Err(
                                    "invalid auth.oauth.wait params: unknown sessionId".to_owned()
                                );
                            }
                        }
                    }
                } else {
                    let Some(provider_id) = requested_provider.clone() else {
                        return Err(
                            "invalid auth.oauth.wait params: provider or sessionId required"
                                .to_owned(),
                        );
                    };
                    let account_id = requested_account
                        .clone()
                        .unwrap_or_else(|| "default".to_owned());
                    let key = oauth_state_key(&provider_id, &account_id);
                    let session = guard.sessions.get(&key).cloned();
                    let session_id = session.as_ref().map(|entry| entry.session_id.clone());
                    (provider_id, account_id, session_id, Some(key), session)
                };

            let credential_key = oauth_state_key(&provider_id, &account_id);
            let credential = guard.credentials.get(&credential_key).cloned();
            if let Some(credential) = credential {
                if let Some(key) = session_key {
                    let _ = guard.sessions.remove(&key);
                }
                (
                    OAuthWaitResult {
                        provider_id,
                        account_id,
                        session_id,
                        connected: true,
                        profile_id: Some(credential.profile_id),
                        status: "connected".to_owned(),
                        message: "OAuth credential is available.".to_owned(),
                        retry_after_ms: None,
                        expires_at_ms: credential.expires_at_ms,
                    },
                    Some(guard.clone()),
                )
            } else if let Some(session) = session {
                if now > session.expires_at_ms {
                    if let Some(key) = session_key {
                        let _ = guard.sessions.remove(&key);
                    }
                    (
                        OAuthWaitResult {
                            provider_id,
                            account_id,
                            session_id: Some(session.session_id),
                            connected: false,
                            profile_id: None,
                            status: "expired".to_owned(),
                            message: "OAuth session expired. Start a new login flow.".to_owned(),
                            retry_after_ms: None,
                            expires_at_ms: Some(session.expires_at_ms),
                        },
                        Some(guard.clone()),
                    )
                } else {
                    let retry_after_ms = if now.saturating_add(timeout_ms) >= session.ready_at_ms {
                        Some(1_000)
                    } else {
                        Some(
                            session
                                .ready_at_ms
                                .saturating_sub(now)
                                .clamp(1_000, timeout_ms),
                        )
                    };
                    (
                        OAuthWaitResult {
                            provider_id,
                            account_id,
                            session_id: Some(session.session_id),
                            connected: false,
                            profile_id: None,
                            status: "pending".to_owned(),
                            message: "OAuth session still waiting for completion.".to_owned(),
                            retry_after_ms,
                            expires_at_ms: Some(session.expires_at_ms),
                        },
                        None,
                    )
                }
            } else {
                (
                    OAuthWaitResult {
                        provider_id,
                        account_id,
                        session_id,
                        connected: false,
                        profile_id: None,
                        status: "missing".to_owned(),
                        message: "No active OAuth session for provider/account.".to_owned(),
                        retry_after_ms: None,
                        expires_at_ms: None,
                    },
                    None,
                )
            }
        };

        if let Some(snapshot) = snapshot {
            let _ = self.persist_state_snapshot(snapshot).await;
        }
        Ok(result)
    }

    async fn complete(&self, input: OAuthCompleteInput) -> Result<OAuthCompleteResult, String> {
        let session_id = normalize_optional_text(Some(input.session_id), 128)
            .ok_or_else(|| "sessionId must be a non-empty string".to_owned())?;
        let now = now_ms();
        let (result, snapshot) = {
            let mut guard = self.state.lock().await;
            let Some((session_key, session)) = guard
                .sessions
                .iter()
                .find(|(_, session)| session.session_id.eq_ignore_ascii_case(&session_id))
                .map(|(key, session)| (key.clone(), session.clone()))
            else {
                return Err("unknown oauth session".to_owned());
            };
            if now > session.expires_at_ms {
                let _ = guard.sessions.remove(&session_key);
                return Err("oauth session expired".to_owned());
            }

            let account_id = input
                .account_id
                .and_then(|value| normalize_optional_text(Some(value), 128))
                .unwrap_or_else(|| session.account_id.clone());
            let provider_id = session.provider_id.clone();
            let profile_id = oauth_default_profile_id(&provider_id, &account_id);
            let source = input
                .source
                .unwrap_or_else(|| "oauth-device-flow".to_owned());
            let credential = OAuthCredential {
                provider_id: provider_id.clone(),
                account_id: account_id.clone(),
                profile_id: profile_id.clone(),
                access_token: input
                    .access_token
                    .or_else(|| Some(format!("oauth-session-{session_id}"))),
                refresh_token: input.refresh_token,
                token_type: input.token_type,
                expires_at_ms: input.expires_at_ms,
                scopes: input.scopes,
                source: source.clone(),
                updated_at_ms: now,
            };
            guard.credentials.insert(
                oauth_state_key(&provider_id, &account_id),
                credential.clone(),
            );
            if let Some(entry) = guard.sessions.get_mut(&session_key) {
                entry.completed_at_ms = Some(now);
                entry.account_id = account_id.clone();
                entry.profile_id = profile_id.clone();
            }
            prune_oldest_oauth_credentials(&mut guard.credentials, 256);
            (
                OAuthCompleteResult {
                    provider_id,
                    account_id,
                    profile_id,
                    connected: true,
                    source,
                    updated_at_ms: now,
                    expires_at_ms: credential.expires_at_ms,
                    access_token_preview: oauth_token_preview(credential.access_token.as_ref()),
                    refresh_token_present: credential.refresh_token.is_some(),
                },
                guard.clone(),
            )
        };
        let _ = self.persist_state_snapshot(snapshot).await;
        Ok(result)
    }

    async fn logout(&self, input: OAuthLogoutInput) -> OAuthLogoutResult {
        let provider_id = input
            .provider_id
            .and_then(|provider| normalize_oauth_provider_id(&provider));
        let account_id = input
            .account_id
            .and_then(|account| normalize_optional_text(Some(account), 128));
        let (result, snapshot) = {
            let mut guard = self.state.lock().await;
            let mut removed = 0usize;
            let mut revoked_sessions = 0usize;

            if input.all || provider_id.is_none() {
                removed = guard.credentials.len();
                revoked_sessions = guard.sessions.len();
                guard.credentials.clear();
                guard.sessions.clear();
            } else if let Some(provider_id) = provider_id.clone() {
                if let Some(account_id) = account_id.clone() {
                    let key = oauth_state_key(&provider_id, &account_id);
                    if guard.credentials.remove(&key).is_some() {
                        removed = removed.saturating_add(1);
                    }
                    if guard.sessions.remove(&key).is_some() {
                        revoked_sessions = revoked_sessions.saturating_add(1);
                    }
                } else {
                    let credential_keys = guard
                        .credentials
                        .iter()
                        .filter(|(_, credential)| {
                            credential.provider_id.eq_ignore_ascii_case(&provider_id)
                        })
                        .map(|(key, _)| key.clone())
                        .collect::<Vec<_>>();
                    for key in credential_keys {
                        let _ = guard.credentials.remove(&key);
                        removed = removed.saturating_add(1);
                    }

                    let session_keys = guard
                        .sessions
                        .iter()
                        .filter(|(_, session)| {
                            session.provider_id.eq_ignore_ascii_case(&provider_id)
                        })
                        .map(|(key, _)| key.clone())
                        .collect::<Vec<_>>();
                    for key in session_keys {
                        let _ = guard.sessions.remove(&key);
                        revoked_sessions = revoked_sessions.saturating_add(1);
                    }
                }
            }

            (
                OAuthLogoutResult {
                    provider_id: provider_id.unwrap_or_else(|| "all".to_owned()),
                    account_id,
                    removed,
                    revoked_sessions,
                },
                guard.clone(),
            )
        };
        let _ = self.persist_state_snapshot(snapshot).await;
        result
    }

    async fn import(&self, input: OAuthImportInput) -> OAuthImportResult {
        let mut requested = input
            .providers
            .iter()
            .filter_map(|provider| normalize_oauth_provider_id(provider))
            .collect::<Vec<_>>();
        if requested.is_empty() {
            requested = vec![
                "openai-codex".to_owned(),
                "anthropic".to_owned(),
                "google-gemini-cli".to_owned(),
                "qwen-portal".to_owned(),
                "minimax-portal".to_owned(),
            ];
        }
        sort_and_dedup_strings(&mut requested);

        let mut candidates: Vec<(String, Result<Option<OAuthImportedCredential>, String>)> =
            Vec::new();
        for provider_id in &requested {
            let candidate = match provider_id.as_str() {
                "openai-codex" => read_codex_cli_oauth_credential(
                    input.home_dir.as_deref(),
                    input.codex_home.as_deref(),
                ),
                "anthropic" => read_claude_cli_oauth_credential(input.home_dir.as_deref()),
                "google-gemini-cli" => read_gemini_cli_oauth_credential(input.home_dir.as_deref()),
                "qwen-portal" => read_portal_cli_oauth_credential(
                    input.home_dir.as_deref(),
                    ".qwen/oauth_creds.json",
                    "qwen-portal",
                    "qwen-cli",
                ),
                "minimax-portal" => read_portal_cli_oauth_credential(
                    input.home_dir.as_deref(),
                    ".minimax/oauth_creds.json",
                    "minimax-portal",
                    "minimax-cli",
                ),
                _ => Err("no CLI import source is defined for this provider".to_owned()),
            };
            candidates.push((provider_id.clone(), candidate));
        }

        let mut results = Vec::new();
        let mut imported_count = 0usize;
        let mut skipped_count = 0usize;

        let snapshot = {
            let mut guard = self.state.lock().await;
            for (provider_id, candidate) in candidates {
                match candidate {
                    Ok(Some(credential)) => {
                        let state_key =
                            oauth_state_key(&credential.provider_id, &credential.account_id);
                        if !input.overwrite && guard.credentials.contains_key(&state_key) {
                            skipped_count = skipped_count.saturating_add(1);
                            results.push(OAuthImportProviderResult {
                                provider_id,
                                imported: false,
                                account_id: Some(credential.account_id),
                                profile_id: Some(credential.profile_id),
                                source: Some(credential.source),
                                reason: Some(
                                    "credential already exists (set overwrite=true to replace)"
                                        .to_owned(),
                                ),
                            });
                            continue;
                        }
                        let stored = OAuthCredential {
                            provider_id: credential.provider_id.clone(),
                            account_id: credential.account_id.clone(),
                            profile_id: credential.profile_id.clone(),
                            access_token: credential.access_token,
                            refresh_token: credential.refresh_token,
                            token_type: credential.token_type,
                            expires_at_ms: credential.expires_at_ms,
                            scopes: credential.scopes,
                            source: credential.source.clone(),
                            updated_at_ms: now_ms(),
                        };
                        guard.credentials.insert(state_key, stored);
                        prune_oldest_oauth_credentials(&mut guard.credentials, 256);
                        imported_count = imported_count.saturating_add(1);
                        results.push(OAuthImportProviderResult {
                            provider_id,
                            imported: true,
                            account_id: Some(credential.account_id),
                            profile_id: Some(credential.profile_id),
                            source: Some(credential.source),
                            reason: None,
                        });
                    }
                    Ok(None) => {
                        skipped_count = skipped_count.saturating_add(1);
                        results.push(OAuthImportProviderResult {
                            provider_id,
                            imported: false,
                            account_id: None,
                            profile_id: None,
                            source: None,
                            reason: Some("no credential file found".to_owned()),
                        });
                    }
                    Err(reason) => {
                        skipped_count = skipped_count.saturating_add(1);
                        results.push(OAuthImportProviderResult {
                            provider_id,
                            imported: false,
                            account_id: None,
                            profile_id: None,
                            source: None,
                            reason: Some(reason),
                        });
                    }
                }
            }
            guard.clone()
        };

        if imported_count > 0 {
            let _ = self.persist_state_snapshot(snapshot).await;
        }

        OAuthImportResult {
            requested_count: requested.len(),
            imported_count,
            skipped_count,
            results,
        }
    }
}

fn oauth_credential_view_from_entry(entry: &OAuthCredential) -> OAuthCredentialView {
    OAuthCredentialView {
        account_id: entry.account_id.clone(),
        profile_id: entry.profile_id.clone(),
        source: entry.source.clone(),
        updated_at_ms: entry.updated_at_ms,
        expires_at_ms: entry.expires_at_ms,
        access_token_preview: oauth_token_preview(entry.access_token.as_ref()),
        refresh_token_present: entry.refresh_token.is_some(),
        scopes: entry.scopes.clone(),
    }
}

fn oauth_state_key(provider_id: &str, account_id: &str) -> String {
    format!("{}:{}", normalize(provider_id), normalize(account_id))
}

fn oauth_user_code(provider_id: &str, session_id: &str) -> String {
    let provider = normalize(provider_id)
        .chars()
        .filter(|ch| ch.is_ascii_alphanumeric())
        .take(4)
        .collect::<String>()
        .to_ascii_uppercase();
    let suffix = session_id
        .chars()
        .rev()
        .filter(|ch| ch.is_ascii_alphanumeric())
        .take(6)
        .collect::<String>()
        .chars()
        .rev()
        .collect::<String>()
        .to_ascii_uppercase();
    format!(
        "{}-{}",
        if provider.is_empty() {
            "OAUTH"
        } else {
            provider.as_str()
        },
        if suffix.is_empty() {
            "000000"
        } else {
            suffix.as_str()
        }
    )
}

fn prune_oldest_oauth_sessions(sessions: &mut HashMap<String, OAuthSession>, max_sessions: usize) {
    while sessions.len() > max_sessions {
        let Some(oldest_key) = sessions
            .iter()
            .min_by_key(|(_, entry)| entry.started_at_ms)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = sessions.remove(&oldest_key);
    }
}

fn prune_oldest_oauth_credentials(
    credentials: &mut HashMap<String, OAuthCredential>,
    max_credentials: usize,
) {
    while credentials.len() > max_credentials {
        let Some(oldest_key) = credentials
            .iter()
            .min_by_key(|(_, entry)| entry.updated_at_ms)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = credentials.remove(&oldest_key);
    }
}

fn oauth_store_path_is_memory(path: &str) -> bool {
    normalize(path).starts_with("memory://")
}

fn load_oauth_store_disk_state(path: &str) -> Result<OAuthState, String> {
    if oauth_store_path_is_memory(path) {
        return Ok(OAuthState::default());
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(OAuthState::default());
    }
    let raw = std::fs::read_to_string(&store_path)
        .map_err(|err| format!("failed reading oauth store {}: {err}", store_path.display()))?;
    serde_json::from_str::<OAuthState>(&raw)
        .map_err(|err| format!("failed parsing oauth store {}: {err}", store_path.display()))
}

fn persist_oauth_store_disk_state(path: &str, state: &OAuthState) -> Result<(), String> {
    if oauth_store_path_is_memory(path) {
        return Ok(());
    }
    let payload = serde_json::to_string_pretty(state)
        .map_err(|err| format!("failed serializing oauth store: {err}"))?;
    let store_path = PathBuf::from(path);
    if let Some(parent) = store_path.parent() {
        std::fs::create_dir_all(parent).map_err(|err| {
            format!(
                "failed creating oauth store directory {}: {err}",
                parent.display()
            )
        })?;
    }
    let mut temp_path = store_path.clone();
    let temp_name = format!(
        ".{}.tmp",
        store_path
            .file_name()
            .and_then(|name| name.to_str())
            .unwrap_or("oauth-store")
    );
    temp_path.set_file_name(temp_name);
    std::fs::write(&temp_path, payload).map_err(|err| {
        format!(
            "failed writing oauth temp store {}: {err}",
            temp_path.display()
        )
    })?;
    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        format!(
            "failed replacing oauth store {}: {err}",
            store_path.display()
        )
    })
}

fn resolve_home_path(home_override: Option<&str>) -> Option<PathBuf> {
    if let Some(raw) =
        home_override.and_then(|value| normalize_optional_text(Some(value.to_owned()), 2048))
    {
        return Some(PathBuf::from(raw));
    }
    env::var("HOME")
        .ok()
        .and_then(|value| normalize_optional_text(Some(value), 2048))
        .map(PathBuf::from)
        .or_else(|| {
            env::var("USERPROFILE")
                .ok()
                .and_then(|value| normalize_optional_text(Some(value), 2048))
                .map(PathBuf::from)
        })
}

fn expand_home_relative_path(path: &str, home: Option<&Path>) -> PathBuf {
    if path == "~" {
        if let Some(home) = home {
            return home.to_path_buf();
        }
        return PathBuf::from(path);
    }
    if let Some(rest) = path.strip_prefix("~/").or_else(|| path.strip_prefix("~\\")) {
        if let Some(home) = home {
            return home.join(rest);
        }
    }
    PathBuf::from(path)
}

fn resolve_codex_home_path(home_dir: Option<&str>, codex_home: Option<&str>) -> Option<PathBuf> {
    let home = resolve_home_path(home_dir);
    if let Some(raw) =
        codex_home.and_then(|value| normalize_optional_text(Some(value.to_owned()), 2048))
    {
        return Some(expand_home_relative_path(&raw, home.as_deref()));
    }
    if let Some(raw) = env::var("CODEX_HOME")
        .ok()
        .and_then(|value| normalize_optional_text(Some(value), 2048))
    {
        return Some(expand_home_relative_path(&raw, home.as_deref()));
    }
    home.map(|path| path.join(".codex"))
}

fn parse_u64_from_json(value: Option<&Value>) -> Option<u64> {
    let value = value?;
    if let Some(raw) = value.as_u64() {
        return Some(raw);
    }
    if let Some(raw) = value.as_i64() {
        return (raw > 0).then_some(raw as u64);
    }
    value
        .as_str()
        .and_then(|raw| raw.trim().parse::<u64>().ok())
}

fn file_modified_ms(path: &Path) -> Option<u64> {
    let modified = std::fs::metadata(path).ok()?.modified().ok()?;
    let duration = modified.duration_since(UNIX_EPOCH).ok()?;
    Some(duration.as_millis() as u64)
}

fn read_json_file_value(path: &Path) -> Result<Option<Value>, String> {
    if !path.exists() {
        return Ok(None);
    }
    let raw = std::fs::read_to_string(path)
        .map_err(|err| format!("failed reading {}: {err}", path.display()))?;
    let parsed = serde_json::from_str::<Value>(&raw)
        .map_err(|err| format!("failed parsing {}: {err}", path.display()))?;
    Ok(Some(parsed))
}

fn read_codex_cli_oauth_credential(
    home_dir: Option<&str>,
    codex_home: Option<&str>,
) -> Result<Option<OAuthImportedCredential>, String> {
    let Some(codex_home) = resolve_codex_home_path(home_dir, codex_home) else {
        return Ok(None);
    };
    let auth_path = codex_home.join("auth.json");
    let Some(raw) = read_json_file_value(&auth_path)? else {
        return Ok(None);
    };
    let Some(tokens) = raw.get("tokens").and_then(Value::as_object) else {
        return Ok(None);
    };
    let access_token = tokens
        .get("access_token")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 8_192));
    if access_token.is_none() {
        return Ok(None);
    }
    let refresh_token = tokens
        .get("refresh_token")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 8_192));
    let account_id = tokens
        .get("account_id")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 256))
        .unwrap_or_else(|| "codex-cli".to_owned());
    let expires_at_ms = file_modified_ms(&auth_path).map(|value| value.saturating_add(3_600_000));
    Ok(Some(OAuthImportedCredential {
        provider_id: "openai-codex".to_owned(),
        account_id: account_id.clone(),
        profile_id: oauth_default_profile_id("openai-codex", &account_id),
        source: auth_path.to_string_lossy().to_string(),
        access_token,
        refresh_token,
        token_type: Some("Bearer".to_owned()),
        expires_at_ms,
        scopes: Vec::new(),
    }))
}

fn read_claude_cli_oauth_credential(
    home_dir: Option<&str>,
) -> Result<Option<OAuthImportedCredential>, String> {
    let Some(home) = resolve_home_path(home_dir) else {
        return Ok(None);
    };
    let credentials_path = home.join(".claude").join(".credentials.json");
    let Some(raw) = read_json_file_value(&credentials_path)? else {
        return Ok(None);
    };
    let Some(oauth) = raw.get("claudeAiOauth").and_then(Value::as_object) else {
        return Ok(None);
    };
    let access_token = oauth
        .get("accessToken")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 8_192));
    if access_token.is_none() {
        return Ok(None);
    }
    let refresh_token = oauth
        .get("refreshToken")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 8_192));
    let expires_at_ms = parse_u64_from_json(oauth.get("expiresAt"));
    let account_id = oauth
        .get("email")
        .or_else(|| oauth.get("emailAddress"))
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 256))
        .unwrap_or_else(|| "claude-cli".to_owned());
    Ok(Some(OAuthImportedCredential {
        provider_id: "anthropic".to_owned(),
        account_id: account_id.clone(),
        profile_id: oauth_default_profile_id("anthropic", &account_id),
        source: credentials_path.to_string_lossy().to_string(),
        access_token,
        refresh_token,
        token_type: Some("Bearer".to_owned()),
        expires_at_ms,
        scopes: Vec::new(),
    }))
}

fn read_gemini_cli_oauth_credential(
    home_dir: Option<&str>,
) -> Result<Option<OAuthImportedCredential>, String> {
    read_portal_cli_oauth_credential(
        home_dir,
        ".gemini/oauth_creds.json",
        "google-gemini-cli",
        "gemini-cli",
    )
}

fn read_portal_cli_oauth_credential(
    home_dir: Option<&str>,
    relative_path: &str,
    provider_id: &str,
    account_id: &str,
) -> Result<Option<OAuthImportedCredential>, String> {
    let Some(home) = resolve_home_path(home_dir) else {
        return Ok(None);
    };
    let credentials_path = home.join(PathBuf::from(relative_path));
    let Some(raw) = read_json_file_value(&credentials_path)? else {
        return Ok(None);
    };
    let access_token = raw
        .get("access_token")
        .and_then(Value::as_str)
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 8_192));
    if access_token.is_none() {
        return Ok(None);
    }
    let refresh_token = raw
        .get("refresh_token")
        .and_then(Value::as_str)
        .and_then(|value| normalize_optional_text(Some(value.to_owned()), 8_192));
    let expires_at_ms = parse_u64_from_json(raw.get("expiry_date"));
    let scope_value = raw
        .get("scope")
        .and_then(Value::as_str)
        .and_then(|scope| normalize_optional_text(Some(scope.to_owned()), 2_048))
        .unwrap_or_default();
    let scopes = scope_value
        .split_whitespace()
        .filter_map(|scope| normalize_optional_text(Some(scope.to_owned()), 128))
        .collect::<Vec<_>>();

    Ok(Some(OAuthImportedCredential {
        provider_id: provider_id.to_owned(),
        account_id: account_id.to_owned(),
        profile_id: oauth_default_profile_id(provider_id, account_id),
        source: credentials_path.to_string_lossy().to_string(),
        access_token,
        refresh_token,
        token_type: Some("Bearer".to_owned()),
        expires_at_ms,
        scopes,
    }))
}

struct WizardRegistry {
    state: Mutex<WizardState>,
    runtime: Mutex<WizardRuntimeState>,
}

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
struct WizardState {
    sessions: HashMap<String, WizardSessionState>,
}

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "lowercase")]
enum WizardRunStatus {
    Running,
    Done,
    Cancelled,
    Error,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct WizardSessionState {
    mode: String,
    workspace: Option<String>,
    status: WizardRunStatus,
    error: Option<String>,
    #[serde(rename = "createdAtMs")]
    created_at_ms: u64,
    #[serde(rename = "updatedAtMs")]
    updated_at_ms: u64,
}

#[derive(Debug, Clone)]
struct WizardRuntimeState {
    store_path: String,
}

#[derive(Debug, Clone)]
enum WizardRegistryError {
    Invalid(String),
    Unavailable(String),
}

impl WizardRunStatus {
    fn as_str(&self) -> &'static str {
        match self {
            Self::Running => "running",
            Self::Done => "done",
            Self::Cancelled => "cancelled",
            Self::Error => "error",
        }
    }
}

impl WizardRegistry {
    fn new() -> Self {
        Self {
            state: Mutex::new(WizardState {
                sessions: HashMap::new(),
            }),
            runtime: Mutex::new(WizardRuntimeState {
                store_path: WIZARD_STORE_PATH.to_owned(),
            }),
        }
    }

    async fn apply_runtime_config(&self, runtime: WizardRuntimeConfig) -> Result<(), String> {
        let target_store_path = runtime
            .store_path
            .and_then(|value| normalize_optional_text(Some(value), 2048))
            .unwrap_or_else(|| WIZARD_STORE_PATH.to_owned());

        let current_store_path = { self.runtime.lock().await.store_path.clone() };
        if current_store_path == target_store_path {
            return Ok(());
        }

        let mut loaded = load_wizard_store_disk_state(&target_store_path)?;
        prune_oldest_wizard_sessions(&mut loaded.sessions, 64);
        {
            let mut guard = self.state.lock().await;
            *guard = loaded.clone();
        }
        {
            let mut runtime_guard = self.runtime.lock().await;
            runtime_guard.store_path = target_store_path.clone();
        }
        persist_wizard_store_disk_state(&target_store_path, &loaded)?;
        Ok(())
    }

    async fn persist_state_snapshot(&self, state: WizardState) -> Result<(), String> {
        let store_path = { self.runtime.lock().await.store_path.clone() };
        persist_wizard_store_disk_state(&store_path, &state)
    }

    async fn start(
        &self,
        mode: String,
        workspace: Option<String>,
    ) -> Result<Value, WizardRegistryError> {
        let (response, snapshot) = {
            let mut guard = self.state.lock().await;
            if guard
                .sessions
                .values()
                .any(|session| session.status == WizardRunStatus::Running)
            {
                return Err(WizardRegistryError::Unavailable(
                    "wizard already running".to_owned(),
                ));
            }
            let now = now_ms();
            let session_id = next_wizard_session_id();
            let session = WizardSessionState {
                mode,
                workspace,
                status: WizardRunStatus::Running,
                error: None,
                created_at_ms: now,
                updated_at_ms: now,
            };
            guard.sessions.insert(session_id.clone(), session.clone());
            prune_oldest_wizard_sessions(&mut guard.sessions, 64);
            (
                json!({
                    "sessionId": session_id,
                    "done": false,
                    "step": wizard_step_payload(&session),
                    "status": WizardRunStatus::Running.as_str()
                }),
                guard.clone(),
            )
        };
        let _ = self.persist_state_snapshot(snapshot).await;
        Ok(response)
    }

    async fn next(&self, params: WizardNextParams) -> Result<Value, WizardRegistryError> {
        let session_id = normalize_optional_text(params.session_id, 128).ok_or_else(|| {
            WizardRegistryError::Invalid(
                "invalid wizard.next params: sessionId required".to_owned(),
            )
        })?;
        let (response, snapshot) = {
            let mut guard = self.state.lock().await;
            let Some(session) = guard.sessions.get_mut(&session_id) else {
                return Err(WizardRegistryError::Invalid("wizard not found".to_owned()));
            };

            if let Some(answer) = params.answer {
                if session.status != WizardRunStatus::Running {
                    return Err(WizardRegistryError::Invalid(
                        "wizard not running".to_owned(),
                    ));
                }
                let step_id =
                    normalize_optional_text(Some(answer.step_id), 128).ok_or_else(|| {
                        WizardRegistryError::Invalid(
                            "invalid wizard.next params: answer.stepId required".to_owned(),
                        )
                    })?;
                if normalize(&step_id) != "confirm-setup" {
                    session.status = WizardRunStatus::Error;
                    session.error = Some("invalid wizard step".to_owned());
                    return Err(WizardRegistryError::Invalid(
                        "invalid wizard.next params: unknown stepId".to_owned(),
                    ));
                }
                let accepted = match answer.value {
                    Some(value) => json_value_as_bool(&value).ok_or_else(|| {
                        WizardRegistryError::Invalid(
                            "invalid wizard.next params: answer.value must be boolean".to_owned(),
                        )
                    })?,
                    None => true,
                };
                session.updated_at_ms = now_ms();
                session.status = if accepted {
                    WizardRunStatus::Done
                } else {
                    WizardRunStatus::Cancelled
                };
            }

            let running = session.status == WizardRunStatus::Running;
            let response = if running {
                json!({
                    "done": false,
                    "step": wizard_step_payload(session),
                    "status": session.status.as_str(),
                    "error": session.error
                })
            } else {
                json!({
                    "done": true,
                    "status": session.status.as_str(),
                    "error": session.error
                })
            };
            if !running {
                let _ = guard.sessions.remove(&session_id);
            }
            (response, guard.clone())
        };
        let _ = self.persist_state_snapshot(snapshot).await;
        Ok(response)
    }

    async fn cancel(&self, session_id: &str) -> Result<Value, WizardRegistryError> {
        let (response, snapshot) = {
            let mut guard = self.state.lock().await;
            let Some(mut session) = guard.sessions.remove(session_id) else {
                return Err(WizardRegistryError::Invalid("wizard not found".to_owned()));
            };
            session.status = WizardRunStatus::Cancelled;
            session.updated_at_ms = now_ms();
            (
                json!({
                    "status": session.status.as_str(),
                    "error": session.error
                }),
                guard.clone(),
            )
        };
        let _ = self.persist_state_snapshot(snapshot).await;
        Ok(response)
    }

    async fn status(&self, session_id: &str) -> Result<Value, WizardRegistryError> {
        let (response, snapshot) = {
            let mut guard = self.state.lock().await;
            let Some(session) = guard.sessions.get(session_id).cloned() else {
                return Err(WizardRegistryError::Invalid("wizard not found".to_owned()));
            };
            let mut persisted = None;
            if session.status != WizardRunStatus::Running {
                let _ = guard.sessions.remove(session_id);
                persisted = Some(guard.clone());
            }
            (
                json!({
                    "status": session.status.as_str(),
                    "error": session.error
                }),
                persisted,
            )
        };
        if let Some(snapshot) = snapshot {
            let _ = self.persist_state_snapshot(snapshot).await;
        }
        Ok(response)
    }
}

fn prune_oldest_wizard_sessions(
    sessions: &mut HashMap<String, WizardSessionState>,
    max_sessions: usize,
) {
    while sessions.len() > max_sessions {
        let Some(oldest_key) = sessions
            .iter()
            .filter(|(_, entry)| entry.status != WizardRunStatus::Running)
            .min_by_key(|(_, entry)| entry.created_at_ms)
            .map(|(key, _)| key.clone())
        else {
            break;
        };
        let _ = sessions.remove(&oldest_key);
    }
}

fn wizard_store_path_is_memory(path: &str) -> bool {
    normalize(path).starts_with("memory://")
}

fn load_wizard_store_disk_state(path: &str) -> Result<WizardState, String> {
    if wizard_store_path_is_memory(path) {
        return Ok(WizardState::default());
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(WizardState::default());
    }
    let raw = std::fs::read_to_string(&store_path).map_err(|err| {
        format!(
            "failed reading wizard store {}: {err}",
            store_path.display()
        )
    })?;
    let parsed: WizardState = serde_json::from_str(&raw).map_err(|err| {
        format!(
            "failed parsing wizard store {}: {err}",
            store_path.display()
        )
    })?;
    Ok(parsed)
}

fn persist_wizard_store_disk_state(path: &str, state: &WizardState) -> Result<(), String> {
    if wizard_store_path_is_memory(path) {
        return Ok(());
    }
    let payload = serde_json::to_string_pretty(state)
        .map_err(|err| format!("failed serializing wizard store: {err}"))?;
    let store_path = PathBuf::from(path);
    if let Some(parent) = store_path.parent() {
        std::fs::create_dir_all(parent).map_err(|err| {
            format!(
                "failed creating wizard store directory {}: {err}",
                parent.display()
            )
        })?;
    }
    let mut temp_path = store_path.clone();
    let temp_name = format!(
        ".{}.tmp",
        store_path
            .file_name()
            .and_then(|name| name.to_str())
            .unwrap_or("wizard-store")
    );
    temp_path.set_file_name(temp_name);
    std::fs::write(&temp_path, payload).map_err(|err| {
        format!(
            "failed writing wizard temp store {}: {err}",
            temp_path.display()
        )
    })?;
    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        format!(
            "failed replacing wizard store {}: {err}",
            store_path.display()
        )
    })
}

fn wizard_step_payload(session: &WizardSessionState) -> Value {
    let workspace_label = session
        .workspace
        .as_deref()
        .filter(|value| !value.trim().is_empty())
        .unwrap_or("default");
    json!({
        "id": "confirm-setup",
        "type": "confirm",
        "title": "Rust Gateway Wizard",
        "message": format!(
            "Mode: {}. Workspace: {}. Confirm to apply Rust parity wizard setup.",
            session.mode, workspace_label
        ),
        "initialValue": true,
        "executor": "gateway"
    })
}

fn parse_wizard_mode(mode: Option<String>) -> Result<String, String> {
    let normalized = normalize_optional_text(mode, 32).unwrap_or_else(|| "local".to_owned());
    match normalize(&normalized).as_str() {
        "local" => Ok("local".to_owned()),
        "remote" => Ok("remote".to_owned()),
        _ => Err("invalid wizard.start params: mode must be local|remote".to_owned()),
    }
}

fn resolve_web_login_provider(channel_capabilities: &[ChannelCapabilities]) -> Option<String> {
    for candidate in ["whatsapp", "zalouser", "zalo"] {
        if channel_capabilities
            .iter()
            .any(|cap| cap.name.eq_ignore_ascii_case(candidate))
        {
            return Some(candidate.to_owned());
        }
    }
    None
}

#[derive(Debug, Clone, Copy)]
struct OAuthProviderCatalogEntry {
    id: &'static str,
    display_name: &'static str,
    aliases: &'static [&'static str],
    verification_url: &'static str,
}

const OAUTH_PROVIDER_CATALOG: &[OAuthProviderCatalogEntry] = &[
    OAuthProviderCatalogEntry {
        id: "openai",
        display_name: "ChatGPT",
        aliases: &["chatgpt", "openai-chatgpt"],
        verification_url: "https://chatgpt.com",
    },
    OAuthProviderCatalogEntry {
        id: "openai-codex",
        display_name: "Codex",
        aliases: &["codex", "codex-cli", "openai-codex-cli"],
        verification_url: "https://platform.openai.com",
    },
    OAuthProviderCatalogEntry {
        id: "anthropic",
        display_name: "Claude",
        aliases: &["claude", "claude-cli"],
        verification_url: "https://claude.ai",
    },
    OAuthProviderCatalogEntry {
        id: "google-gemini-cli",
        display_name: "Gemini",
        aliases: &["gemini", "gemini-cli", "google-gemini"],
        verification_url: "https://aistudio.google.com",
    },
    OAuthProviderCatalogEntry {
        id: "qwen-portal",
        display_name: "Qwen",
        aliases: &["qwen", "qwen-cli"],
        verification_url: "https://chat.qwen.ai",
    },
    OAuthProviderCatalogEntry {
        id: "minimax-portal",
        display_name: "MiniMax",
        aliases: &["minimax", "minimax-cli"],
        verification_url: "https://chat.minimax.io",
    },
    OAuthProviderCatalogEntry {
        id: "kimi-coding",
        display_name: "Kimi",
        aliases: &["kimi", "kimi-code"],
        verification_url: "https://www.kimi.com",
    },
    OAuthProviderCatalogEntry {
        id: "opencode",
        display_name: "OpenCode",
        aliases: &["opencode-zen", "opencode-ai"],
        verification_url: "https://opencode.ai",
    },
    OAuthProviderCatalogEntry {
        id: "zhipuai",
        display_name: "Zhipu AI",
        aliases: &["zhipu", "zhipu-ai", "bigmodel"],
        verification_url: "https://open.bigmodel.cn",
    },
];

fn oauth_provider_catalog_entry(provider: &str) -> Option<&'static OAuthProviderCatalogEntry> {
    let normalized = normalize(provider);
    OAUTH_PROVIDER_CATALOG.iter().find(|entry| {
        normalize(entry.id) == normalized
            || entry
                .aliases
                .iter()
                .any(|alias| normalize(alias) == normalized)
    })
}

fn normalize_oauth_provider_id(provider: &str) -> Option<String> {
    let candidate = normalize_optional_text(Some(provider.to_owned()), 128)?;
    if let Some(entry) = oauth_provider_catalog_entry(&candidate) {
        return Some(entry.id.to_owned());
    }
    let normalized = normalize_provider_id(&candidate);
    if normalized.is_empty() {
        return None;
    }
    Some(normalized)
}

fn resolve_oauth_provider_param(
    provider_id: Option<String>,
    provider: Option<String>,
) -> Option<String> {
    let raw = provider_id.or(provider)?;
    normalize_oauth_provider_id(&raw)
}

fn oauth_provider_display_name(provider: &str) -> String {
    oauth_provider_catalog_entry(provider)
        .map(|entry| entry.display_name.to_owned())
        .unwrap_or_else(|| provider.to_owned())
}

fn oauth_provider_verification_url(provider: &str) -> String {
    oauth_provider_catalog_entry(provider)
        .map(|entry| entry.verification_url.to_owned())
        .unwrap_or_else(|| "https://example.com/oauth".to_owned())
}

fn oauth_provider_aliases(provider: &str) -> Vec<String> {
    oauth_provider_catalog_entry(provider)
        .map(|entry| {
            let mut aliases = entry
                .aliases
                .iter()
                .map(|alias| alias.to_string())
                .collect::<Vec<_>>();
            sort_and_dedup_strings(&mut aliases);
            aliases
        })
        .unwrap_or_default()
}

fn oauth_default_profile_id(provider: &str, account_id: &str) -> String {
    match provider {
        "anthropic" => "anthropic:claude-cli".to_owned(),
        "openai-codex" => "openai-codex:codex-cli".to_owned(),
        "google-gemini-cli" => "google-gemini-cli:gemini-cli".to_owned(),
        "qwen-portal" => "qwen-portal:qwen-cli".to_owned(),
        "minimax-portal" => "minimax-portal:minimax-cli".to_owned(),
        "opencode" => "opencode:default".to_owned(),
        "zhipuai" => "zhipuai:default".to_owned(),
        _ => format!("{provider}:{account_id}"),
    }
}

fn oauth_token_preview(token: Option<&String>) -> Option<String> {
    let token = token?;
    if token.len() <= 8 {
        return Some("********".to_owned());
    }
    let prefix = &token[..4];
    let suffix = &token[token.len().saturating_sub(4)..];
    Some(format!("{prefix}...{suffix}"))
}

fn extract_update_delivery_info(session_key: Option<&str>) -> (Option<Value>, Option<String>) {
    let Some(session_key) = session_key else {
        return (None, None);
    };
    let parsed = parse_session_key(session_key);
    let mut delivery = serde_json::Map::new();
    if let Some(channel) = parsed.channel {
        delivery.insert("channel".to_owned(), Value::String(channel));
    }
    if let Some(to) = parsed.scope_id {
        delivery.insert("to".to_owned(), Value::String(to));
    }
    (
        (!delivery.is_empty()).then_some(Value::Object(delivery)),
        parsed.topic_id,
    )
}

fn json_value_as_bool(value: &Value) -> Option<bool> {
    match value {
        Value::Bool(v) => Some(*v),
        Value::Number(v) => v.as_i64().map(|raw| raw != 0),
        Value::String(v) => match normalize(v).as_str() {
            "1" | "true" | "yes" | "on" => Some(true),
            "0" | "false" | "no" | "off" => Some(false),
            _ => None,
        },
        _ => None,
    }
}

fn json_value_as_timeout_ms(value: &Value) -> Option<u64> {
    let Value::Number(raw) = value else {
        return None;
    };
    if let Some(value) = raw.as_u64() {
        return Some(value.max(1));
    }
    if let Some(value) = raw.as_i64() {
        return Some(value.max(1) as u64);
    }
    let value = raw.as_f64()?;
    if !value.is_finite() {
        return None;
    }
    Some(value.floor().max(1.0) as u64)
}

fn parse_payload_json(payload_json: &str) -> Option<Value> {
    let trimmed = payload_json.trim();
    if trimmed.is_empty() {
        return None;
    }
    serde_json::from_str::<Value>(trimmed)
        .ok()
        .or_else(|| Some(json!({ "payloadJSON": payload_json })))
}

fn normalize_node_invoke_result_params(params: Value) -> Value {
    let Some(mut map) = params.as_object().cloned() else {
        return params;
    };
    if matches!(map.get("payloadJSON"), Some(Value::Null)) {
        map.remove("payloadJSON");
    } else if matches!(map.get("payload_json"), Some(Value::Null)) {
        map.remove("payload_json");
    }

    let payload_json_value = map
        .get("payloadJSON")
        .cloned()
        .or_else(|| map.get("payload_json").cloned());
    if let Some(payload_json_value) = payload_json_value {
        if !payload_json_value.is_string() {
            if !map.contains_key("payload") {
                map.insert("payload".to_owned(), payload_json_value);
            }
            map.remove("payloadJSON");
            map.remove("payload_json");
        }
    }

    if matches!(map.get("error"), Some(Value::Null)) {
        map.remove("error");
    }
    Value::Object(map)
}

fn discover_skills(
    base_dir: &Path,
    config_entries: &HashMap<String, SkillConfigState>,
    virtual_skills: &HashMap<String, VirtualSkillEntry>,
) -> Vec<DiscoveredSkill> {
    let mut by_key = HashMap::new();
    if base_dir.exists() {
        let mut stack = vec![(base_dir.to_path_buf(), 0usize)];
        while let Some((dir, depth)) = stack.pop() {
            if depth > 6 {
                continue;
            }
            let read_dir = match std::fs::read_dir(&dir) {
                Ok(entries) => entries,
                Err(_) => continue,
            };
            for entry in read_dir.flatten() {
                let path = entry.path();
                if path.is_dir() {
                    stack.push((path, depth + 1));
                    continue;
                }
                let is_skill_file = path
                    .file_name()
                    .and_then(|value| value.to_str())
                    .map(|value| value.eq_ignore_ascii_case("SKILL.md"))
                    .unwrap_or(false);
                if !is_skill_file {
                    continue;
                }
                if let Some(skill) = parse_skill_file(&path) {
                    by_key.insert(skill.skill_key.clone(), skill);
                    if by_key.len() >= 512 {
                        break;
                    }
                }
            }
            if by_key.len() >= 512 {
                break;
            }
        }
    }

    for (skill_key, virtual_skill) in virtual_skills {
        by_key
            .entry(skill_key.clone())
            .or_insert_with(|| DiscoveredSkill {
                name: virtual_skill.name.clone(),
                description: virtual_skill.description.clone(),
                source: "virtual".to_owned(),
                file_path: String::new(),
                base_dir: String::new(),
                skill_key: skill_key.clone(),
                bundled: false,
                primary_env: None,
                emoji: None,
                homepage: None,
                requirements: SkillRequirementSet::default(),
                install: Vec::new(),
            });
    }

    for skill_key in config_entries.keys() {
        by_key
            .entry(skill_key.clone())
            .or_insert_with(|| DiscoveredSkill {
                name: skill_key.clone(),
                description: "Configured skill".to_owned(),
                source: "config".to_owned(),
                file_path: String::new(),
                base_dir: String::new(),
                skill_key: skill_key.clone(),
                bundled: false,
                primary_env: None,
                emoji: None,
                homepage: None,
                requirements: SkillRequirementSet::default(),
                install: Vec::new(),
            });
    }

    let mut values = by_key.into_values().collect::<Vec<_>>();
    values.sort_by(|a, b| {
        a.name
            .to_ascii_lowercase()
            .cmp(&b.name.to_ascii_lowercase())
            .then_with(|| a.skill_key.cmp(&b.skill_key))
    });
    values
}

fn parse_skill_file(path: &Path) -> Option<DiscoveredSkill> {
    let raw = std::fs::read_to_string(path).ok()?;
    let mut frontmatter = HashMap::new();
    let mut lines = raw.lines();
    if matches!(lines.next().map(str::trim), Some("---")) {
        for line in lines {
            let trimmed = line.trim();
            if trimmed == "---" {
                break;
            }
            if let Some((key, value)) = trimmed.split_once(':') {
                frontmatter.insert(
                    key.trim().to_ascii_lowercase(),
                    value.trim().trim_matches('"').to_owned(),
                );
            }
        }
    }

    let parent = path.parent()?;
    let fallback_name = parent
        .file_name()
        .and_then(|value| value.to_str())
        .unwrap_or("skill")
        .to_owned();
    let name = frontmatter
        .get("name")
        .cloned()
        .filter(|value| !value.trim().is_empty())
        .unwrap_or(fallback_name.clone());
    let description = frontmatter
        .get("description")
        .cloned()
        .filter(|value| !value.trim().is_empty())
        .unwrap_or_else(|| "Installed skill".to_owned());
    let skill_key = skill_key_from_name(&name);
    let source = if path.to_string_lossy().contains(".system") {
        "system".to_owned()
    } else {
        "local".to_owned()
    };
    Some(DiscoveredSkill {
        name,
        description,
        source,
        file_path: path.to_string_lossy().to_string(),
        base_dir: parent.to_string_lossy().to_string(),
        skill_key,
        bundled: path.to_string_lossy().contains(".system"),
        primary_env: frontmatter.get("primary_env").cloned(),
        emoji: frontmatter.get("emoji").cloned(),
        homepage: frontmatter.get("homepage").cloned(),
        requirements: SkillRequirementSet::default(),
        install: Vec::new(),
    })
}

fn build_skill_status_entry(skill: DiscoveredSkill, cfg: SkillConfigState) -> SkillStatusEntryView {
    let mut missing_env = skill
        .requirements
        .env
        .iter()
        .filter(|key| !cfg.env.contains_key(*key))
        .filter(|key| std::env::var(key.as_str()).is_err())
        .cloned()
        .collect::<Vec<_>>();
    sort_and_dedup_strings(&mut missing_env);

    let mut missing_config = skill
        .requirements
        .config
        .iter()
        .filter(|path| path.trim().is_empty())
        .cloned()
        .collect::<Vec<_>>();
    sort_and_dedup_strings(&mut missing_config);

    let config_checks = skill
        .requirements
        .config
        .iter()
        .map(|path| SkillsStatusConfigCheck {
            path: path.clone(),
            satisfied: !path.trim().is_empty(),
        })
        .collect::<Vec<_>>();

    SkillStatusEntryView {
        name: skill.name,
        description: skill.description,
        source: skill.source,
        file_path: skill.file_path,
        base_dir: skill.base_dir,
        skill_key: skill.skill_key,
        bundled: skill.bundled.then_some(true),
        primary_env: skill.primary_env,
        emoji: skill.emoji,
        homepage: skill.homepage,
        always: false,
        disabled: matches!(cfg.enabled, Some(false)),
        blocked_by_allowlist: false,
        eligible: true,
        requirements: SkillStatusRequirements {
            bins: skill.requirements.bins.clone(),
            env: skill.requirements.env.clone(),
            config: skill.requirements.config.clone(),
            os: skill.requirements.os.clone(),
        },
        missing: SkillStatusRequirements {
            bins: Vec::new(),
            env: missing_env,
            config: missing_config,
            os: Vec::new(),
        },
        config_checks,
        install: skill.install,
    }
}

fn default_codex_skills_dir() -> PathBuf {
    if let Some(value) = std::env::var_os("CODEX_HOME") {
        return PathBuf::from(value).join("skills");
    }
    if cfg!(windows) {
        if let Some(home) = std::env::var_os("USERPROFILE") {
            return PathBuf::from(home).join(".codex").join("skills");
        }
    }
    if let Some(home) = std::env::var_os("HOME") {
        return PathBuf::from(home).join(".codex").join("skills");
    }
    PathBuf::from(".codex").join("skills")
}

fn skill_key_from_name(name: &str) -> String {
    let mut out = String::new();
    let mut last_dash = false;
    for ch in name.trim().chars() {
        let lower = ch.to_ascii_lowercase();
        let keep = lower.is_ascii_alphanumeric() || lower == '_' || lower == '-';
        if keep {
            out.push(lower);
            last_dash = false;
        } else if !last_dash {
            out.push('-');
            last_dash = true;
        }
    }
    let trimmed = out.trim_matches('-').to_owned();
    if trimmed.is_empty() {
        "skill".to_owned()
    } else {
        trimmed
    }
}

fn normalize_secret_input(value: &str) -> String {
    value
        .chars()
        .filter(|ch| *ch != '\r' && *ch != '\n')
        .collect::<String>()
        .trim()
        .to_owned()
}

fn sort_and_dedup_strings(values: &mut Vec<String>) {
    values.sort();
    values.dedup();
}

struct ConfigRegistry {
    state: Mutex<ConfigState>,
    runtime: Mutex<ConfigRuntimeState>,
}

#[derive(Debug, Clone)]
struct ConfigState {
    path: String,
    config: Value,
    hash: String,
    updated_at_ms: u64,
}

#[derive(Debug, Clone)]
struct ConfigSnapshot {
    path: String,
    raw: String,
    config: Value,
    hash: String,
    updated_at_ms: u64,
}

#[derive(Debug, Clone)]
struct ConfigUpdateResult {
    path: String,
    config: Value,
    hash: String,
}

#[derive(Debug, Clone)]
struct ConfigRuntimeState {
    store_path: String,
}

impl ConfigRegistry {
    fn new() -> Self {
        let config = default_gateway_config_document();
        let hash = hash_json_value(&config);
        Self {
            state: Mutex::new(ConfigState {
                path: CONFIG_STORE_PATH.to_owned(),
                config,
                hash,
                updated_at_ms: now_ms(),
            }),
            runtime: Mutex::new(ConfigRuntimeState {
                store_path: CONFIG_STORE_PATH.to_owned(),
            }),
        }
    }

    async fn apply_runtime_config(&self, runtime: ConfigRuntimeConfig) -> Result<(), String> {
        let target_store_path = runtime
            .store_path
            .and_then(|value| normalize_optional_text(Some(value), 2048))
            .unwrap_or_else(|| CONFIG_STORE_PATH.to_owned());

        let current_store_path = { self.runtime.lock().await.store_path.clone() };
        if current_store_path == target_store_path {
            return Ok(());
        }

        let loaded = load_config_store_disk_state(&target_store_path)?;
        let state = ConfigState {
            path: target_store_path.clone(),
            hash: loaded.hash.clone(),
            updated_at_ms: loaded.updated_at_ms,
            config: loaded.config,
        };

        {
            let mut guard = self.state.lock().await;
            *guard = state.clone();
        }
        {
            let mut runtime_guard = self.runtime.lock().await;
            runtime_guard.store_path = target_store_path.clone();
        }
        persist_config_store_disk_state(&target_store_path, &state)?;
        Ok(())
    }

    async fn persist_state_snapshot(&self, state: ConfigState) -> Result<(), String> {
        let store_path = { self.runtime.lock().await.store_path.clone() };
        persist_config_store_disk_state(&store_path, &state)
    }

    fn schema(&self) -> Value {
        json!({
            "schema": {
                "type": "object"
            },
            "uiHints": {},
            "version": "rust-parity-1",
            "generatedAt": now_ms().to_string()
        })
    }

    async fn get_snapshot(&self) -> ConfigSnapshot {
        let guard = self.state.lock().await;
        ConfigSnapshot {
            path: guard.path.clone(),
            raw: serde_json::to_string_pretty(&guard.config).unwrap_or_else(|_| "{}".to_owned()),
            config: guard.config.clone(),
            hash: guard.hash.clone(),
            updated_at_ms: guard.updated_at_ms,
        }
    }

    async fn set(
        &self,
        raw: String,
        base_hash: Option<String>,
    ) -> Result<ConfigUpdateResult, String> {
        let parsed = parse_config_raw(raw, "config.set")?;
        let (result, snapshot, store_path) = {
            let mut guard = self.state.lock().await;
            require_base_hash(base_hash, &guard)?;
            guard.config = parsed;
            guard.hash = hash_json_value(&guard.config);
            guard.updated_at_ms = now_ms();
            let store_path = config_runtime_config_from_config(&guard.config)
                .store_path
                .and_then(|value| normalize_optional_text(Some(value), 2048))
                .unwrap_or_else(|| CONFIG_STORE_PATH.to_owned());
            guard.path = store_path.clone();
            (
                ConfigUpdateResult {
                    path: guard.path.clone(),
                    config: guard.config.clone(),
                    hash: guard.hash.clone(),
                },
                guard.clone(),
                store_path,
            )
        };
        {
            let mut runtime_guard = self.runtime.lock().await;
            runtime_guard.store_path = store_path;
        }
        let _ = self.persist_state_snapshot(snapshot).await;
        Ok(result)
    }

    async fn patch(
        &self,
        raw: String,
        base_hash: Option<String>,
    ) -> Result<ConfigUpdateResult, String> {
        let patch = parse_config_patch_raw(raw)?;
        let (result, snapshot, store_path) = {
            let mut guard = self.state.lock().await;
            require_base_hash(base_hash, &guard)?;
            let candidate = apply_merge_patch(guard.config.clone(), patch.clone());
            let store_path = config_runtime_config_from_config(&candidate)
                .store_path
                .and_then(|value| normalize_optional_text(Some(value), 2048))
                .unwrap_or_else(|| CONFIG_STORE_PATH.to_owned());
            let next_config = if !guard.path.eq_ignore_ascii_case(&store_path) {
                match load_config_store_disk_state(&store_path) {
                    Ok(loaded) => apply_merge_patch(loaded.config, patch),
                    Err(_) => candidate,
                }
            } else {
                candidate
            };
            guard.config = next_config;
            guard.hash = hash_json_value(&guard.config);
            guard.updated_at_ms = now_ms();
            guard.path = store_path.clone();
            (
                ConfigUpdateResult {
                    path: guard.path.clone(),
                    config: guard.config.clone(),
                    hash: guard.hash.clone(),
                },
                guard.clone(),
                store_path,
            )
        };
        {
            let mut runtime_guard = self.runtime.lock().await;
            runtime_guard.store_path = store_path;
        }
        let _ = self.persist_state_snapshot(snapshot).await;
        Ok(result)
    }

    async fn cron_webhook_defaults(&self) -> CronWebhookDefaults {
        let guard = self.state.lock().await;
        cron_webhook_defaults_from_config(&guard.config)
    }

    async fn cron_runtime_config(&self) -> CronRuntimeConfig {
        let guard = self.state.lock().await;
        cron_runtime_config_from_config(&guard.config)
    }

    async fn send_runtime_config(&self) -> SendRuntimeConfig {
        let guard = self.state.lock().await;
        send_runtime_config_from_config(&guard.config)
    }

    async fn session_runtime_config(&self) -> SessionRuntimeConfig {
        let guard = self.state.lock().await;
        session_runtime_config_from_config(&guard.config)
    }

    async fn memory_runtime_config(&self) -> MemoryRuntimeConfig {
        let guard = self.state.lock().await;
        memory_runtime_config_from_config(&guard.config)
    }

    async fn channel_runtime_config(&self) -> ChannelRuntimeConfig {
        let guard = self.state.lock().await;
        channel_runtime_config_from_config(&guard.config)
    }

    async fn device_pair_runtime_config(&self) -> DevicePairRuntimeConfig {
        let guard = self.state.lock().await;
        device_pair_runtime_config_from_config(&guard.config)
    }

    async fn node_pair_runtime_config(&self) -> NodePairRuntimeConfig {
        let guard = self.state.lock().await;
        node_pair_runtime_config_from_config(&guard.config)
    }

    async fn config_runtime_config(&self) -> ConfigRuntimeConfig {
        let guard = self.state.lock().await;
        config_runtime_config_from_config(&guard.config)
    }

    async fn web_login_runtime_config(&self) -> WebLoginRuntimeConfig {
        let guard = self.state.lock().await;
        web_login_runtime_config_from_config(&guard.config)
    }

    async fn oauth_runtime_config(&self) -> OAuthRuntimeConfig {
        let guard = self.state.lock().await;
        oauth_runtime_config_from_config(&guard.config)
    }

    async fn wizard_runtime_config(&self) -> WizardRuntimeConfig {
        let guard = self.state.lock().await;
        wizard_runtime_config_from_config(&guard.config)
    }

    async fn node_host_runtime_config(&self) -> NodeHostRuntimeConfig {
        let guard = self.state.lock().await;
        node_host_runtime_config_from_config(&guard.config)
    }

    async fn node_command_policy_config(&self) -> NodeCommandPolicyConfig {
        let guard = self.state.lock().await;
        node_command_policy_config_from_config(&guard.config)
    }
}

fn default_gateway_config_document() -> Value {
    json!({
        "session": { "mainKey": "main" },
        "memory": {
            "enabled": true,
            "zvecStorePath": DEFAULT_ZVEC_STORE_PATH,
            "graphStorePath": DEFAULT_GRAPHLITE_STORE_PATH,
            "maxEntries": 20000,
            "recallTopK": 8,
            "recallMinScore": 0.18
        },
        "talk": {
            "outputFormat": "pcm16",
            "interruptOnSpeech": true
        },
        "ui": { "seamColor": "#4b5563" }
    })
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct ConfigStoreDiskState {
    config: Value,
    #[serde(rename = "updatedAtMs")]
    updated_at_ms: u64,
}

impl Default for ConfigStoreDiskState {
    fn default() -> Self {
        Self {
            config: default_gateway_config_document(),
            updated_at_ms: now_ms(),
        }
    }
}

impl From<ConfigState> for ConfigStoreDiskState {
    fn from(value: ConfigState) -> Self {
        Self {
            config: value.config,
            updated_at_ms: value.updated_at_ms,
        }
    }
}

impl ConfigStoreDiskState {
    fn into_state(self, path: String) -> ConfigState {
        let config = if self.config.is_object() {
            self.config
        } else {
            default_gateway_config_document()
        };
        ConfigState {
            hash: hash_json_value(&config),
            updated_at_ms: self.updated_at_ms.max(1),
            path,
            config,
        }
    }
}

fn load_config_store_disk_state(path: &str) -> Result<ConfigState, String> {
    if config_store_path_is_memory(path) {
        return Ok(ConfigStoreDiskState::default().into_state(path.to_owned()));
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(ConfigStoreDiskState::default().into_state(path.to_owned()));
    }
    let raw = std::fs::read_to_string(&store_path).map_err(|err| {
        format!(
            "failed reading config store {}: {err}",
            store_path.display()
        )
    })?;
    let parsed = serde_json::from_str::<ConfigStoreDiskState>(&raw).or_else(|_| {
        let config = serde_json::from_str::<Value>(&raw).map_err(|err| {
            format!(
                "failed parsing config store {}: {err}",
                store_path.display()
            )
        })?;
        Ok::<ConfigStoreDiskState, String>(ConfigStoreDiskState {
            config,
            updated_at_ms: now_ms(),
        })
    })?;
    Ok(parsed.into_state(path.to_owned()))
}

fn persist_config_store_disk_state(path: &str, state: &ConfigState) -> Result<(), String> {
    if config_store_path_is_memory(path) {
        return Ok(());
    }
    let payload = serde_json::to_string_pretty(&ConfigStoreDiskState {
        config: state.config.clone(),
        updated_at_ms: state.updated_at_ms,
    })
    .map_err(|err| format!("failed serializing config store: {err}"))?;
    let store_path = PathBuf::from(path);
    if let Some(parent) = store_path.parent() {
        std::fs::create_dir_all(parent).map_err(|err| {
            format!(
                "failed creating config store directory {}: {err}",
                parent.display()
            )
        })?;
    }
    let mut temp_path = store_path.clone();
    let temp_name = format!(
        ".{}.tmp",
        store_path
            .file_name()
            .and_then(|name| name.to_str())
            .unwrap_or("config-store")
    );
    temp_path.set_file_name(temp_name);
    std::fs::write(&temp_path, payload).map_err(|err| {
        format!(
            "failed writing config temp store {}: {err}",
            temp_path.display()
        )
    })?;
    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        format!(
            "failed replacing config store {}: {err}",
            store_path.display()
        )
    })
}

fn config_store_path_is_memory(path: &str) -> bool {
    normalize(path).starts_with("memory://")
}

fn parse_config_raw(raw: String, method: &str) -> Result<Value, String> {
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return Err(format!("invalid {method} params: raw (string) required"));
    }
    let parsed: Value =
        serde_json::from_str(trimmed).map_err(|err| format!("invalid config: {err}"))?;
    if !parsed.is_object() {
        return Err("invalid config: root must be object".to_owned());
    }
    Ok(parsed)
}

fn parse_config_patch_raw(raw: String) -> Result<Value, String> {
    let patch = parse_config_raw(raw, "config.patch")?;
    if !patch.is_object() {
        return Err("config.patch raw must be an object".to_owned());
    }
    Ok(patch)
}

fn require_base_hash(base_hash: Option<String>, state: &ConfigState) -> Result<(), String> {
    let Some(base_hash) = normalize_optional_text(base_hash, 128) else {
        return Err("config base hash required; re-run config.get and retry".to_owned());
    };
    if !base_hash.eq_ignore_ascii_case(&state.hash) {
        return Err("config changed since last load; re-run config.get and retry".to_owned());
    }
    Ok(())
}

fn hash_json_value(value: &Value) -> String {
    use sha2::{Digest, Sha256};
    let mut hasher = Sha256::new();
    let payload = serde_json::to_vec(value).unwrap_or_default();
    hasher.update(payload);
    format!("{:x}", hasher.finalize())
}

fn cron_webhook_defaults_from_config(config: &Value) -> CronWebhookDefaults {
    let Some(cron) = config.get("cron").and_then(Value::as_object) else {
        return CronWebhookDefaults::default();
    };
    let webhook = cron
        .get("webhook")
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 2048))
        .and_then(|raw| normalize_http_webhook_url(&raw));
    let webhook_token = cron
        .get("webhookToken")
        .or_else(|| cron.get("webhook_token"))
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 512));
    CronWebhookDefaults {
        webhook,
        webhook_token,
    }
}

fn cron_runtime_config_from_config(config: &Value) -> CronRuntimeConfig {
    let Some(cron) = config.get("cron").and_then(Value::as_object) else {
        return CronRuntimeConfig::default();
    };
    let enabled = cron.get("enabled").and_then(Value::as_bool);
    let store_path = cron
        .get("storePath")
        .or_else(|| cron.get("store_path"))
        .and_then(Value::as_str)
        .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 2048));
    CronRuntimeConfig {
        enabled,
        store_path,
    }
}

fn send_runtime_config_from_config(config: &Value) -> SendRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let idempotency = config.get("idempotency").and_then(Value::as_object);

    let store_path = idempotency
        .and_then(|obj| {
            read_config_string(
                obj,
                &[
                    "sendStorePath",
                    "send_store_path",
                    "storePath",
                    "store_path",
                ],
                2048,
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(
                    obj,
                    &["idempotencyStorePath", "idempotency_store_path"],
                    2048,
                )
            })
        });

    let ttl_ms = idempotency
        .and_then(|obj| read_config_u64(obj, &["ttlMs", "ttl_ms"]))
        .or_else(|| {
            runtime
                .and_then(|obj| read_config_u64(obj, &["idempotencyTtlMs", "idempotency_ttl_ms"]))
        })
        .or_else(|| {
            idempotency
                .and_then(|obj| read_config_u64(obj, &["ttlSecs", "ttl_secs"]))
                .map(|value| value.saturating_mul(1_000))
        })
        .or_else(|| {
            runtime
                .and_then(|obj| {
                    read_config_u64(obj, &["idempotencyTtlSecs", "idempotency_ttl_secs"])
                })
                .map(|value| value.saturating_mul(1_000))
        })
        .map(|value| value.max(1_000));

    let max_entries = idempotency
        .and_then(|obj| read_config_usize(obj, &["maxEntries", "max_entries"]))
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_usize(obj, &["idempotencyMaxEntries", "idempotency_max_entries"])
            })
        })
        .map(|value| value.max(32));

    SendRuntimeConfig {
        store_path,
        ttl_ms,
        max_entries,
    }
}

fn session_runtime_config_from_config(config: &Value) -> SessionRuntimeConfig {
    let session = config.get("session").and_then(Value::as_object);
    let store_path = session.and_then(|obj| {
        read_config_string(
            obj,
            &["storePath", "store_path", "statePath", "state_path"],
            2048,
        )
    });
    SessionRuntimeConfig { store_path }
}

fn memory_runtime_config_from_config(config: &Value) -> MemoryRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let memory = config.get("memory").and_then(Value::as_object);
    let zvec = memory.and_then(|obj| read_config_object(obj, &["zvec", "vector"]));
    let graphlite = memory.and_then(|obj| read_config_object(obj, &["graphlite", "graph"]));

    let enabled = memory
        .and_then(|obj| read_config_bool(obj, &["enabled"]))
        .or_else(|| {
            runtime.and_then(|obj| read_config_bool(obj, &["memoryEnabled", "memory_enabled"]))
        });

    let zvec_store_path = zvec
        .and_then(|obj| read_config_string(obj, &["storePath", "store_path", "path"], 2048))
        .or_else(|| {
            memory.and_then(|obj| {
                read_config_string(
                    obj,
                    &[
                        "zvecStorePath",
                        "zvec_store_path",
                        "vectorStorePath",
                        "vector_store_path",
                    ],
                    2048,
                )
            })
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(
                    obj,
                    &[
                        "memoryVectorStorePath",
                        "memory_vector_store_path",
                        "zvecStorePath",
                        "zvec_store_path",
                    ],
                    2048,
                )
            })
        });

    let graph_store_path = graphlite
        .and_then(|obj| read_config_string(obj, &["storePath", "store_path", "path"], 2048))
        .or_else(|| {
            memory.and_then(|obj| {
                read_config_string(
                    obj,
                    &[
                        "graphStorePath",
                        "graph_store_path",
                        "graphliteStorePath",
                        "graphlite_store_path",
                    ],
                    2048,
                )
            })
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(
                    obj,
                    &[
                        "memoryGraphStorePath",
                        "memory_graph_store_path",
                        "graphStorePath",
                        "graph_store_path",
                    ],
                    2048,
                )
            })
        });

    let max_entries = zvec
        .and_then(|obj| read_config_usize(obj, &["maxEntries", "max_entries"]))
        .or_else(|| memory.and_then(|obj| read_config_usize(obj, &["maxEntries", "max_entries"])))
        .or_else(|| {
            runtime
                .and_then(|obj| read_config_usize(obj, &["memoryMaxEntries", "memory_max_entries"]))
        });

    let recall_top_k = memory
        .and_then(|obj| read_config_usize(obj, &["recallTopK", "recall_top_k", "topK", "top_k"]))
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_usize(obj, &["memoryRecallTopK", "memory_recall_top_k"])
            })
        });

    let recall_min_score = memory
        .and_then(|obj| {
            read_config_f64(
                obj,
                &[
                    "recallMinScore",
                    "recall_min_score",
                    "minScore",
                    "min_score",
                ],
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_f64(obj, &["memoryRecallMinScore", "memory_recall_min_score"])
            })
        });

    MemoryRuntimeConfig {
        enabled,
        zvec_store_path,
        graph_store_path,
        max_entries,
        recall_top_k,
        recall_min_score,
    }
}

fn runtime_feature_profile_from_config(config: &Value) -> RuntimeFeatureProfile {
    if let Ok(raw) = env::var(RUNTIME_PROFILE_ENV) {
        if let Some(profile) = RuntimeFeatureProfile::from_raw(&raw) {
            return profile;
        }
    }

    let runtime = config.get("runtime").and_then(Value::as_object);
    let root = config.as_object();
    runtime
        .and_then(|obj| {
            read_config_string(obj, &["profile", "runtimeProfile", "runtime_profile"], 32)
        })
        .or_else(|| {
            root.and_then(|obj| {
                read_config_string(obj, &["profile", "runtimeProfile", "runtime_profile"], 32)
            })
        })
        .and_then(|raw| RuntimeFeatureProfile::from_raw(&raw))
        .unwrap_or(RuntimeFeatureProfile::Core)
}

fn agent_self_healing_runtime_config_from_config(config: &Value) -> AgentSelfHealingRuntimeConfig {
    let profile = runtime_feature_profile_from_config(config);
    let mut runtime = AgentSelfHealingRuntimeConfig::defaults_for_profile(profile);

    let root = config.as_object();
    let runtime_obj = config.get("runtime").and_then(Value::as_object);
    let agent_obj = config.get("agent").and_then(Value::as_object);
    let self_healing_obj = config.get("selfHealing").and_then(Value::as_object);
    let runtime_self_healing =
        runtime_obj.and_then(|obj| read_config_object(obj, &["selfHealing", "self_healing"]));
    let agent_self_healing =
        agent_obj.and_then(|obj| read_config_object(obj, &["selfHealing", "self_healing"]));

    let enabled = runtime_self_healing
        .and_then(|obj| read_config_bool(obj, &["enabled"]))
        .or_else(|| agent_self_healing.and_then(|obj| read_config_bool(obj, &["enabled"])))
        .or_else(|| self_healing_obj.and_then(|obj| read_config_bool(obj, &["enabled"])))
        .or_else(|| {
            runtime_obj.and_then(|obj| {
                read_config_bool(
                    obj,
                    &[
                        "agentSelfHealingEnabled",
                        "agent_self_healing_enabled",
                        "selfHealingEnabled",
                        "self_healing_enabled",
                    ],
                )
            })
        })
        .or_else(|| {
            root.and_then(|obj| {
                read_config_bool(
                    obj,
                    &[
                        "agentSelfHealingEnabled",
                        "agent_self_healing_enabled",
                        "selfHealingEnabled",
                        "self_healing_enabled",
                    ],
                )
            })
        })
        .or_else(|| {
            env::var(AGENT_SELF_HEAL_ENABLED_ENV)
                .ok()
                .and_then(|raw| json_value_as_bool(&Value::String(raw)))
        });

    let max_attempts = runtime_self_healing
        .and_then(|obj| read_config_usize(obj, &["maxAttempts", "max_attempts"]))
        .or_else(|| {
            agent_self_healing
                .and_then(|obj| read_config_usize(obj, &["maxAttempts", "max_attempts"]))
        })
        .or_else(|| {
            self_healing_obj
                .and_then(|obj| read_config_usize(obj, &["maxAttempts", "max_attempts"]))
        })
        .or_else(|| {
            runtime_obj.and_then(|obj| {
                read_config_usize(
                    obj,
                    &[
                        "agentSelfHealingMaxAttempts",
                        "agent_self_healing_max_attempts",
                        "selfHealingMaxAttempts",
                        "self_healing_max_attempts",
                    ],
                )
            })
        })
        .or_else(|| {
            root.and_then(|obj| {
                read_config_usize(
                    obj,
                    &[
                        "agentSelfHealingMaxAttempts",
                        "agent_self_healing_max_attempts",
                        "selfHealingMaxAttempts",
                        "self_healing_max_attempts",
                    ],
                )
            })
        })
        .or_else(|| {
            env::var(AGENT_SELF_HEAL_MAX_ATTEMPTS_ENV)
                .ok()
                .and_then(|raw| raw.trim().parse::<usize>().ok())
        })
        .map(|value| value.min(AGENT_SELF_HEAL_MAX_ATTEMPTS_CAP));

    let backoff_ms = runtime_self_healing
        .and_then(|obj| read_config_u64(obj, &["backoffMs", "backoff_ms"]))
        .or_else(|| {
            agent_self_healing.and_then(|obj| read_config_u64(obj, &["backoffMs", "backoff_ms"]))
        })
        .or_else(|| {
            self_healing_obj.and_then(|obj| read_config_u64(obj, &["backoffMs", "backoff_ms"]))
        })
        .or_else(|| {
            runtime_obj.and_then(|obj| {
                read_config_u64(
                    obj,
                    &[
                        "agentSelfHealingBackoffMs",
                        "agent_self_healing_backoff_ms",
                        "selfHealingBackoffMs",
                        "self_healing_backoff_ms",
                    ],
                )
            })
        })
        .or_else(|| {
            root.and_then(|obj| {
                read_config_u64(
                    obj,
                    &[
                        "agentSelfHealingBackoffMs",
                        "agent_self_healing_backoff_ms",
                        "selfHealingBackoffMs",
                        "self_healing_backoff_ms",
                    ],
                )
            })
        })
        .or_else(|| {
            env::var(AGENT_SELF_HEAL_BACKOFF_MS_ENV)
                .ok()
                .and_then(|raw| raw.trim().parse::<u64>().ok())
        })
        .map(|value| value.min(AGENT_SELF_HEAL_MAX_BACKOFF_MS));

    if let Some(enabled) = enabled {
        runtime.enabled = enabled;
    }
    if let Some(max_attempts) = max_attempts {
        runtime.max_attempts = max_attempts;
    }
    if let Some(backoff_ms) = backoff_ms {
        runtime.backoff_ms = backoff_ms;
    }

    runtime
}

fn channel_runtime_config_from_config(config: &Value) -> ChannelRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let channels = config.get("channels").and_then(Value::as_object);
    let channel_runtime = config.get("channelRuntime").and_then(Value::as_object);

    let store_path = channel_runtime
        .and_then(|obj| {
            read_config_string(
                obj,
                &[
                    "storePath",
                    "store_path",
                    "statePath",
                    "state_path",
                    "runtimeStorePath",
                    "runtime_store_path",
                ],
                2048,
            )
        })
        .or_else(|| {
            channels.and_then(|obj| {
                read_config_string(
                    obj,
                    &[
                        "runtimeStorePath",
                        "runtime_store_path",
                        "storePath",
                        "store_path",
                        "statePath",
                        "state_path",
                    ],
                    2048,
                )
            })
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(
                    obj,
                    &["channelRuntimeStorePath", "channel_runtime_store_path"],
                    2048,
                )
            })
        });

    ChannelRuntimeConfig { store_path }
}

fn device_pair_runtime_config_from_config(config: &Value) -> DevicePairRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let device_pair = config.get("devicePair").and_then(Value::as_object);
    let device_pair_nested = config
        .get("device")
        .and_then(Value::as_object)
        .and_then(|device| device.get("pair").and_then(Value::as_object));

    let store_path = device_pair
        .and_then(|obj| {
            read_config_string(
                obj,
                &["storePath", "store_path", "statePath", "state_path"],
                2048,
            )
        })
        .or_else(|| {
            device_pair_nested.and_then(|obj| {
                read_config_string(
                    obj,
                    &["storePath", "store_path", "statePath", "state_path"],
                    2048,
                )
            })
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(
                    obj,
                    &["devicePairStorePath", "device_pair_store_path"],
                    2048,
                )
            })
        });

    DevicePairRuntimeConfig { store_path }
}

fn node_pair_runtime_config_from_config(config: &Value) -> NodePairRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let node_pair = config.get("nodePair").and_then(Value::as_object);
    let node_pair_nested = config
        .get("node")
        .and_then(Value::as_object)
        .and_then(|node| node.get("pair").and_then(Value::as_object));

    let store_path = node_pair
        .and_then(|obj| {
            read_config_string(
                obj,
                &["storePath", "store_path", "statePath", "state_path"],
                2048,
            )
        })
        .or_else(|| {
            node_pair_nested.and_then(|obj| {
                read_config_string(
                    obj,
                    &["storePath", "store_path", "statePath", "state_path"],
                    2048,
                )
            })
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(obj, &["nodePairStorePath", "node_pair_store_path"], 2048)
            })
        });

    NodePairRuntimeConfig { store_path }
}

fn config_runtime_config_from_config(config: &Value) -> ConfigRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let config_obj = config.get("config").and_then(Value::as_object);
    let store_path = config_obj
        .and_then(|obj| {
            read_config_string(
                obj,
                &["storePath", "store_path", "statePath", "state_path"],
                2048,
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(obj, &["configStorePath", "config_store_path"], 2048)
            })
        });
    ConfigRuntimeConfig { store_path }
}

fn web_login_runtime_config_from_config(config: &Value) -> WebLoginRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let web_login = config
        .get("webLogin")
        .and_then(Value::as_object)
        .or_else(|| {
            config
                .get("web")
                .and_then(Value::as_object)
                .and_then(|web| web.get("login").and_then(Value::as_object))
        });
    let store_path = web_login
        .and_then(|obj| {
            read_config_string(
                obj,
                &["storePath", "store_path", "statePath", "state_path"],
                2048,
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(obj, &["webLoginStorePath", "web_login_store_path"], 2048)
            })
        });
    WebLoginRuntimeConfig { store_path }
}

fn oauth_runtime_config_from_config(config: &Value) -> OAuthRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let auth_oauth = config
        .get("auth")
        .and_then(Value::as_object)
        .and_then(|auth| auth.get("oauth").and_then(Value::as_object))
        .or_else(|| config.get("oauth").and_then(Value::as_object));
    let store_path = auth_oauth
        .and_then(|obj| {
            read_config_string(
                obj,
                &["storePath", "store_path", "statePath", "state_path"],
                2048,
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(obj, &["oauthStorePath", "oauth_store_path"], 2048)
            })
        });
    OAuthRuntimeConfig { store_path }
}

fn wizard_runtime_config_from_config(config: &Value) -> WizardRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let wizard = config.get("wizard").and_then(Value::as_object);
    let store_path = wizard
        .and_then(|obj| {
            read_config_string(
                obj,
                &["storePath", "store_path", "statePath", "state_path"],
                2048,
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(obj, &["wizardStorePath", "wizard_store_path"], 2048)
            })
        });
    WizardRuntimeConfig { store_path }
}

fn node_host_runtime_config_from_config(config: &Value) -> NodeHostRuntimeConfig {
    let runtime = config.get("runtime").and_then(Value::as_object);
    let node = config.get("node").and_then(Value::as_object);
    let node_host = config
        .get("nodeHost")
        .and_then(Value::as_object)
        .or_else(|| {
            node.and_then(|node_obj| node_obj.get("hostRuntime").and_then(Value::as_object))
        });

    let local_node_ids = node_host
        .and_then(|obj| read_config_string_list(obj, &["localNodeIds", "local_node_ids"], 128, 128))
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string_list(obj, &["localNodeIds", "local_node_ids"], 128, 128)
            })
        })
        .unwrap_or_default();

    let allow_system_run = node_host
        .and_then(|obj| read_config_bool(obj, &["allowSystemRun", "allow_system_run"]))
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_bool(obj, &["allowLocalSystemRun", "allow_local_system_run"])
            })
        })
        .unwrap_or(false);

    let system_run_timeout_ms = node_host
        .and_then(|obj| {
            read_config_u64(
                obj,
                &[
                    "systemRunTimeoutMs",
                    "system_run_timeout_ms",
                    "timeoutMs",
                    "timeout_ms",
                ],
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_u64(
                    obj,
                    &["localSystemRunTimeoutMs", "local_system_run_timeout_ms"],
                )
            })
        })
        .map(|value| value.clamp(500, 120_000))
        .unwrap_or(LOCAL_NODE_HOST_SYSTEM_RUN_TIMEOUT_MS);

    let external_persistent = node_host
        .and_then(|obj| {
            read_config_bool(
                obj,
                &[
                    "externalPersistent",
                    "external_persistent",
                    "hostPersistent",
                    "host_persistent",
                    "persistent",
                ],
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_bool(
                    obj,
                    &[
                        "nodeHostExternalPersistent",
                        "node_host_external_persistent",
                        "externalNodeHostPersistent",
                    ],
                )
            })
        })
        .unwrap_or(false);

    let external_queue_capacity = node_host
        .and_then(|obj| {
            read_config_usize(
                obj,
                &[
                    "externalQueueCapacity",
                    "external_queue_capacity",
                    "hostQueueCapacity",
                    "host_queue_capacity",
                    "queueCapacity",
                    "queue_capacity",
                ],
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_usize(
                    obj,
                    &[
                        "nodeHostExternalQueueCapacity",
                        "node_host_external_queue_capacity",
                        "externalNodeHostQueueCapacity",
                    ],
                )
            })
        })
        .map(|value| value.clamp(1, 1_024))
        .unwrap_or(LOCAL_NODE_HOST_EXTERNAL_QUEUE_CAPACITY);

    let external_idle_timeout_ms = node_host
        .and_then(|obj| {
            read_config_u64(
                obj,
                &[
                    "externalIdleTimeoutMs",
                    "external_idle_timeout_ms",
                    "hostIdleTimeoutMs",
                    "host_idle_timeout_ms",
                    "idleTimeoutMs",
                    "idle_timeout_ms",
                ],
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_u64(
                    obj,
                    &[
                        "nodeHostExternalIdleTimeoutMs",
                        "node_host_external_idle_timeout_ms",
                        "externalNodeHostIdleTimeoutMs",
                    ],
                )
            })
        })
        .map(|value| value.clamp(1_000, 600_000))
        .unwrap_or(LOCAL_NODE_HOST_EXTERNAL_IDLE_TIMEOUT_MS);

    let external_command = node_host
        .and_then(|obj| {
            read_config_string(
                obj,
                &[
                    "externalCommand",
                    "external_command",
                    "hostCommand",
                    "host_command",
                    "command",
                ],
                1_024,
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string(
                    obj,
                    &[
                        "nodeHostCommand",
                        "node_host_command",
                        "externalNodeHostCommand",
                    ],
                    1_024,
                )
            })
        });
    let external_args = node_host
        .and_then(|obj| {
            read_config_string_list(
                obj,
                &["externalArgs", "external_args", "hostArgs", "host_args"],
                32,
                512,
            )
        })
        .or_else(|| {
            runtime.and_then(|obj| {
                read_config_string_list(
                    obj,
                    &["nodeHostArgs", "node_host_args", "externalNodeHostArgs"],
                    32,
                    512,
                )
            })
        })
        .unwrap_or_default();

    let mut external_commands = HashMap::new();
    if let Some(map) = runtime.and_then(|obj| {
        read_config_object(
            obj,
            &[
                "nodeHostCommands",
                "node_host_commands",
                "externalNodeHostCommands",
            ],
        )
    }) {
        collect_node_host_external_command_overrides(
            &mut external_commands,
            map,
            external_command.as_deref(),
            &external_args,
            false,
        );
    }
    if let Some(map) = node_host.and_then(|obj| {
        read_config_object(
            obj,
            &[
                "externalCommands",
                "external_commands",
                "hostCommands",
                "host_commands",
            ],
        )
    }) {
        collect_node_host_external_command_overrides(
            &mut external_commands,
            map,
            external_command.as_deref(),
            &external_args,
            true,
        );
    }

    let mut external_platforms: HashMap<String, NodeHostPlatformRuntimeConfig> = HashMap::new();
    if let Some(map) = runtime.and_then(|obj| {
        read_config_object(
            obj,
            &[
                "nodeHostExternalPlatforms",
                "node_host_external_platforms",
                "externalNodeHostPlatforms",
            ],
        )
    }) {
        collect_node_host_external_platform_overrides(
            &mut external_platforms,
            map,
            external_command.as_deref(),
            &external_args,
            false,
        );
    }
    if let Some(map) = node_host.and_then(|obj| {
        read_config_object(
            obj,
            &[
                "externalPlatforms",
                "external_platforms",
                "hostPlatforms",
                "host_platforms",
            ],
        )
    }) {
        collect_node_host_external_platform_overrides(
            &mut external_platforms,
            map,
            external_command.as_deref(),
            &external_args,
            true,
        );
    }

    NodeHostRuntimeConfig {
        local_node_ids,
        allow_system_run,
        system_run_timeout_ms,
        external_persistent,
        external_queue_capacity,
        external_idle_timeout_ms,
        external_command,
        external_args,
        external_commands,
        external_platforms,
    }
}

fn node_command_policy_config_from_config(config: &Value) -> NodeCommandPolicyConfig {
    let gateway_nodes = config
        .get("gateway")
        .and_then(Value::as_object)
        .and_then(|gateway| gateway.get("nodes").and_then(Value::as_object));
    let root_nodes = config.get("nodes").and_then(Value::as_object);
    let node = config.get("node").and_then(Value::as_object);
    let node_policy = node.and_then(|node_obj| node_obj.get("policy").and_then(Value::as_object));

    let allow_commands = gateway_nodes
        .and_then(|obj| {
            read_config_string_list(obj, &["allowCommands", "allow_commands"], 256, 160)
        })
        .or_else(|| {
            root_nodes.and_then(|obj| {
                read_config_string_list(obj, &["allowCommands", "allow_commands"], 256, 160)
            })
        })
        .or_else(|| {
            node.and_then(|obj| {
                read_config_string_list(obj, &["allowCommands", "allow_commands"], 256, 160)
            })
        })
        .or_else(|| {
            node_policy.and_then(|obj| {
                read_config_string_list(obj, &["allowCommands", "allow_commands"], 256, 160)
            })
        })
        .unwrap_or_default();
    let deny_commands = gateway_nodes
        .and_then(|obj| read_config_string_list(obj, &["denyCommands", "deny_commands"], 256, 160))
        .or_else(|| {
            root_nodes.and_then(|obj| {
                read_config_string_list(obj, &["denyCommands", "deny_commands"], 256, 160)
            })
        })
        .or_else(|| {
            node.and_then(|obj| {
                read_config_string_list(obj, &["denyCommands", "deny_commands"], 256, 160)
            })
        })
        .or_else(|| {
            node_policy.and_then(|obj| {
                read_config_string_list(obj, &["denyCommands", "deny_commands"], 256, 160)
            })
        })
        .unwrap_or_default();

    NodeCommandPolicyConfig {
        allow_commands,
        deny_commands,
    }
}

fn read_config_object<'a>(
    object: &'a serde_json::Map<String, Value>,
    keys: &[&str],
) -> Option<&'a serde_json::Map<String, Value>> {
    keys.iter()
        .find_map(|key| object.get(*key).and_then(Value::as_object))
}

fn read_config_string(
    object: &serde_json::Map<String, Value>,
    keys: &[&str],
    max_len: usize,
) -> Option<String> {
    keys.iter().find_map(|key| {
        object
            .get(*key)
            .and_then(Value::as_str)
            .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), max_len))
    })
}

fn read_config_u64(object: &serde_json::Map<String, Value>, keys: &[&str]) -> Option<u64> {
    keys.iter()
        .find_map(|key| object.get(*key).and_then(config_value_as_u64))
}

fn read_config_f64(object: &serde_json::Map<String, Value>, keys: &[&str]) -> Option<f64> {
    keys.iter()
        .find_map(|key| object.get(*key).and_then(config_value_as_f64))
}

fn read_config_bool(object: &serde_json::Map<String, Value>, keys: &[&str]) -> Option<bool> {
    keys.iter()
        .find_map(|key| object.get(*key).and_then(json_value_as_bool))
}

fn read_config_usize(object: &serde_json::Map<String, Value>, keys: &[&str]) -> Option<usize> {
    keys.iter()
        .find_map(|key| object.get(*key).and_then(config_value_as_usize))
}

fn read_config_string_list(
    object: &serde_json::Map<String, Value>,
    keys: &[&str],
    max_items: usize,
    max_len: usize,
) -> Option<Vec<String>> {
    keys.iter().find_map(|key| {
        let value = object.get(*key)?;
        let Value::Array(items) = value else {
            return None;
        };
        let mut out = Vec::new();
        for item in items {
            let Some(raw) = item.as_str() else {
                continue;
            };
            let Some(normalized) = normalize_optional_text(Some(raw.to_owned()), max_len) else {
                continue;
            };
            if out
                .iter()
                .any(|existing: &String| existing.eq_ignore_ascii_case(&normalized))
            {
                continue;
            }
            out.push(normalized);
            if out.len() >= max_items {
                break;
            }
        }
        Some(out)
    })
}

fn parse_node_host_external_command_entry(
    value: &Value,
    fallback_command: Option<&str>,
    fallback_args: &[String],
) -> Option<NodeHostExternalCommand> {
    match value {
        Value::String(raw_command) => normalize_optional_text(Some(raw_command.clone()), 1_024)
            .map(|command| NodeHostExternalCommand {
                command,
                args: Vec::new(),
            }),
        Value::Object(obj) => {
            let command = read_config_string(
                obj,
                &[
                    "command",
                    "externalCommand",
                    "external_command",
                    "hostCommand",
                    "host_command",
                ],
                1_024,
            )
            .or_else(|| {
                fallback_command
                    .and_then(|value| normalize_optional_text(Some(value.to_owned()), 1_024))
            })?;
            let args = read_config_string_list(
                obj,
                &[
                    "args",
                    "externalArgs",
                    "external_args",
                    "hostArgs",
                    "host_args",
                ],
                32,
                512,
            )
            .unwrap_or_else(|| fallback_args.to_vec());
            Some(NodeHostExternalCommand { command, args })
        }
        _ => None,
    }
}

fn collect_node_host_external_command_overrides(
    target: &mut HashMap<String, NodeHostExternalCommand>,
    source: &serde_json::Map<String, Value>,
    fallback_command: Option<&str>,
    fallback_args: &[String],
    overwrite: bool,
) {
    for (command_key_raw, entry) in source {
        let Some(command_key) = normalize_optional_text(Some(command_key_raw.clone()), 128)
            .map(|value| normalize(&value))
        else {
            continue;
        };
        if command_key.is_empty() {
            continue;
        }
        if !overwrite && target.contains_key(&command_key) {
            continue;
        }
        let Some(parsed) =
            parse_node_host_external_command_entry(entry, fallback_command, fallback_args)
        else {
            continue;
        };
        target.insert(command_key, parsed);
    }
}

fn normalize_node_host_platform_key(value: &str) -> Option<String> {
    let trimmed = normalize_optional_text(Some(value.to_owned()), 64)?;
    let normalized = normalize_node_platform_id(Some(trimmed.as_str()), None).to_owned();
    if normalized == "unknown" {
        Some(normalize(&trimmed))
    } else {
        Some(normalized)
    }
}

fn collect_node_host_external_platform_overrides(
    target: &mut HashMap<String, NodeHostPlatformRuntimeConfig>,
    source: &serde_json::Map<String, Value>,
    fallback_command: Option<&str>,
    fallback_args: &[String],
    overwrite: bool,
) {
    for (platform_key_raw, entry) in source {
        let Some(platform_key) = normalize_node_host_platform_key(platform_key_raw) else {
            continue;
        };
        let Value::Object(platform_config) = entry else {
            continue;
        };
        if !overwrite && target.contains_key(&platform_key) {
            continue;
        }

        let external_command = read_config_string(
            platform_config,
            &[
                "command",
                "externalCommand",
                "external_command",
                "hostCommand",
                "host_command",
            ],
            1_024,
        )
        .or_else(|| {
            fallback_command
                .and_then(|value| normalize_optional_text(Some(value.to_owned()), 1_024))
        });
        let external_args = read_config_string_list(
            platform_config,
            &[
                "args",
                "externalArgs",
                "external_args",
                "hostArgs",
                "host_args",
            ],
            32,
            512,
        )
        .unwrap_or_else(|| fallback_args.to_vec());

        let mut external_commands = HashMap::new();
        if let Some(map) = read_config_object(
            platform_config,
            &[
                "externalCommands",
                "external_commands",
                "hostCommands",
                "host_commands",
                "commands",
            ],
        ) {
            collect_node_host_external_command_overrides(
                &mut external_commands,
                map,
                external_command.as_deref(),
                &external_args,
                true,
            );
        }

        if external_command.is_none() && external_commands.is_empty() {
            continue;
        }
        target.insert(
            platform_key,
            NodeHostPlatformRuntimeConfig {
                external_command,
                external_args,
                external_commands,
            },
        );
    }
}

fn config_value_as_u64(value: &Value) -> Option<u64> {
    match value {
        Value::Number(number) => number.as_u64(),
        Value::String(text) => text.trim().parse::<u64>().ok(),
        _ => None,
    }
}

fn config_value_as_f64(value: &Value) -> Option<f64> {
    match value {
        Value::Number(number) => number.as_f64(),
        Value::String(text) => text.trim().parse::<f64>().ok(),
        _ => None,
    }
}

fn config_value_as_usize(value: &Value) -> Option<usize> {
    match value {
        Value::Number(number) => number.as_u64().and_then(|n| usize::try_from(n).ok()),
        Value::String(text) => text.trim().parse::<usize>().ok(),
        _ => None,
    }
}

fn normalize_http_webhook_url(raw: &str) -> Option<String> {
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return None;
    }
    let parsed = reqwest::Url::parse(trimmed).ok()?;
    match parsed.scheme() {
        "http" | "https" => Some(parsed.to_string()),
        _ => None,
    }
}

fn cron_store_path_is_memory(path: &str) -> bool {
    path.trim().to_ascii_lowercase().starts_with("memory://")
}

fn load_cron_store_disk_state(path: &str) -> Result<CronStoreDiskState, CronRegistryError> {
    if cron_store_path_is_memory(path) {
        return Ok(CronStoreDiskState::default());
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(CronStoreDiskState::default());
    }
    let raw = std::fs::read_to_string(&store_path).map_err(|err| {
        CronRegistryError::Invalid(format!(
            "failed reading cron store {}: {err}",
            store_path.display()
        ))
    })?;
    let parsed = serde_json::from_str::<CronStoreDiskState>(&raw).map_err(|err| {
        CronRegistryError::Invalid(format!(
            "failed parsing cron store {}: {err}",
            store_path.display()
        ))
    })?;
    Ok(parsed)
}

fn persist_cron_store_disk_state(state: &CronState) -> Result<(), CronRegistryError> {
    if cron_store_path_is_memory(&state.store_path) {
        return Ok(());
    }
    let mut jobs = state.jobs.values().cloned().collect::<Vec<_>>();
    jobs.sort_by(|a, b| {
        a.created_at_ms
            .cmp(&b.created_at_ms)
            .then_with(|| a.id.cmp(&b.id))
    });
    let snapshot = CronStoreDiskState {
        version: 1,
        enabled: state.enabled,
        jobs,
    };
    let payload = serde_json::to_string_pretty(&snapshot).map_err(|err| {
        CronRegistryError::Invalid(format!("failed serializing cron store: {err}"))
    })?;
    let store_path = PathBuf::from(&state.store_path);
    if let Some(parent) = store_path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent).map_err(|err| {
                CronRegistryError::Invalid(format!(
                    "failed creating cron store parent directory {}: {err}",
                    parent.display()
                ))
            })?;
        }
    }

    let mut temp_path = store_path.clone();
    let temp_extension = format!(
        "{}.tmp.{}",
        store_path
            .extension()
            .and_then(|value| value.to_str())
            .unwrap_or("json"),
        now_ms()
    );
    temp_path.set_extension(temp_extension);

    std::fs::write(&temp_path, payload).map_err(|err| {
        CronRegistryError::Invalid(format!(
            "failed writing cron store temp file {}: {err}",
            temp_path.display()
        ))
    })?;

    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        CronRegistryError::Invalid(format!(
            "failed moving cron store temp file into place {}: {err}",
            store_path.display()
        ))
    })?;
    Ok(())
}

fn send_store_path_is_memory(path: &str) -> bool {
    path.trim().to_ascii_lowercase().starts_with("memory://")
}

fn load_send_store_disk_state(path: &str) -> Result<SendStoreDiskState, SendRegistryError> {
    if send_store_path_is_memory(path) {
        return Ok(SendStoreDiskState::default());
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(SendStoreDiskState::default());
    }
    let raw = std::fs::read_to_string(&store_path).map_err(|err| {
        SendRegistryError::Invalid(format!(
            "failed reading send cache store {}: {err}",
            store_path.display()
        ))
    })?;
    let parsed = serde_json::from_str::<SendStoreDiskState>(&raw).map_err(|err| {
        SendRegistryError::Invalid(format!(
            "failed parsing send cache store {}: {err}",
            store_path.display()
        ))
    })?;
    Ok(parsed)
}

fn persist_send_store_disk_state(state: &SendState) -> Result<(), SendRegistryError> {
    if send_store_path_is_memory(&state.store_path) {
        return Ok(());
    }
    let mut entries = state
        .cached_by_id
        .iter()
        .map(|(idempotency_key, entry)| SendStoreDiskEntry {
            idempotency_key: idempotency_key.clone(),
            payload: entry.payload.clone(),
            created_at_ms: entry.created_at_ms,
        })
        .collect::<Vec<_>>();
    entries.sort_by(|a, b| {
        a.created_at_ms
            .cmp(&b.created_at_ms)
            .then_with(|| a.idempotency_key.cmp(&b.idempotency_key))
    });
    let snapshot = SendStoreDiskState {
        version: 1,
        ttl_ms: state.ttl_ms,
        max_entries: state.max_entries,
        entries,
    };
    let payload = serde_json::to_string_pretty(&snapshot).map_err(|err| {
        SendRegistryError::Invalid(format!("failed serializing send cache store: {err}"))
    })?;
    let store_path = PathBuf::from(&state.store_path);
    if let Some(parent) = store_path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent).map_err(|err| {
                SendRegistryError::Invalid(format!(
                    "failed creating send cache store parent directory {}: {err}",
                    parent.display()
                ))
            })?;
        }
    }

    let mut temp_path = store_path.clone();
    let temp_extension = format!(
        "{}.tmp.{}",
        store_path
            .extension()
            .and_then(|value| value.to_str())
            .unwrap_or("json"),
        now_ms()
    );
    temp_path.set_extension(temp_extension);

    std::fs::write(&temp_path, payload).map_err(|err| {
        SendRegistryError::Invalid(format!(
            "failed writing send cache store temp file {}: {err}",
            temp_path.display()
        ))
    })?;

    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        SendRegistryError::Invalid(format!(
            "failed moving send cache store temp file into place {}: {err}",
            store_path.display()
        ))
    })?;
    Ok(())
}

fn session_store_path_is_memory(path: &str) -> bool {
    path.trim().to_ascii_lowercase().starts_with("memory://")
}

fn load_session_store_disk_state(
    path: &str,
) -> Result<SessionStoreDiskState, SessionRegistryError> {
    if session_store_path_is_memory(path) {
        return Ok(SessionStoreDiskState::default());
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(SessionStoreDiskState::default());
    }
    let raw = std::fs::read_to_string(&store_path).map_err(|err| {
        SessionRegistryError::Invalid(format!(
            "failed reading session store {}: {err}",
            store_path.display()
        ))
    })?;
    serde_json::from_str::<SessionStoreDiskState>(&raw).map_err(|err| {
        SessionRegistryError::Invalid(format!(
            "failed parsing session store {}: {err}",
            store_path.display()
        ))
    })
}

fn persist_session_store_disk_state(
    path: &str,
    entries: &[SessionEntry],
) -> Result<(), SessionRegistryError> {
    if session_store_path_is_memory(path) {
        return Ok(());
    }
    let mut values = entries.to_vec();
    values.sort_by(|a, b| {
        b.updated_at_ms
            .cmp(&a.updated_at_ms)
            .then_with(|| a.key.cmp(&b.key))
    });
    let snapshot = SessionStoreDiskState {
        version: 1,
        entries: values,
    };
    let payload = serde_json::to_string_pretty(&snapshot).map_err(|err| {
        SessionRegistryError::Invalid(format!("failed serializing session store: {err}"))
    })?;
    let store_path = PathBuf::from(path);
    if let Some(parent) = store_path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent).map_err(|err| {
                SessionRegistryError::Invalid(format!(
                    "failed creating session store parent directory {}: {err}",
                    parent.display()
                ))
            })?;
        }
    }

    let mut temp_path = store_path.clone();
    let temp_extension = format!(
        "{}.tmp.{}",
        store_path
            .extension()
            .and_then(|value| value.to_str())
            .unwrap_or("json"),
        now_ms()
    );
    temp_path.set_extension(temp_extension);

    std::fs::write(&temp_path, payload).map_err(|err| {
        SessionRegistryError::Invalid(format!(
            "failed writing session store temp file {}: {err}",
            temp_path.display()
        ))
    })?;

    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        SessionRegistryError::Invalid(format!(
            "failed moving session store temp file into place {}: {err}",
            store_path.display()
        ))
    })?;
    Ok(())
}

fn channel_runtime_store_path_is_memory(path: &str) -> bool {
    path.trim().to_ascii_lowercase().starts_with("memory://")
}

fn load_channel_runtime_store_disk_state(
    path: &str,
) -> Result<ChannelRuntimeStoreDiskState, String> {
    if channel_runtime_store_path_is_memory(path) {
        return Ok(ChannelRuntimeStoreDiskState::default());
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(ChannelRuntimeStoreDiskState::default());
    }
    let raw = std::fs::read_to_string(&store_path).map_err(|err| {
        format!(
            "failed reading channel runtime store {}: {err}",
            store_path.display()
        )
    })?;
    serde_json::from_str::<ChannelRuntimeStoreDiskState>(&raw).map_err(|err| {
        format!(
            "failed parsing channel runtime store {}: {err}",
            store_path.display()
        )
    })
}

fn persist_channel_runtime_store_disk_state(
    path: &str,
    state: &ChannelRuntimeState,
) -> Result<(), String> {
    if channel_runtime_store_path_is_memory(path) {
        return Ok(());
    }
    let snapshot = ChannelRuntimeStoreDiskState {
        version: 1,
        state: normalize_channel_runtime_state(state.clone()),
    };
    let payload = serde_json::to_string_pretty(&snapshot)
        .map_err(|err| format!("failed serializing channel runtime store: {err}"))?;

    let store_path = PathBuf::from(path);
    if let Some(parent) = store_path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent).map_err(|err| {
                format!(
                    "failed creating channel runtime store parent directory {}: {err}",
                    parent.display()
                )
            })?;
        }
    }

    let mut temp_path = store_path.clone();
    let temp_extension = format!(
        "{}.tmp.{}",
        store_path
            .extension()
            .and_then(|value| value.to_str())
            .unwrap_or("json"),
        now_ms()
    );
    temp_path.set_extension(temp_extension);

    std::fs::write(&temp_path, payload).map_err(|err| {
        format!(
            "failed writing channel runtime store temp file {}: {err}",
            temp_path.display()
        )
    })?;

    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        format!(
            "failed moving channel runtime store temp file into place {}: {err}",
            store_path.display()
        )
    })?;
    Ok(())
}

fn device_pair_store_path_is_memory(path: &str) -> bool {
    path.trim().to_ascii_lowercase().starts_with("memory://")
}

fn load_device_pair_store_disk_state(path: &str) -> Result<DevicePairStoreDiskState, String> {
    if device_pair_store_path_is_memory(path) {
        return Ok(DevicePairStoreDiskState::default());
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(DevicePairStoreDiskState::default());
    }
    let raw = std::fs::read_to_string(&store_path).map_err(|err| {
        format!(
            "failed reading device pair store {}: {err}",
            store_path.display()
        )
    })?;
    serde_json::from_str::<DevicePairStoreDiskState>(&raw).map_err(|err| {
        format!(
            "failed parsing device pair store {}: {err}",
            store_path.display()
        )
    })
}

fn persist_device_pair_store_disk_state(path: &str, state: &DevicePairState) -> Result<(), String> {
    if device_pair_store_path_is_memory(path) {
        return Ok(());
    }
    let mut pending = state
        .pending_by_id
        .values()
        .cloned()
        .collect::<Vec<DevicePairPendingRequest>>();
    pending.sort_by(|a, b| {
        b.ts.cmp(&a.ts)
            .then_with(|| a.request_id.cmp(&b.request_id))
    });

    let mut paired = state
        .paired_by_device_id
        .values()
        .cloned()
        .collect::<Vec<PairedDeviceEntry>>();
    paired.sort_by(|a, b| {
        b.approved_at_ms
            .cmp(&a.approved_at_ms)
            .then_with(|| a.device_id.cmp(&b.device_id))
    });

    let snapshot = DevicePairStoreDiskState {
        version: 1,
        pending,
        paired,
    };
    let payload = serde_json::to_string_pretty(&snapshot)
        .map_err(|err| format!("failed serializing device pair store: {err}"))?;

    let store_path = PathBuf::from(path);
    if let Some(parent) = store_path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent).map_err(|err| {
                format!(
                    "failed creating device pair store parent directory {}: {err}",
                    parent.display()
                )
            })?;
        }
    }

    let mut temp_path = store_path.clone();
    let temp_extension = format!(
        "{}.tmp.{}",
        store_path
            .extension()
            .and_then(|value| value.to_str())
            .unwrap_or("json"),
        now_ms()
    );
    temp_path.set_extension(temp_extension);

    std::fs::write(&temp_path, payload).map_err(|err| {
        format!(
            "failed writing device pair store temp file {}: {err}",
            temp_path.display()
        )
    })?;

    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        format!(
            "failed moving device pair store temp file into place {}: {err}",
            store_path.display()
        )
    })?;
    Ok(())
}

fn node_pair_store_path_is_memory(path: &str) -> bool {
    path.trim().to_ascii_lowercase().starts_with("memory://")
}

fn load_node_pair_store_disk_state(path: &str) -> Result<NodePairStoreDiskState, String> {
    if node_pair_store_path_is_memory(path) {
        return Ok(NodePairStoreDiskState::default());
    }
    let store_path = PathBuf::from(path);
    if !store_path.exists() {
        return Ok(NodePairStoreDiskState::default());
    }
    let raw = std::fs::read_to_string(&store_path).map_err(|err| {
        format!(
            "failed reading node pair store {}: {err}",
            store_path.display()
        )
    })?;
    serde_json::from_str::<NodePairStoreDiskState>(&raw).map_err(|err| {
        format!(
            "failed parsing node pair store {}: {err}",
            store_path.display()
        )
    })
}

fn persist_node_pair_store_disk_state(path: &str, state: &NodePairState) -> Result<(), String> {
    if node_pair_store_path_is_memory(path) {
        return Ok(());
    }
    let mut pending = state
        .pending_by_id
        .values()
        .cloned()
        .collect::<Vec<NodePairPendingRequest>>();
    pending.sort_by(|a, b| {
        b.ts.cmp(&a.ts)
            .then_with(|| a.request_id.cmp(&b.request_id))
    });

    let mut paired = state
        .paired_by_node_id
        .values()
        .cloned()
        .collect::<Vec<PairedNodeEntry>>();
    paired.sort_by(|a, b| {
        b.approved_at_ms
            .cmp(&a.approved_at_ms)
            .then_with(|| a.node_id.cmp(&b.node_id))
    });

    let snapshot = NodePairStoreDiskState {
        version: 1,
        pending,
        paired,
    };
    let payload = serde_json::to_string_pretty(&snapshot)
        .map_err(|err| format!("failed serializing node pair store: {err}"))?;

    let store_path = PathBuf::from(path);
    if let Some(parent) = store_path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent).map_err(|err| {
                format!(
                    "failed creating node pair store parent directory {}: {err}",
                    parent.display()
                )
            })?;
        }
    }

    let mut temp_path = store_path.clone();
    let temp_extension = format!(
        "{}.tmp.{}",
        store_path
            .extension()
            .and_then(|value| value.to_str())
            .unwrap_or("json"),
        now_ms()
    );
    temp_path.set_extension(temp_extension);

    std::fs::write(&temp_path, payload).map_err(|err| {
        format!(
            "failed writing node pair store temp file {}: {err}",
            temp_path.display()
        )
    })?;

    if store_path.exists() {
        let _ = std::fs::remove_file(&store_path);
    }
    std::fs::rename(&temp_path, &store_path).map_err(|err| {
        format!(
            "failed moving node pair store temp file into place {}: {err}",
            store_path.display()
        )
    })?;
    Ok(())
}

fn apply_merge_patch(target: Value, patch: Value) -> Value {
    let Some(patch_obj) = patch.as_object() else {
        return patch;
    };
    let mut target_obj = target.as_object().cloned().unwrap_or_default();
    for (key, patch_value) in patch_obj {
        if patch_value.is_null() {
            target_obj.remove(key);
            continue;
        }
        let existing = target_obj.get(key).cloned().unwrap_or(Value::Null);
        target_obj.insert(
            key.clone(),
            apply_merge_patch(existing, patch_value.clone()),
        );
    }
    Value::Object(target_obj)
}

struct SessionRegistry {
    entries: Mutex<HashMap<String, SessionEntry>>,
    runtime: Mutex<SessionRuntimeState>,
}

#[derive(Debug, Clone)]
enum SessionRegistryError {
    Invalid(String),
}

#[derive(Debug, Clone)]
struct SessionRuntimeState {
    store_path: String,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(default)]
struct SessionStoreDiskState {
    version: u32,
    entries: Vec<SessionEntry>,
}

impl Default for SessionStoreDiskState {
    fn default() -> Self {
        Self {
            version: 1,
            entries: Vec::new(),
        }
    }
}

#[derive(Debug, Clone)]
struct SessionListQuery {
    limit: usize,
    active_minutes: Option<u64>,
    include_global: bool,
    include_unknown: bool,
    search: Option<String>,
    agent_id: Option<String>,
    label: Option<String>,
    spawned_by: Option<String>,
    channel: Option<String>,
    to: Option<String>,
    account_id: Option<String>,
    thread_id: Option<String>,
    include_derived_titles: bool,
    include_last_message: bool,
}

#[derive(Debug, Clone)]
struct SessionResolveQuery {
    label: Option<String>,
    agent_id: Option<String>,
    spawned_by: Option<String>,
    channel: Option<String>,
    to: Option<String>,
    account_id: Option<String>,
    thread_id: Option<String>,
    include_global: bool,
    include_unknown: bool,
}

#[derive(Debug, Clone)]
struct ChatSessionMeta {
    session_id: String,
    thinking_level: Option<String>,
    verbose_level: Option<String>,
}

#[derive(Debug, Clone)]
struct SessionModelRuntimeState {
    provider_override: Option<String>,
    model_override: Option<String>,
    auth_profile_override: Option<String>,
    auth_profile_override_source: Option<AuthProfileSource>,
    auth_profile_override_compaction_count: Option<u64>,
    compaction_count: u64,
}

fn clear_auth_profile_override(entry: &mut SessionEntry) {
    entry.auth_profile_override = None;
    entry.auth_profile_override_source = None;
    entry.auth_profile_override_compaction_count = None;
}

impl SessionRegistry {
    fn new() -> Self {
        Self {
            entries: Mutex::new(HashMap::new()),
            runtime: Mutex::new(SessionRuntimeState {
                store_path: SESSION_STORE_PATH.to_owned(),
            }),
        }
    }

    async fn apply_runtime_config(
        &self,
        runtime: SessionRuntimeConfig,
    ) -> Result<(), SessionRegistryError> {
        let Some(path) = runtime.store_path else {
            return Ok(());
        };
        let mut runtime_guard = self.runtime.lock().await;
        if runtime_guard.store_path.eq_ignore_ascii_case(&path) {
            return Ok(());
        }
        let loaded = load_session_store_disk_state(&path)?;
        let mut entries_guard = self.entries.lock().await;
        runtime_guard.store_path = path.clone();
        *entries_guard = loaded
            .entries
            .into_iter()
            .map(|entry| (entry.key.clone(), entry))
            .collect::<HashMap<_, _>>();
        let snapshot = entries_guard.values().cloned().collect::<Vec<_>>();
        persist_session_store_disk_state(&runtime_guard.store_path, &snapshot)?;
        Ok(())
    }

    async fn persist_entries_snapshot(&self, entries: Vec<SessionEntry>) {
        let store_path = {
            let guard = self.runtime.lock().await;
            guard.store_path.clone()
        };
        let _ = persist_session_store_disk_state(&store_path, &entries);
    }

    async fn record_decision(&self, request: &ActionRequest, decision: &Decision) {
        let session_key = request
            .session_id
            .clone()
            .map(|value| canonicalize_session_key(&value))
            .filter(|value| !value.is_empty())
            .unwrap_or_else(|| "global".to_owned());
        let now = now_ms();

        let mut guard = self.entries.lock().await;
        let entry = guard
            .entry(session_key.clone())
            .or_insert_with(|| SessionEntry::new(&session_key));

        entry.updated_at_ms = now;
        entry.total_requests += 1;
        entry.last_action = Some(decision.action);
        entry.last_risk_score = decision.risk_score;
        let delivery_hints = extract_delivery_context_hints(&request.raw);
        match decision.action {
            DecisionAction::Allow => entry.allowed_count += 1,
            DecisionAction::Review => entry.review_count += 1,
            DecisionAction::Block => entry.blocked_count += 1,
        }
        if request.channel.is_some() || delivery_hints.channel.is_some() {
            entry.channel = request.channel.clone().or(delivery_hints.channel.clone());
        }
        if delivery_hints.to.is_some() {
            entry.last_to = delivery_hints.to.clone();
        }
        if delivery_hints.account_id.is_some() {
            entry.last_account_id = delivery_hints.account_id.clone();
        }
        if delivery_hints.thread_id.is_some() {
            entry.last_thread_id = delivery_hints.thread_id.clone();
        }
        entry.push_history(SessionHistoryEvent {
            at_ms: now,
            kind: SessionHistoryKind::Decision,
            request_id: Some(request.id.clone()),
            text: normalize_optional_text(request.prompt.clone(), 2_048),
            command: normalize_optional_text(request.command.clone(), 1_024),
            action: Some(decision.action),
            risk_score: Some(decision.risk_score),
            source: normalize_optional_text(Some(request.source.clone()), 128),
            channel: request
                .channel
                .clone()
                .or(delivery_hints.channel)
                .or_else(|| entry.channel.clone()),
            to: delivery_hints.to,
            account_id: delivery_hints.account_id,
            thread_id: delivery_hints.thread_id,
            reply_back: None,
        });
        let snapshot = guard.values().cloned().collect::<Vec<_>>();
        drop(guard);
        self.persist_entries_snapshot(snapshot).await;
    }

    async fn record_send(&self, send: SessionSend) -> (SessionView, SessionHistoryRecord) {
        let SessionSend {
            session_key,
            request_id,
            message,
            command,
            source,
            channel,
            to,
            account_id,
            thread_id,
            reply_back,
        } = send;
        let now = now_ms();
        let mut guard = self.entries.lock().await;
        let entry = guard
            .entry(session_key.clone())
            .or_insert_with(|| SessionEntry::new(&session_key));
        entry.updated_at_ms = now;
        if channel.is_some() {
            entry.channel = channel.clone();
        }
        if to.is_some() {
            entry.last_to = to.clone();
        }
        if account_id.is_some() {
            entry.last_account_id = account_id.clone();
        }
        if thread_id.is_some() {
            entry.last_thread_id = thread_id.clone();
        }

        let event = SessionHistoryEvent {
            at_ms: now,
            kind: SessionHistoryKind::Send,
            request_id,
            text: message,
            command,
            action: None,
            risk_score: None,
            source: Some(source),
            channel: channel.or_else(|| entry.channel.clone()),
            to,
            account_id,
            thread_id,
            reply_back,
        };
        entry.push_history(event.clone());

        let record = SessionHistoryRecord::from_event(&entry.key, event);
        let session = entry.to_view(false, false);
        let snapshot = guard.values().cloned().collect::<Vec<_>>();
        drop(guard);
        self.persist_entries_snapshot(snapshot).await;
        (session, record)
    }

    async fn patch(&self, patch: SessionPatch) -> Result<SessionView, String> {
        let now = now_ms();
        let mut guard = self.entries.lock().await;
        if let PatchValue::Set(label) = &patch.label {
            let duplicate = guard.iter().any(|(key, existing)| {
                key != &patch.session_key
                    && existing
                        .label
                        .as_deref()
                        .map(|v| v.eq_ignore_ascii_case(label))
                        .unwrap_or(false)
            });
            if duplicate {
                return Err(format!("label already in use: {label}"));
            }
        }
        let entry = guard
            .entry(patch.session_key.clone())
            .or_insert_with(|| SessionEntry::new(&patch.session_key));
        entry.updated_at_ms = now;
        if let PatchValue::Clear = &patch.spawned_by {
            if entry.spawned_by.is_some() {
                return Err("spawnedBy cannot be cleared once set".to_owned());
            }
        }
        if let PatchValue::Set(spawned_by) = &patch.spawned_by {
            if !is_subagent_session_key(&patch.session_key) {
                return Err("spawnedBy is only supported for subagent sessions".to_owned());
            }
            if let Some(existing) = entry.spawned_by.as_deref() {
                if !existing.eq_ignore_ascii_case(spawned_by) {
                    return Err("spawnedBy cannot be changed once set".to_owned());
                }
            }
        }
        if let PatchValue::Clear = &patch.spawn_depth {
            if entry.spawn_depth.is_some() {
                return Err("spawnDepth cannot be cleared once set".to_owned());
            }
        }
        if let PatchValue::Set(spawn_depth) = &patch.spawn_depth {
            if !is_subagent_session_key(&patch.session_key) {
                return Err("spawnDepth is only supported for subagent sessions".to_owned());
            }
            if let Some(existing) = entry.spawn_depth {
                if existing != *spawn_depth {
                    return Err("spawnDepth cannot be changed once set".to_owned());
                }
            }
        }
        apply_patch_value(&mut entry.send_policy, patch.send_policy);
        apply_patch_value(&mut entry.group_activation, patch.group_activation);
        apply_patch_value(&mut entry.queue_mode, patch.queue_mode);
        apply_patch_value(&mut entry.label, patch.label);
        apply_patch_value(&mut entry.spawned_by, patch.spawned_by);
        apply_patch_value(&mut entry.spawn_depth, patch.spawn_depth);
        apply_patch_value(&mut entry.thinking_level, patch.thinking_level);
        apply_patch_value(&mut entry.verbose_level, patch.verbose_level);
        apply_patch_value(&mut entry.reasoning_level, patch.reasoning_level);
        apply_patch_value(&mut entry.response_usage, patch.response_usage);
        apply_patch_value(&mut entry.elevated_level, patch.elevated_level);
        apply_patch_value(&mut entry.exec_host, patch.exec_host);
        apply_patch_value(&mut entry.exec_security, patch.exec_security);
        apply_patch_value(&mut entry.exec_ask, patch.exec_ask);
        apply_patch_value(&mut entry.exec_node, patch.exec_node);
        match patch.model_override {
            PatchValue::Keep => {}
            PatchValue::Clear => {
                entry.model_override = None;
                entry.provider_override = None;
                clear_auth_profile_override(entry);
            }
            PatchValue::Set(model) => {
                entry.model_override = Some(model.model_override);
                entry.provider_override = model.provider_override;
                clear_auth_profile_override(entry);
            }
        }
        let view = entry.to_view(false, false);
        let snapshot = guard.values().cloned().collect::<Vec<_>>();
        drop(guard);
        self.persist_entries_snapshot(snapshot).await;
        Ok(view)
    }

    async fn get(&self, session_key: &str) -> Option<SessionView> {
        let guard = self.entries.lock().await;
        guard
            .get(session_key)
            .map(|entry| entry.to_view(false, false))
    }

    async fn model_runtime_state(&self, session_key: &str) -> Option<SessionModelRuntimeState> {
        let guard = self.entries.lock().await;
        let entry = guard.get(session_key)?;
        Some(SessionModelRuntimeState {
            provider_override: entry.provider_override.clone(),
            model_override: entry.model_override.clone(),
            auth_profile_override: entry.auth_profile_override.clone(),
            auth_profile_override_source: entry.auth_profile_override_source,
            auth_profile_override_compaction_count: entry.auth_profile_override_compaction_count,
            compaction_count: entry.compaction_count,
        })
    }

    async fn apply_auth_profile_resolution(
        &self,
        session_key: &str,
        profile_id: Option<String>,
        source: Option<AuthProfileSource>,
        compaction_count: Option<u64>,
    ) -> Option<SessionView> {
        let mut guard = self.entries.lock().await;
        let entry = guard.get_mut(session_key)?;
        match profile_id {
            Some(profile_id) => {
                entry.auth_profile_override = Some(profile_id);
                entry.auth_profile_override_source = source;
                entry.auth_profile_override_compaction_count = compaction_count;
            }
            None => {
                clear_auth_profile_override(entry);
            }
        }
        entry.updated_at_ms = now_ms();
        let view = entry.to_view(false, false);
        let snapshot = guard.values().cloned().collect::<Vec<_>>();
        drop(guard);
        self.persist_entries_snapshot(snapshot).await;
        Some(view)
    }

    async fn resolve_key(&self, candidate: &str) -> Option<String> {
        let guard = self.entries.lock().await;
        if guard.contains_key(candidate) {
            return Some(candidate.to_owned());
        }
        guard
            .keys()
            .find(|key| key.eq_ignore_ascii_case(candidate))
            .cloned()
    }

    async fn resolve_session_id(&self, session_id: &str) -> Option<String> {
        let guard = self.entries.lock().await;
        guard
            .values()
            .find(|entry| entry.session_id.eq_ignore_ascii_case(session_id))
            .map(|entry| entry.key.clone())
    }

    async fn chat_meta(&self, session_key: &str) -> Option<ChatSessionMeta> {
        let guard = self.entries.lock().await;
        let entry = guard.get(session_key)?;
        Some(ChatSessionMeta {
            session_id: entry.session_id.clone(),
            thinking_level: entry.thinking_level.clone(),
            verbose_level: entry.verbose_level.clone(),
        })
    }

    async fn resolve_query(&self, query: SessionResolveQuery) -> Option<String> {
        let guard = self.entries.lock().await;
        let mut entries = guard.values().cloned().collect::<Vec<_>>();
        if !query.include_unknown {
            entries.retain(|entry| entry.kind != SessionKind::Other);
        }
        if !query.include_global {
            entries.retain(|entry| !is_global_session(entry));
        }
        if let Some(label) = query.label {
            entries.retain(|entry| {
                entry
                    .label
                    .as_deref()
                    .map(|v| v.eq_ignore_ascii_case(&label))
                    .unwrap_or(false)
            });
        }
        if let Some(agent_id) = query.agent_id {
            entries.retain(|entry| {
                entry
                    .agent_id
                    .as_deref()
                    .map(|v| v.eq_ignore_ascii_case(&agent_id))
                    .unwrap_or(false)
            });
        }
        if let Some(spawned_by) = query.spawned_by {
            entries.retain(|entry| {
                entry
                    .spawned_by
                    .as_deref()
                    .map(|v| v.eq_ignore_ascii_case(&spawned_by))
                    .unwrap_or(false)
            });
        }
        if let Some(channel) = query.channel {
            entries.retain(|entry| {
                entry
                    .channel
                    .as_deref()
                    .map(|value| value.eq_ignore_ascii_case(&channel))
                    .unwrap_or(false)
            });
        }
        if let Some(to) = query.to {
            entries.retain(|entry| {
                entry
                    .last_to
                    .as_deref()
                    .map(|value| value.eq_ignore_ascii_case(&to))
                    .unwrap_or(false)
            });
        }
        if let Some(account_id) = query.account_id {
            entries.retain(|entry| {
                entry
                    .last_account_id
                    .as_deref()
                    .map(|value| value.eq_ignore_ascii_case(&account_id))
                    .unwrap_or(false)
            });
        }
        if let Some(thread_id) = query.thread_id {
            entries.retain(|entry| {
                entry
                    .last_thread_id
                    .as_deref()
                    .map(|value| value.eq_ignore_ascii_case(&thread_id))
                    .unwrap_or(false)
            });
        }
        entries.sort_by(|a, b| {
            b.updated_at_ms
                .cmp(&a.updated_at_ms)
                .then_with(|| a.key.cmp(&b.key))
        });
        entries.first().map(|entry| entry.key.clone())
    }

    async fn list(&self, query: SessionListQuery) -> Vec<SessionView> {
        let guard = self.entries.lock().await;
        let mut items = guard.values().cloned().collect::<Vec<_>>();
        if let Some(mins) = query.active_minutes {
            let min_updated = now_ms().saturating_sub(mins.saturating_mul(60_000));
            items.retain(|entry| entry.updated_at_ms >= min_updated);
        }
        if !query.include_unknown {
            items.retain(|entry| entry.kind != SessionKind::Other);
        }
        if !query.include_global {
            items.retain(|entry| !is_global_session(entry));
        }
        if let Some(agent_id) = query.agent_id {
            items.retain(|entry| {
                entry
                    .agent_id
                    .as_deref()
                    .map(|v| v.eq_ignore_ascii_case(&agent_id))
                    .unwrap_or(false)
            });
        }
        if let Some(label) = query.label {
            items.retain(|entry| {
                entry
                    .label
                    .as_deref()
                    .map(|v| v.eq_ignore_ascii_case(&label))
                    .unwrap_or(false)
            });
        }
        if let Some(spawned_by) = query.spawned_by {
            items.retain(|entry| {
                entry
                    .spawned_by
                    .as_deref()
                    .map(|v| v.eq_ignore_ascii_case(&spawned_by))
                    .unwrap_or(false)
            });
        }
        if let Some(channel) = query.channel {
            items.retain(|entry| {
                entry
                    .channel
                    .as_deref()
                    .map(|value| value.eq_ignore_ascii_case(&channel))
                    .unwrap_or(false)
            });
        }
        if let Some(to) = query.to {
            items.retain(|entry| {
                entry
                    .last_to
                    .as_deref()
                    .map(|value| value.eq_ignore_ascii_case(&to))
                    .unwrap_or(false)
            });
        }
        if let Some(account_id) = query.account_id {
            items.retain(|entry| {
                entry
                    .last_account_id
                    .as_deref()
                    .map(|value| value.eq_ignore_ascii_case(&account_id))
                    .unwrap_or(false)
            });
        }
        if let Some(thread_id) = query.thread_id {
            items.retain(|entry| {
                entry
                    .last_thread_id
                    .as_deref()
                    .map(|value| value.eq_ignore_ascii_case(&thread_id))
                    .unwrap_or(false)
            });
        }
        if let Some(search) = query.search {
            let needle = search.to_ascii_lowercase();
            items.retain(|entry| {
                entry.key.to_ascii_lowercase().contains(&needle)
                    || entry
                        .channel
                        .as_deref()
                        .map(|v| v.to_ascii_lowercase().contains(&needle))
                        .unwrap_or(false)
                    || entry
                        .agent_id
                        .as_deref()
                        .map(|v| v.to_ascii_lowercase().contains(&needle))
                        .unwrap_or(false)
                    || entry
                        .label
                        .as_deref()
                        .map(|v| v.to_ascii_lowercase().contains(&needle))
                        .unwrap_or(false)
                    || entry
                        .spawned_by
                        .as_deref()
                        .map(|v| v.to_ascii_lowercase().contains(&needle))
                        .unwrap_or(false)
            });
        }
        items.sort_by(|a, b| {
            b.updated_at_ms
                .cmp(&a.updated_at_ms)
                .then_with(|| a.key.cmp(&b.key))
        });
        items
            .into_iter()
            .take(query.limit)
            .map(|entry| entry.to_view(query.include_derived_titles, query.include_last_message))
            .collect()
    }

    async fn history(
        &self,
        session_key: Option<&str>,
        limit: Option<usize>,
    ) -> Vec<SessionHistoryRecord> {
        let lim = limit.unwrap_or(100).clamp(1, 1_000);
        let guard = self.entries.lock().await;
        if let Some(key) = session_key {
            return guard
                .get(key)
                .map(|entry| {
                    entry
                        .history
                        .iter()
                        .rev()
                        .take(lim)
                        .cloned()
                        .map(|event| SessionHistoryRecord::from_event(&entry.key, event))
                        .collect()
                })
                .unwrap_or_default();
        }

        let mut merged = guard
            .values()
            .flat_map(|entry| {
                entry
                    .history
                    .iter()
                    .rev()
                    .take(lim)
                    .cloned()
                    .map(|event| SessionHistoryRecord::from_event(&entry.key, event))
                    .collect::<Vec<_>>()
            })
            .collect::<Vec<_>>();
        merged.sort_by(|a, b| b.at_ms.cmp(&a.at_ms));
        merged.truncate(lim);
        merged
    }

    async fn preview(
        &self,
        keys: &[String],
        limit: usize,
        max_chars: usize,
    ) -> Vec<SessionPreviewEntry> {
        let guard = self.entries.lock().await;
        let lim = limit.clamp(1, 256);
        keys.iter()
            .map(|key| {
                let Some(entry) = guard.get(key) else {
                    return SessionPreviewEntry {
                        key: key.clone(),
                        status: "missing".to_owned(),
                        items: Vec::new(),
                    };
                };
                let items = entry
                    .history
                    .iter()
                    .rev()
                    .take(lim)
                    .cloned()
                    .map(|event| SessionPreviewItem {
                        at_ms: event.at_ms,
                        kind: event.kind,
                        text: event
                            .text
                            .as_deref()
                            .map(|v| truncate_text(v, max_chars))
                            .filter(|v| !v.is_empty()),
                        command: event
                            .command
                            .as_deref()
                            .map(|v| truncate_text(v, max_chars))
                            .filter(|v| !v.is_empty()),
                        action: event.action,
                        risk_score: event.risk_score,
                        source: event.source,
                        channel: event.channel,
                        to: event.to,
                        account_id: event.account_id,
                        thread_id: event.thread_id,
                        reply_back: event.reply_back,
                    })
                    .collect::<Vec<_>>();
                SessionPreviewEntry {
                    key: key.clone(),
                    status: if items.is_empty() {
                        "empty".to_owned()
                    } else {
                        "ok".to_owned()
                    },
                    items,
                }
            })
            .collect()
    }

    async fn reset(&self, session_key: &str, reason: String) -> SessionReset {
        let now = now_ms();
        let mut guard = self.entries.lock().await;
        let entry = guard
            .entry(session_key.to_owned())
            .or_insert_with(|| SessionEntry::new(session_key));
        entry.updated_at_ms = now;
        entry.total_requests = 0;
        entry.allowed_count = 0;
        entry.review_count = 0;
        entry.blocked_count = 0;
        entry.last_action = None;
        entry.last_risk_score = 0;
        entry.session_id = next_session_id();
        entry.history.clear();
        let reset = SessionReset {
            session: entry.to_view(false, false),
            reason,
        };
        let snapshot = guard.values().cloned().collect::<Vec<_>>();
        drop(guard);
        self.persist_entries_snapshot(snapshot).await;
        reset
    }

    async fn delete(&self, session_key: &str) -> bool {
        let mut guard = self.entries.lock().await;
        let deleted = guard.remove(session_key).is_some();
        let snapshot = guard.values().cloned().collect::<Vec<_>>();
        drop(guard);
        self.persist_entries_snapshot(snapshot).await;
        deleted
    }

    async fn compact(&self, session_key: &str, max_lines: usize) -> SessionCompactResult {
        let mut guard = self.entries.lock().await;
        let Some(entry) = guard.get_mut(session_key) else {
            return SessionCompactResult {
                compacted: false,
                kept: 0,
                removed: 0,
                reason: Some("missing session".to_owned()),
            };
        };
        let max_lines = max_lines.clamp(1, 100_000);
        let before = entry.history.len();
        if before <= max_lines {
            return SessionCompactResult {
                compacted: false,
                kept: before,
                removed: 0,
                reason: Some("below limit".to_owned()),
            };
        }

        while entry.history.len() > max_lines {
            let _ = entry.history.pop_front();
        }
        entry.updated_at_ms = now_ms();
        entry.compaction_count = entry.compaction_count.saturating_add(1);
        let result = SessionCompactResult {
            compacted: true,
            kept: entry.history.len(),
            removed: before.saturating_sub(entry.history.len()),
            reason: None,
        };
        let snapshot = guard.values().cloned().collect::<Vec<_>>();
        drop(guard);
        self.persist_entries_snapshot(snapshot).await;
        result
    }

    async fn usage(
        &self,
        session_key: Option<&str>,
        limit: Option<usize>,
        window: Option<(i64, i64)>,
        include_context_weight: bool,
    ) -> Vec<SessionUsageView> {
        let lim = limit.unwrap_or(100).clamp(1, 1_000);
        let guard = self.entries.lock().await;
        let mut items = guard
            .values()
            .filter(|entry| session_key.map(|k| k == entry.key).unwrap_or(true))
            .cloned()
            .collect::<Vec<_>>();
        items.sort_by(|a, b| {
            b.total_requests
                .cmp(&a.total_requests)
                .then_with(|| b.updated_at_ms.cmp(&a.updated_at_ms))
        });
        items
            .into_iter()
            .filter_map(|entry| {
                let (
                    total_requests,
                    allowed_count,
                    review_count,
                    blocked_count,
                    last_action,
                    last_risk_score,
                    updated_at_ms,
                ) = if let Some((start_day, end_day)) = window {
                    let mut total_requests = 0_u64;
                    let mut allowed_count = 0_u64;
                    let mut review_count = 0_u64;
                    let mut blocked_count = 0_u64;
                    let mut last_action = None;
                    let mut last_risk_score = 0_u8;
                    let mut updated_at_ms = entry.updated_at_ms;
                    for event in &entry.history {
                        let day = (event.at_ms / 86_400_000) as i64;
                        if day < start_day || day > end_day {
                            continue;
                        }
                        if event.kind != SessionHistoryKind::Decision {
                            continue;
                        }
                        total_requests += 1;
                        match event.action {
                            Some(DecisionAction::Allow) => allowed_count += 1,
                            Some(DecisionAction::Review) => review_count += 1,
                            Some(DecisionAction::Block) => blocked_count += 1,
                            None => {}
                        }
                        last_action = event.action;
                        last_risk_score = event.risk_score.unwrap_or(0);
                        updated_at_ms = event.at_ms;
                    }
                    if total_requests == 0 && session_key.is_none() {
                        return None;
                    }
                    (
                        total_requests,
                        allowed_count,
                        review_count,
                        blocked_count,
                        last_action,
                        last_risk_score,
                        updated_at_ms,
                    )
                } else {
                    (
                        entry.total_requests,
                        entry.allowed_count,
                        entry.review_count,
                        entry.blocked_count,
                        entry.last_action,
                        entry.last_risk_score,
                        entry.updated_at_ms,
                    )
                };

                Some(SessionUsageView {
                    key: entry.key,
                    kind: entry.kind,
                    agent_id: entry.agent_id,
                    channel: entry.channel,
                    label: entry.label,
                    spawned_by: entry.spawned_by,
                    total_requests,
                    allowed_count,
                    review_count,
                    blocked_count,
                    last_action,
                    last_risk_score,
                    updated_at_ms,
                    context_weight: include_context_weight.then_some(Value::Null),
                })
            })
            .take(lim)
            .collect()
    }

    async fn usage_timeseries(
        &self,
        session_key: &str,
        max_points: usize,
    ) -> Option<Vec<SessionUsageTimeseriesPoint>> {
        let guard = self.entries.lock().await;
        let entry = guard.get(session_key)?;
        let mut by_day: HashMap<String, SessionUsageTimeseriesPoint> = HashMap::new();
        for event in &entry.history {
            let date = format_utc_date(event.at_ms);
            let point = by_day
                .entry(date.clone())
                .or_insert_with(|| SessionUsageTimeseriesPoint {
                    date,
                    total_events: 0,
                    decision_events: 0,
                    send_events: 0,
                    allow_count: 0,
                    review_count: 0,
                    block_count: 0,
                });
            point.total_events += 1;
            match event.kind {
                SessionHistoryKind::Decision => {
                    point.decision_events += 1;
                    match event.action {
                        Some(DecisionAction::Allow) => point.allow_count += 1,
                        Some(DecisionAction::Review) => point.review_count += 1,
                        Some(DecisionAction::Block) => point.block_count += 1,
                        None => {}
                    }
                }
                SessionHistoryKind::Send => {
                    point.send_events += 1;
                }
            }
        }
        let mut points = by_day.into_values().collect::<Vec<_>>();
        points.sort_by(|a, b| a.date.cmp(&b.date));
        if points.len() > max_points {
            points = points.split_off(points.len() - max_points);
        }
        Some(points)
    }

    async fn usage_logs(
        &self,
        session_key: &str,
        limit: usize,
    ) -> Option<Vec<SessionHistoryRecord>> {
        let guard = self.entries.lock().await;
        let entry = guard.get(session_key)?;
        Some(
            entry
                .history
                .iter()
                .rev()
                .take(limit.clamp(1, 1_000))
                .cloned()
                .map(|event| SessionHistoryRecord::from_event(&entry.key, event))
                .collect(),
        )
    }

    async fn usage_totals(&self) -> UsageTotals {
        let guard = self.entries.lock().await;
        UsageTotals {
            sessions: guard.len() as u64,
            total_requests: guard.values().map(|e| e.total_requests).sum(),
            allowed_count: guard.values().map(|e| e.allowed_count).sum(),
            review_count: guard.values().map(|e| e.review_count).sum(),
            blocked_count: guard.values().map(|e| e.blocked_count).sum(),
        }
    }

    async fn summary(&self) -> SessionSummary {
        let guard = self.entries.lock().await;
        let total_sessions = guard.len() as u64;
        let total_requests = guard.values().map(|e| e.total_requests).sum::<u64>();
        SessionSummary {
            total_sessions,
            total_requests,
            updated_at_ms: now_ms(),
        }
    }
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct SessionEntry {
    key: String,
    session_id: String,
    kind: SessionKind,
    agent_id: Option<String>,
    channel: Option<String>,
    last_to: Option<String>,
    last_account_id: Option<String>,
    last_thread_id: Option<String>,
    label: Option<String>,
    spawned_by: Option<String>,
    spawn_depth: Option<u32>,
    updated_at_ms: u64,
    total_requests: u64,
    allowed_count: u64,
    review_count: u64,
    blocked_count: u64,
    last_action: Option<DecisionAction>,
    last_risk_score: u8,
    send_policy: Option<SendPolicyOverride>,
    group_activation: Option<GroupActivationMode>,
    queue_mode: Option<SessionQueueMode>,
    thinking_level: Option<String>,
    verbose_level: Option<String>,
    reasoning_level: Option<String>,
    response_usage: Option<ResponseUsageMode>,
    elevated_level: Option<String>,
    exec_host: Option<String>,
    exec_security: Option<String>,
    exec_ask: Option<String>,
    exec_node: Option<String>,
    model_override: Option<String>,
    provider_override: Option<String>,
    compaction_count: u64,
    auth_profile_override: Option<String>,
    auth_profile_override_source: Option<AuthProfileSource>,
    auth_profile_override_compaction_count: Option<u64>,
    history: VecDeque<SessionHistoryEvent>,
}

impl SessionEntry {
    fn new(session_key: &str) -> Self {
        let parsed = parse_session_key(session_key);
        Self {
            key: session_key.to_owned(),
            session_id: next_session_id(),
            kind: parsed.kind,
            agent_id: parsed.agent_id,
            channel: parsed.channel,
            last_to: None,
            last_account_id: None,
            last_thread_id: None,
            label: None,
            spawned_by: None,
            spawn_depth: None,
            updated_at_ms: now_ms(),
            total_requests: 0,
            allowed_count: 0,
            review_count: 0,
            blocked_count: 0,
            last_action: None,
            last_risk_score: 0,
            send_policy: None,
            group_activation: None,
            queue_mode: None,
            thinking_level: None,
            verbose_level: None,
            reasoning_level: None,
            response_usage: None,
            elevated_level: None,
            exec_host: None,
            exec_security: None,
            exec_ask: None,
            exec_node: None,
            model_override: None,
            provider_override: None,
            compaction_count: 0,
            auth_profile_override: None,
            auth_profile_override_source: None,
            auth_profile_override_compaction_count: None,
            history: VecDeque::new(),
        }
    }

    fn to_view(&self, include_derived_title: bool, include_last_message: bool) -> SessionView {
        let derived_title = if include_derived_title {
            self.derived_title()
        } else {
            None
        };
        let display_name = self
            .label
            .clone()
            .or_else(|| derived_title.clone())
            .map(|v| truncate_text(&v, 120));
        let last_message_preview = if include_last_message {
            self.last_message_preview()
        } else {
            None
        };
        SessionView {
            key: self.key.clone(),
            session_id: self.session_id.clone(),
            kind: self.kind,
            agent_id: self.agent_id.clone(),
            display_name,
            derived_title,
            last_message_preview,
            channel: self.channel.clone(),
            last_account_id: self.last_account_id.clone(),
            last_thread_id: self.last_thread_id.clone(),
            delivery_context: SessionDeliveryContext::from_parts(
                self.channel.clone(),
                self.last_to.clone(),
                self.last_account_id.clone(),
                self.last_thread_id.clone(),
            ),
            total_tokens: None,
            total_tokens_fresh: false,
            label: self.label.clone(),
            spawned_by: self.spawned_by.clone(),
            spawn_depth: self.spawn_depth,
            updated_at_ms: self.updated_at_ms,
            total_requests: self.total_requests,
            allowed_count: self.allowed_count,
            review_count: self.review_count,
            blocked_count: self.blocked_count,
            last_action: self.last_action,
            last_risk_score: self.last_risk_score,
            send_policy: self.send_policy,
            group_activation: self.group_activation,
            queue_mode: self.queue_mode,
            thinking_level: self.thinking_level.clone(),
            verbose_level: self.verbose_level.clone(),
            reasoning_level: self.reasoning_level.clone(),
            response_usage: self.response_usage,
            elevated_level: self.elevated_level.clone(),
            exec_host: self.exec_host.clone(),
            exec_security: self.exec_security.clone(),
            exec_ask: self.exec_ask.clone(),
            exec_node: self.exec_node.clone(),
            model_override: self.model_override.clone(),
            provider_override: self.provider_override.clone(),
            auth_profile_override: self.auth_profile_override.clone(),
            auth_profile_override_source: self.auth_profile_override_source,
            auth_profile_override_compaction_count: self.auth_profile_override_compaction_count,
        }
    }

    fn derived_title(&self) -> Option<String> {
        let from_send = self.history.iter().find_map(|event| {
            (event.kind == SessionHistoryKind::Send)
                .then(|| event_preview_text(event, 120))
                .flatten()
        });
        from_send.or_else(|| {
            self.history
                .iter()
                .find_map(|event| event_preview_text(event, 120))
        })
    }

    fn last_message_preview(&self) -> Option<String> {
        self.history
            .iter()
            .rev()
            .find_map(|event| event_preview_text(event, 160))
    }

    fn push_history(&mut self, event: SessionHistoryEvent) {
        if self.history.len() >= MAX_SESSION_HISTORY_PER_SESSION {
            let _ = self.history.pop_front();
        }
        self.history.push_back(event);
    }
}

#[derive(Debug, Clone)]
struct SessionPatch {
    session_key: String,
    send_policy: PatchValue<SendPolicyOverride>,
    group_activation: PatchValue<GroupActivationMode>,
    queue_mode: PatchValue<SessionQueueMode>,
    label: PatchValue<String>,
    spawned_by: PatchValue<String>,
    spawn_depth: PatchValue<u32>,
    thinking_level: PatchValue<String>,
    verbose_level: PatchValue<String>,
    reasoning_level: PatchValue<String>,
    response_usage: PatchValue<ResponseUsageMode>,
    elevated_level: PatchValue<String>,
    exec_host: PatchValue<String>,
    exec_security: PatchValue<String>,
    exec_ask: PatchValue<String>,
    exec_node: PatchValue<String>,
    model_override: PatchValue<ModelOverridePatch>,
}

#[derive(Debug, Clone)]
struct SessionReset {
    session: SessionView,
    reason: String,
}

#[derive(Debug, Clone)]
struct SessionCompactResult {
    compacted: bool,
    kept: usize,
    removed: usize,
    reason: Option<String>,
}

#[derive(Debug, Clone)]
struct SessionSend {
    session_key: String,
    request_id: Option<String>,
    message: Option<String>,
    command: Option<String>,
    source: String,
    channel: Option<String>,
    to: Option<String>,
    account_id: Option<String>,
    thread_id: Option<String>,
    reply_back: Option<bool>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
enum SessionHistoryKind {
    Decision,
    Send,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct SessionHistoryEvent {
    at_ms: u64,
    kind: SessionHistoryKind,
    request_id: Option<String>,
    text: Option<String>,
    command: Option<String>,
    action: Option<DecisionAction>,
    risk_score: Option<u8>,
    source: Option<String>,
    channel: Option<String>,
    to: Option<String>,
    account_id: Option<String>,
    thread_id: Option<String>,
    reply_back: Option<bool>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SessionHistoryRecord {
    #[serde(rename = "sessionKey")]
    session_key: String,
    #[serde(rename = "atMs")]
    at_ms: u64,
    kind: SessionHistoryKind,
    #[serde(rename = "requestId", skip_serializing_if = "Option::is_none")]
    request_id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    text: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    command: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    action: Option<DecisionAction>,
    #[serde(rename = "riskScore", skip_serializing_if = "Option::is_none")]
    risk_score: Option<u8>,
    #[serde(skip_serializing_if = "Option::is_none")]
    source: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    channel: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    to: Option<String>,
    #[serde(rename = "accountId", skip_serializing_if = "Option::is_none")]
    account_id: Option<String>,
    #[serde(rename = "threadId", skip_serializing_if = "Option::is_none")]
    thread_id: Option<String>,
    #[serde(rename = "replyBack", skip_serializing_if = "Option::is_none")]
    reply_back: Option<bool>,
}

impl SessionHistoryRecord {
    fn from_event(session_key: &str, event: SessionHistoryEvent) -> Self {
        Self {
            session_key: session_key.to_owned(),
            at_ms: event.at_ms,
            kind: event.kind,
            request_id: event.request_id,
            text: event.text,
            command: event.command,
            action: event.action,
            risk_score: event.risk_score,
            source: event.source,
            channel: event.channel,
            to: event.to,
            account_id: event.account_id,
            thread_id: event.thread_id,
            reply_back: event.reply_back,
        }
    }
}

#[derive(Debug, Clone, serde::Serialize)]
struct SessionPreviewEntry {
    key: String,
    status: String,
    items: Vec<SessionPreviewItem>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SessionPreviewItem {
    #[serde(rename = "atMs")]
    at_ms: u64,
    kind: SessionHistoryKind,
    #[serde(skip_serializing_if = "Option::is_none")]
    text: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    command: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    action: Option<DecisionAction>,
    #[serde(rename = "riskScore", skip_serializing_if = "Option::is_none")]
    risk_score: Option<u8>,
    #[serde(skip_serializing_if = "Option::is_none")]
    source: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    channel: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    to: Option<String>,
    #[serde(rename = "accountId", skip_serializing_if = "Option::is_none")]
    account_id: Option<String>,
    #[serde(rename = "threadId", skip_serializing_if = "Option::is_none")]
    thread_id: Option<String>,
    #[serde(rename = "replyBack", skip_serializing_if = "Option::is_none")]
    reply_back: Option<bool>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SessionUsageView {
    key: String,
    kind: SessionKind,
    #[serde(rename = "agentId", skip_serializing_if = "Option::is_none")]
    agent_id: Option<String>,
    channel: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    label: Option<String>,
    #[serde(rename = "spawnedBy", skip_serializing_if = "Option::is_none")]
    spawned_by: Option<String>,
    #[serde(rename = "totalRequests")]
    total_requests: u64,
    #[serde(rename = "allowedCount")]
    allowed_count: u64,
    #[serde(rename = "reviewCount")]
    review_count: u64,
    #[serde(rename = "blockedCount")]
    blocked_count: u64,
    #[serde(rename = "lastAction", skip_serializing_if = "Option::is_none")]
    last_action: Option<DecisionAction>,
    #[serde(rename = "lastRiskScore")]
    last_risk_score: u8,
    #[serde(rename = "updatedAtMs")]
    updated_at_ms: u64,
    #[serde(rename = "contextWeight", skip_serializing_if = "Option::is_none")]
    context_weight: Option<Value>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SessionUsageTimeseriesPoint {
    date: String,
    #[serde(rename = "totalEvents")]
    total_events: u64,
    #[serde(rename = "decisionEvents")]
    decision_events: u64,
    #[serde(rename = "sendEvents")]
    send_events: u64,
    #[serde(rename = "allowCount")]
    allow_count: u64,
    #[serde(rename = "reviewCount")]
    review_count: u64,
    #[serde(rename = "blockCount")]
    block_count: u64,
}

#[derive(Debug, Clone, serde::Serialize)]
struct UsageTotals {
    sessions: u64,
    #[serde(rename = "totalRequests")]
    total_requests: u64,
    #[serde(rename = "allowedCount")]
    allowed_count: u64,
    #[serde(rename = "reviewCount")]
    review_count: u64,
    #[serde(rename = "blockedCount")]
    blocked_count: u64,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SendPolicyOverride {
    Allow,
    Deny,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ResponseUsageMode {
    Off,
    Tokens,
    Full,
}

#[derive(Debug, Clone)]
enum PatchValue<T> {
    Keep,
    Clear,
    Set(T),
}

#[derive(Debug, Clone)]
struct ModelOverridePatch {
    provider_override: Option<String>,
    model_override: String,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SessionDeliveryContext {
    #[serde(skip_serializing_if = "Option::is_none")]
    channel: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    to: Option<String>,
    #[serde(rename = "accountId", skip_serializing_if = "Option::is_none")]
    account_id: Option<String>,
    #[serde(rename = "threadId", skip_serializing_if = "Option::is_none")]
    thread_id: Option<String>,
}

impl SessionDeliveryContext {
    fn from_parts(
        channel: Option<String>,
        to: Option<String>,
        account_id: Option<String>,
        thread_id: Option<String>,
    ) -> Option<Self> {
        if channel.is_none() && to.is_none() && account_id.is_none() && thread_id.is_none() {
            return None;
        }
        Some(Self {
            channel,
            to,
            account_id,
            thread_id,
        })
    }
}

#[derive(Debug, Clone, serde::Serialize)]
struct SessionView {
    key: String,
    #[serde(rename = "sessionId")]
    session_id: String,
    kind: SessionKind,
    #[serde(rename = "agentId", skip_serializing_if = "Option::is_none")]
    agent_id: Option<String>,
    #[serde(rename = "displayName", skip_serializing_if = "Option::is_none")]
    display_name: Option<String>,
    #[serde(rename = "derivedTitle", skip_serializing_if = "Option::is_none")]
    derived_title: Option<String>,
    #[serde(rename = "lastMessagePreview", skip_serializing_if = "Option::is_none")]
    last_message_preview: Option<String>,
    channel: Option<String>,
    #[serde(rename = "lastAccountId", skip_serializing_if = "Option::is_none")]
    last_account_id: Option<String>,
    #[serde(rename = "lastThreadId", skip_serializing_if = "Option::is_none")]
    last_thread_id: Option<String>,
    #[serde(rename = "deliveryContext", skip_serializing_if = "Option::is_none")]
    delivery_context: Option<SessionDeliveryContext>,
    #[serde(rename = "totalTokens", skip_serializing_if = "Option::is_none")]
    total_tokens: Option<u64>,
    #[serde(rename = "totalTokensFresh")]
    total_tokens_fresh: bool,
    #[serde(skip_serializing_if = "Option::is_none")]
    label: Option<String>,
    #[serde(rename = "spawnedBy", skip_serializing_if = "Option::is_none")]
    spawned_by: Option<String>,
    #[serde(rename = "spawnDepth", skip_serializing_if = "Option::is_none")]
    spawn_depth: Option<u32>,
    #[serde(rename = "updatedAtMs")]
    updated_at_ms: u64,
    #[serde(rename = "totalRequests")]
    total_requests: u64,
    #[serde(rename = "allowedCount")]
    allowed_count: u64,
    #[serde(rename = "reviewCount")]
    review_count: u64,
    #[serde(rename = "blockedCount")]
    blocked_count: u64,
    #[serde(rename = "lastAction")]
    last_action: Option<DecisionAction>,
    #[serde(rename = "lastRiskScore")]
    last_risk_score: u8,
    #[serde(rename = "sendPolicy", skip_serializing_if = "Option::is_none")]
    send_policy: Option<SendPolicyOverride>,
    #[serde(rename = "groupActivation", skip_serializing_if = "Option::is_none")]
    group_activation: Option<GroupActivationMode>,
    #[serde(rename = "queueMode", skip_serializing_if = "Option::is_none")]
    queue_mode: Option<SessionQueueMode>,
    #[serde(rename = "thinkingLevel", skip_serializing_if = "Option::is_none")]
    thinking_level: Option<String>,
    #[serde(rename = "verboseLevel", skip_serializing_if = "Option::is_none")]
    verbose_level: Option<String>,
    #[serde(rename = "reasoningLevel", skip_serializing_if = "Option::is_none")]
    reasoning_level: Option<String>,
    #[serde(rename = "responseUsage", skip_serializing_if = "Option::is_none")]
    response_usage: Option<ResponseUsageMode>,
    #[serde(rename = "elevatedLevel", skip_serializing_if = "Option::is_none")]
    elevated_level: Option<String>,
    #[serde(rename = "execHost", skip_serializing_if = "Option::is_none")]
    exec_host: Option<String>,
    #[serde(rename = "execSecurity", skip_serializing_if = "Option::is_none")]
    exec_security: Option<String>,
    #[serde(rename = "execAsk", skip_serializing_if = "Option::is_none")]
    exec_ask: Option<String>,
    #[serde(rename = "execNode", skip_serializing_if = "Option::is_none")]
    exec_node: Option<String>,
    #[serde(rename = "modelOverride", skip_serializing_if = "Option::is_none")]
    model_override: Option<String>,
    #[serde(rename = "providerOverride", skip_serializing_if = "Option::is_none")]
    provider_override: Option<String>,
    #[serde(
        rename = "authProfileOverride",
        skip_serializing_if = "Option::is_none"
    )]
    auth_profile_override: Option<String>,
    #[serde(
        rename = "authProfileOverrideSource",
        skip_serializing_if = "Option::is_none"
    )]
    auth_profile_override_source: Option<AuthProfileSource>,
    #[serde(
        rename = "authProfileOverrideCompactionCount",
        skip_serializing_if = "Option::is_none"
    )]
    auth_profile_override_compaction_count: Option<u64>,
}

#[derive(Debug, Clone, serde::Serialize)]
struct SessionSummary {
    #[serde(rename = "totalSessions")]
    total_sessions: u64,
    #[serde(rename = "totalRequests")]
    total_requests: u64,
    #[serde(rename = "updatedAtMs")]
    updated_at_ms: u64,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsListParams {
    limit: Option<usize>,
    #[serde(rename = "activeMinutes", alias = "active_minutes")]
    active_minutes: Option<u64>,
    #[serde(rename = "includeGlobal", alias = "include_global")]
    include_global: Option<bool>,
    #[serde(rename = "includeUnknown", alias = "include_unknown")]
    include_unknown: Option<bool>,
    #[serde(rename = "includeDerivedTitles", alias = "include_derived_titles")]
    include_derived_titles: Option<bool>,
    #[serde(rename = "includeLastMessage", alias = "include_last_message")]
    include_last_message: Option<bool>,
    label: Option<String>,
    #[serde(rename = "spawnedBy", alias = "spawned_by")]
    spawned_by: Option<String>,
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: Option<String>,
    channel: Option<String>,
    to: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    #[serde(rename = "threadId", alias = "thread_id")]
    thread_id: Option<String>,
    search: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct UsageCostParams {
    #[serde(rename = "startDate", alias = "start_date")]
    start_date: Option<String>,
    #[serde(rename = "endDate", alias = "end_date")]
    end_date: Option<String>,
    days: Option<u32>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SetHeartbeatsParams {
    enabled: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SystemEventParams {
    text: Option<String>,
    #[serde(rename = "deviceId", alias = "device_id")]
    device_id: Option<String>,
    #[serde(rename = "instanceId", alias = "instance_id")]
    instance_id: Option<String>,
    host: Option<String>,
    ip: Option<String>,
    mode: Option<String>,
    version: Option<String>,
    platform: Option<String>,
    #[serde(rename = "deviceFamily", alias = "device_family")]
    device_family: Option<String>,
    #[serde(rename = "modelIdentifier", alias = "model_identifier")]
    model_identifier: Option<String>,
    #[serde(rename = "lastInputSeconds", alias = "last_input_seconds")]
    last_input_seconds: Option<f64>,
    reason: Option<String>,
    roles: Option<Vec<String>>,
    scopes: Option<Vec<String>>,
    tags: Option<Vec<String>>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct WakeParams {
    mode: Option<String>,
    text: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct TalkConfigParams {
    #[serde(rename = "includeSecrets", alias = "include_secrets")]
    include_secrets: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct TalkModeParams {
    enabled: Option<bool>,
    phase: Option<String>,
    #[serde(rename = "inputDevice", alias = "input_device")]
    input_device: Option<String>,
    #[serde(rename = "outputDevice", alias = "output_device")]
    output_device: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct TtsStatusParams {}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct TtsToggleParams {}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct TtsConvertParams {
    text: Option<String>,
    channel: Option<String>,
    #[serde(rename = "outputDevice", alias = "output_device")]
    output_device: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct TtsSetProviderParams {
    provider: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct TtsProvidersParams {}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct VoiceWakeGetParams {}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct VoiceWakeSetParams {
    triggers: Option<Value>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct ModelsListParams {}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct AgentsListParams {}

#[derive(Debug, Clone, Deserialize)]
#[serde(deny_unknown_fields)]
struct AgentsCreateParams {
    name: String,
    workspace: String,
    emoji: Option<String>,
    avatar: Option<String>,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(deny_unknown_fields)]
struct AgentsUpdateParams {
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: String,
    name: Option<String>,
    workspace: Option<String>,
    model: Option<String>,
    avatar: Option<String>,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(deny_unknown_fields)]
struct AgentsDeleteParams {
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: String,
    #[serde(rename = "deleteFiles", alias = "delete_files")]
    delete_files: Option<bool>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct AgentsFilesListParams {
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct AgentsFilesGetParams {
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: String,
    name: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct AgentsFilesSetParams {
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: String,
    name: String,
    content: String,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct AgentParams {
    message: String,
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: Option<String>,
    to: Option<String>,
    #[serde(rename = "replyTo", alias = "reply_to")]
    reply_to: Option<String>,
    #[serde(rename = "sessionId", alias = "session_id")]
    session_id: Option<String>,
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    thinking: Option<String>,
    deliver: Option<bool>,
    attachments: Option<Vec<Value>>,
    channel: Option<String>,
    #[serde(rename = "replyChannel", alias = "reply_channel")]
    reply_channel: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    #[serde(rename = "replyAccountId", alias = "reply_account_id")]
    reply_account_id: Option<String>,
    #[serde(rename = "threadId", alias = "thread_id")]
    thread_id: Option<String>,
    #[serde(rename = "groupId", alias = "group_id")]
    group_id: Option<String>,
    #[serde(rename = "groupChannel", alias = "group_channel")]
    group_channel: Option<String>,
    #[serde(rename = "groupSpace", alias = "group_space")]
    group_space: Option<String>,
    timeout: Option<u64>,
    lane: Option<String>,
    #[serde(rename = "extraSystemPrompt", alias = "extra_system_prompt")]
    extra_system_prompt: Option<String>,
    #[serde(rename = "inputProvenance", alias = "input_provenance")]
    input_provenance: Option<Value>,
    #[serde(rename = "idempotencyKey", alias = "idempotency_key")]
    idempotency_key: String,
    label: Option<String>,
    #[serde(rename = "spawnedBy", alias = "spawned_by")]
    spawned_by: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct AgentIdentityParams {
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: Option<String>,
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct AgentWaitParams {
    #[serde(rename = "runId", alias = "run_id")]
    run_id: String,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct SkillsStatusParams {
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct SkillsBinsParams {}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct SkillsInstallParams {
    name: String,
    #[serde(rename = "installId", alias = "install_id")]
    install_id: String,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct SkillsUpdateParams {
    #[serde(rename = "skillKey", alias = "skill_key")]
    skill_key: String,
    enabled: Option<bool>,
    #[serde(rename = "apiKey", alias = "api_key")]
    api_key: Option<String>,
    env: Option<HashMap<String, String>>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct CronListParams {
    #[serde(rename = "includeDisabled", alias = "include_disabled")]
    include_disabled: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct CronStatusParams {}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct CronAddParams {
    name: String,
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: Option<Option<String>>,
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<Option<String>>,
    description: Option<String>,
    enabled: Option<bool>,
    #[serde(rename = "deleteAfterRun", alias = "delete_after_run")]
    delete_after_run: Option<bool>,
    schedule: CronSchedule,
    #[serde(rename = "sessionTarget", alias = "session_target")]
    session_target: Option<String>,
    #[serde(rename = "wakeMode", alias = "wake_mode")]
    wake_mode: Option<String>,
    payload: CronPayload,
    delivery: Option<CronDelivery>,
    notify: Option<bool>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct CronUpdateParams {
    id: Option<String>,
    #[serde(rename = "jobId", alias = "job_id")]
    job_id: Option<String>,
    patch: CronUpdatePatchInput,
}

#[derive(Debug, Deserialize, Default)]
#[serde(default, deny_unknown_fields)]
struct CronUpdatePatchInput {
    name: Option<String>,
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: Option<Option<String>>,
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<Option<String>>,
    description: Option<Option<String>>,
    enabled: Option<bool>,
    #[serde(rename = "deleteAfterRun", alias = "delete_after_run")]
    delete_after_run: Option<bool>,
    schedule: Option<CronSchedule>,
    #[serde(rename = "sessionTarget", alias = "session_target")]
    session_target: Option<String>,
    #[serde(rename = "wakeMode", alias = "wake_mode")]
    wake_mode: Option<String>,
    payload: Option<CronPayloadPatchInput>,
    delivery: Option<CronDeliveryPatchInput>,
    notify: Option<Option<bool>>,
    state: Option<CronJobStatePatchInput>,
}

#[derive(Debug, Deserialize, Default)]
#[serde(default, deny_unknown_fields)]
struct CronPayloadPatchInput {
    kind: Option<String>,
    text: Option<String>,
    message: Option<String>,
    model: Option<String>,
    thinking: Option<String>,
    #[serde(rename = "timeoutSeconds", alias = "timeout_seconds")]
    timeout_seconds: Option<u64>,
    #[serde(
        rename = "allowUnsafeExternalContent",
        alias = "allow_unsafe_external_content"
    )]
    allow_unsafe_external_content: Option<bool>,
    deliver: Option<bool>,
    channel: Option<String>,
    to: Option<String>,
    #[serde(rename = "bestEffortDeliver", alias = "best_effort_deliver")]
    best_effort_deliver: Option<bool>,
}

#[derive(Debug, Deserialize, Default)]
#[serde(default, deny_unknown_fields)]
struct CronDeliveryPatchInput {
    mode: Option<Option<String>>,
    channel: Option<Option<String>>,
    to: Option<Option<String>>,
    #[serde(rename = "bestEffort", alias = "best_effort")]
    best_effort: Option<Option<bool>>,
}

#[derive(Debug, Deserialize, Default)]
#[serde(default, deny_unknown_fields)]
struct CronJobStatePatchInput {
    #[serde(rename = "nextRunAtMs", alias = "next_run_at_ms")]
    next_run_at_ms: Option<Option<u64>>,
    #[serde(rename = "runningAtMs", alias = "running_at_ms")]
    running_at_ms: Option<Option<u64>>,
    #[serde(rename = "lastRunAtMs", alias = "last_run_at_ms")]
    last_run_at_ms: Option<Option<u64>>,
    #[serde(rename = "lastStatus", alias = "last_status")]
    last_status: Option<Option<CronRunStatus>>,
    #[serde(rename = "lastError", alias = "last_error")]
    last_error: Option<Option<String>>,
    #[serde(rename = "lastDurationMs", alias = "last_duration_ms")]
    last_duration_ms: Option<Option<u64>>,
    #[serde(rename = "consecutiveErrors", alias = "consecutive_errors")]
    consecutive_errors: Option<Option<u64>>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct CronRemoveParams {
    id: Option<String>,
    #[serde(rename = "jobId", alias = "job_id")]
    job_id: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct CronRunParams {
    id: Option<String>,
    #[serde(rename = "jobId", alias = "job_id")]
    job_id: Option<String>,
    mode: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct CronRunsParams {
    id: Option<String>,
    #[serde(rename = "jobId", alias = "job_id")]
    job_id: Option<String>,
    limit: Option<usize>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct ChannelsStatusParams {
    probe: Option<bool>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct ChannelsLogoutParams {
    channel: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct UpdateRunParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    note: Option<String>,
    #[serde(rename = "restartDelayMs", alias = "restart_delay_ms")]
    restart_delay_ms: Option<u64>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct ChatHistoryParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: String,
    limit: Option<usize>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct ChatSendParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: String,
    message: String,
    thinking: Option<String>,
    deliver: Option<bool>,
    attachments: Option<Vec<Value>>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
    #[serde(rename = "idempotencyKey", alias = "idempotency_key")]
    idempotency_key: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct ChatAbortParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: String,
    #[serde(rename = "runId", alias = "run_id")]
    run_id: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct ChatInjectParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: String,
    message: String,
    label: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct NodePairRequestParams {
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: String,
    #[serde(rename = "displayName", alias = "display_name")]
    display_name: Option<String>,
    platform: Option<String>,
    version: Option<String>,
    #[serde(rename = "coreVersion", alias = "core_version")]
    core_version: Option<String>,
    #[serde(rename = "uiVersion", alias = "ui_version")]
    ui_version: Option<String>,
    #[serde(rename = "deviceFamily", alias = "device_family")]
    device_family: Option<String>,
    #[serde(rename = "modelIdentifier", alias = "model_identifier")]
    model_identifier: Option<String>,
    caps: Option<Vec<String>>,
    commands: Option<Vec<String>>,
    #[serde(rename = "remoteIp", alias = "remote_ip")]
    remote_ip: Option<String>,
    silent: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct NodePairListParams {}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct NodePairApproveParams {
    #[serde(rename = "requestId", alias = "request_id")]
    request_id: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct NodePairRejectParams {
    #[serde(rename = "requestId", alias = "request_id")]
    request_id: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct NodePairVerifyParams {
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: String,
    token: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct NodeRenameParams {
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: String,
    #[serde(rename = "displayName", alias = "display_name")]
    display_name: String,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct NodeListParams {}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct NodeDescribeParams {
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct NodeInvokeParams {
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: String,
    command: String,
    params: Option<Value>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
    #[serde(rename = "idempotencyKey", alias = "idempotency_key")]
    idempotency_key: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct NodeInvokeResultParams {
    id: String,
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: String,
    ok: bool,
    payload: Option<Value>,
    #[serde(rename = "payloadJSON", alias = "payload_json")]
    payload_json: Option<String>,
    error: Option<NodeInvokeResultError>,
}

#[derive(Debug, Clone, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct NodeInvokeResultError {
    code: Option<String>,
    message: Option<String>,
}

#[derive(Debug, Clone)]
struct LocalNodeCommandExecution {
    ok: bool,
    payload: Option<Value>,
    payload_json: Option<String>,
    error: Option<NodeInvokeResultError>,
}

#[derive(Clone, Copy)]
struct LocalNodeCommandContext<'a> {
    node_id: &'a str,
    platform: Option<&'a str>,
    device_family: Option<&'a str>,
    invoke_id: &'a str,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct NodeEventParams {
    event: String,
    payload: Option<Value>,
    #[serde(rename = "payloadJSON", alias = "payload_json")]
    payload_json: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct PushTestParams {
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: String,
    title: Option<String>,
    body: Option<String>,
    environment: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct BrowserOpenParams {
    url: String,
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: Option<String>,
    node: Option<String>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
    profile: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct CanvasPresentParams {
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: Option<String>,
    node: Option<String>,
    target: Option<String>,
    url: Option<String>,
    x: Option<f64>,
    y: Option<f64>,
    width: Option<f64>,
    height: Option<f64>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
    #[serde(rename = "idempotencyKey", alias = "idempotency_key")]
    idempotency_key: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct ExecApprovalsGetParams {}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct ExecApprovalsSetParams {
    file: Option<Value>,
    #[serde(rename = "baseHash", alias = "base_hash")]
    base_hash: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct ExecApprovalsNodeGetParams {
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct ExecApprovalsNodeSetParams {
    #[serde(rename = "nodeId", alias = "node_id")]
    node_id: String,
    file: Option<Value>,
    #[serde(rename = "baseHash", alias = "base_hash")]
    base_hash: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct ExecApprovalRequestParams {
    id: Option<String>,
    command: String,
    cwd: Option<String>,
    host: Option<String>,
    security: Option<String>,
    ask: Option<String>,
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: Option<String>,
    #[serde(rename = "resolvedPath", alias = "resolved_path")]
    resolved_path: Option<String>,
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
    #[serde(rename = "twoPhase", alias = "two_phase")]
    two_phase: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct ExecApprovalWaitDecisionParams {
    id: Option<String>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct ExecApprovalResolveParams {
    id: String,
    decision: String,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct DevicePairListParams {}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct DevicePairApproveParams {
    #[serde(rename = "requestId", alias = "request_id")]
    request_id: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct DevicePairRejectParams {
    #[serde(rename = "requestId", alias = "request_id")]
    request_id: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct DevicePairRemoveParams {
    #[serde(rename = "deviceId", alias = "device_id")]
    device_id: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct DeviceTokenRotateParams {
    #[serde(rename = "deviceId", alias = "device_id")]
    device_id: String,
    role: String,
    scopes: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct DeviceTokenRevokeParams {
    #[serde(rename = "deviceId", alias = "device_id")]
    device_id: String,
    role: String,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct WebLoginStartParams {
    force: Option<bool>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
    verbose: Option<bool>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct WebLoginWaitParams {
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct AuthOAuthProvidersParams {}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct AuthOAuthStartParams {
    provider: Option<String>,
    #[serde(rename = "providerId", alias = "provider_id")]
    provider_id: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
    force: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct AuthOAuthWaitParams {
    provider: Option<String>,
    #[serde(rename = "providerId", alias = "provider_id")]
    provider_id: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    #[serde(rename = "sessionId", alias = "session_id")]
    session_id: Option<String>,
    #[serde(rename = "timeoutMs", alias = "timeout_ms")]
    timeout_ms: Option<u64>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct AuthOAuthCompleteParams {
    #[serde(rename = "sessionId", alias = "session_id")]
    session_id: String,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    #[serde(rename = "accessToken", alias = "access_token")]
    access_token: Option<String>,
    #[serde(rename = "refreshToken", alias = "refresh_token")]
    refresh_token: Option<String>,
    #[serde(rename = "tokenType", alias = "token_type")]
    token_type: Option<String>,
    #[serde(rename = "expiresAtMs", alias = "expires_at_ms")]
    expires_at_ms: Option<u64>,
    scopes: Option<Vec<String>>,
    source: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct AuthOAuthLogoutParams {
    provider: Option<String>,
    #[serde(rename = "providerId", alias = "provider_id")]
    provider_id: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    all: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct AuthOAuthImportParams {
    providers: Option<Vec<String>>,
    #[serde(rename = "homeDir", alias = "home_dir")]
    home_dir: Option<String>,
    #[serde(rename = "codexHome", alias = "codex_home")]
    codex_home: Option<String>,
    overwrite: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct WizardStartParams {
    mode: Option<String>,
    workspace: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct WizardNextParams {
    #[serde(rename = "sessionId", alias = "session_id")]
    session_id: Option<String>,
    answer: Option<WizardAnswerInput>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct WizardAnswerInput {
    #[serde(rename = "stepId", alias = "step_id")]
    step_id: String,
    value: Option<Value>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default, deny_unknown_fields)]
struct WizardSessionParams {
    #[serde(rename = "sessionId", alias = "session_id")]
    session_id: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct ConfigWriteParams {
    raw: Option<String>,
    #[serde(rename = "baseHash", alias = "base_hash")]
    base_hash: Option<String>,
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    note: Option<String>,
    #[serde(rename = "restartDelayMs", alias = "restart_delay_ms")]
    restart_delay_ms: Option<u64>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct LogsTailParams {
    cursor: Option<u64>,
    limit: Option<usize>,
    #[serde(rename = "maxBytes", alias = "max_bytes")]
    max_bytes: Option<usize>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsPreviewParams {
    keys: Option<Vec<String>>,
    limit: Option<usize>,
    #[serde(rename = "maxChars", alias = "max_chars")]
    max_chars: Option<usize>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsPatchParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsResolveParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
    #[serde(rename = "sessionId", alias = "session_id")]
    session_id: Option<String>,
    label: Option<String>,
    #[serde(rename = "agentId", alias = "agent_id")]
    agent_id: Option<String>,
    #[serde(rename = "spawnedBy", alias = "spawned_by")]
    spawned_by: Option<String>,
    channel: Option<String>,
    to: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    #[serde(rename = "threadId", alias = "thread_id")]
    thread_id: Option<String>,
    #[serde(rename = "includeGlobal", alias = "include_global")]
    include_global: Option<bool>,
    #[serde(rename = "includeUnknown", alias = "include_unknown")]
    include_unknown: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsResetParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
    reason: Option<String>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsDeleteParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
    #[serde(rename = "deleteTranscript", alias = "delete_transcript")]
    delete_transcript: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsCompactParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
    #[serde(rename = "maxLines", alias = "max_lines")]
    max_lines: Option<usize>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsUsageParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
    limit: Option<usize>,
    #[serde(rename = "startDate", alias = "start_date")]
    start_date: Option<String>,
    #[serde(rename = "endDate", alias = "end_date")]
    end_date: Option<String>,
    #[serde(rename = "includeContextWeight", alias = "include_context_weight")]
    include_context_weight: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsUsageTimeseriesParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
    #[serde(rename = "maxPoints", alias = "max_points")]
    max_points: Option<usize>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsUsageLogsParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
    limit: Option<usize>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionsHistoryParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
    #[serde(rename = "sessionId", alias = "session_id")]
    session_id: Option<String>,
    limit: Option<usize>,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct GatewaySendParams {
    to: String,
    message: Option<String>,
    #[serde(rename = "mediaUrl", alias = "media_url")]
    media_url: Option<String>,
    #[serde(rename = "mediaUrls", alias = "media_urls")]
    media_urls: Option<Vec<String>>,
    #[serde(rename = "gifPlayback", alias = "gif_playback")]
    gif_playback: Option<bool>,
    channel: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    #[serde(rename = "threadId", alias = "thread_id")]
    thread_id: Option<String>,
    #[serde(rename = "replyTo", alias = "reply_to")]
    reply_to: Option<String>,
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    #[serde(rename = "idempotencyKey", alias = "idempotency_key")]
    idempotency_key: String,
}

#[derive(Debug, Deserialize)]
#[serde(deny_unknown_fields)]
struct GatewayPollParams {
    to: String,
    question: String,
    options: Vec<String>,
    #[serde(rename = "maxSelections", alias = "max_selections")]
    max_selections: Option<usize>,
    #[serde(rename = "durationSeconds", alias = "duration_seconds")]
    duration_seconds: Option<u64>,
    #[serde(rename = "durationHours", alias = "duration_hours")]
    duration_hours: Option<u64>,
    silent: Option<bool>,
    #[serde(rename = "isAnonymous", alias = "is_anonymous")]
    is_anonymous: Option<bool>,
    #[serde(rename = "threadId", alias = "thread_id")]
    thread_id: Option<String>,
    channel: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    #[serde(rename = "idempotencyKey", alias = "idempotency_key")]
    idempotency_key: String,
}

#[derive(Debug, Deserialize)]
struct SessionsSendParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
    key: Option<String>,
    #[serde(rename = "sessionId", alias = "session_id")]
    session_id: Option<String>,
    #[serde(rename = "message", alias = "text", alias = "prompt", alias = "input")]
    message: Option<String>,
    command: Option<String>,
    #[serde(rename = "requestId", alias = "request_id")]
    request_id: Option<String>,
    source: Option<String>,
    channel: Option<String>,
    to: Option<String>,
    #[serde(rename = "accountId", alias = "account_id")]
    account_id: Option<String>,
    #[serde(rename = "threadId", alias = "thread_id")]
    thread_id: Option<String>,
    #[serde(rename = "replyBack", alias = "reply_back")]
    reply_back: Option<bool>,
    #[serde(rename = "deliveryContext", alias = "delivery_context")]
    delivery_context: Option<Value>,
    #[serde(rename = "includeGlobal", alias = "include_global")]
    include_global: Option<bool>,
    #[serde(rename = "includeUnknown", alias = "include_unknown")]
    include_unknown: Option<bool>,
}

#[derive(Debug, Default, Deserialize)]
#[serde(default)]
struct SessionStatusParams {
    #[serde(rename = "sessionKey", alias = "session_key")]
    session_key: Option<String>,
}

fn decode_params<T>(value: &Value) -> Result<T, serde_json::Error>
where
    T: for<'de> Deserialize<'de>,
{
    if value.is_null() {
        serde_json::from_value(json!({}))
    } else {
        serde_json::from_value(value.clone())
    }
}

fn parse_apns_environment(value: Option<&str>) -> Option<&'static str> {
    let raw = value?.trim().to_ascii_lowercase();
    match raw.as_str() {
        "sandbox" => Some("sandbox"),
        "production" => Some("production"),
        _ => None,
    }
}

fn normalize_apns_token(value: &str) -> Option<String> {
    let mut out = String::with_capacity(value.len());
    for ch in value.chars() {
        if ch == '<' || ch == '>' || ch.is_whitespace() {
            continue;
        }
        out.push(ch.to_ascii_lowercase());
    }
    if is_likely_apns_token(&out) {
        Some(out)
    } else {
        None
    }
}

fn is_likely_apns_token(value: &str) -> bool {
    value.len() >= 32 && value.chars().all(|ch| ch.is_ascii_hexdigit())
}

fn apns_token_suffix(value: &str) -> String {
    let suffix_len = value.len().min(8);
    value[value.len() - suffix_len..].to_owned()
}

fn resolve_apns_bearer_token_from_env() -> Result<String, String> {
    env::var("OPENCLAW_APNS_BEARER_TOKEN")
        .ok()
        .and_then(|value| normalize_optional_text(Some(value), 16_384))
        .ok_or_else(|| "APNs auth missing: set OPENCLAW_APNS_BEARER_TOKEN for push.test".to_owned())
}

fn parse_apns_reason(body: &str) -> Option<String> {
    let trimmed = body.trim();
    if trimmed.is_empty() {
        return None;
    }
    if let Ok(parsed) = serde_json::from_str::<Value>(trimmed) {
        let reason = parsed
            .get("reason")
            .and_then(Value::as_str)
            .and_then(|value| {
                let value = value.trim();
                if value.is_empty() {
                    None
                } else {
                    Some(value.to_owned())
                }
            });
        if reason.is_some() {
            return reason;
        }
    }
    Some(trimmed.chars().take(200).collect())
}

fn parse_apns_registration_event_payload(
    payload: Option<&Value>,
    payload_json: Option<&str>,
) -> Option<ApnsRegistrationEntry> {
    let payload_value = payload
        .cloned()
        .or_else(|| payload_json.and_then(parse_payload_json))?;
    let map = payload_value.as_object()?;
    let node_id = normalize_optional_text(
        map.get("nodeId")
            .or_else(|| map.get("node_id"))
            .and_then(Value::as_str)
            .map(ToOwned::to_owned),
        128,
    )?;
    let token_raw = map
        .get("token")
        .and_then(Value::as_str)
        .map(|value| value.trim().to_owned())
        .filter(|value| !value.is_empty())?;
    let token = normalize_apns_token(&token_raw)?;
    let topic = normalize_optional_text(
        map.get("topic")
            .and_then(Value::as_str)
            .map(ToOwned::to_owned),
        255,
    )?;
    let environment = parse_apns_environment(
        map.get("environment")
            .and_then(Value::as_str)
            .or(Some("sandbox")),
    )
    .unwrap_or("sandbox")
    .to_owned();
    Some(ApnsRegistrationEntry {
        node_id,
        token,
        topic,
        environment,
        updated_at_ms: now_ms(),
    })
}

async fn send_apns_alert(
    bearer_token: &str,
    registration: &ApnsRegistrationEntry,
    node_id: &str,
    title: &str,
    body: &str,
) -> Result<ApnsPushAlertResult, String> {
    let authority = if registration.environment == "production" {
        "https://api.push.apple.com"
    } else {
        "https://api.sandbox.push.apple.com"
    };
    let payload = json!({
        "aps": {
            "alert": {
                "title": title,
                "body": body
            },
            "sound": "default"
        },
        "openclaw": {
            "kind": "push.test",
            "nodeId": node_id,
            "ts": now_ms()
        }
    });
    let url = format!("{authority}/3/device/{}", registration.token);
    let client = reqwest::Client::builder()
        .build()
        .map_err(|err| format!("failed creating APNs client: {err}"))?;
    let response = client
        .post(url)
        .timeout(Duration::from_millis(DEFAULT_APNS_PUSH_TIMEOUT_MS))
        .header("authorization", format!("bearer {bearer_token}"))
        .header("apns-topic", registration.topic.clone())
        .header("apns-push-type", "alert")
        .header("apns-priority", "10")
        .header("apns-expiration", "0")
        .header("content-type", "application/json")
        .json(&payload)
        .send()
        .await
        .map_err(|err| format!("APNs request failed: {err}"))?;
    let status = response.status().as_u16();
    let apns_id = response
        .headers()
        .get("apns-id")
        .and_then(|value| value.to_str().ok())
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .map(ToOwned::to_owned);
    let body_text = response.text().await.unwrap_or_default();
    Ok(ApnsPushAlertResult {
        ok: status == 200,
        status,
        apns_id,
        reason: parse_apns_reason(&body_text),
        token_suffix: apns_token_suffix(&registration.token),
        topic: registration.topic.clone(),
        environment: registration.environment.clone(),
    })
}

fn param_patch_value(params: &Value, keys: &[&str]) -> Option<Option<Value>> {
    let map = params.as_object()?;
    for key in keys {
        if let Some(value) = map.get(*key) {
            if value.is_null() {
                return Some(None);
            }
            return Some(Some(value.clone()));
        }
    }
    None
}

fn parse_group_activation_mode(value: &str) -> Option<GroupActivationMode> {
    match normalize(value).as_str() {
        "mention" => Some(GroupActivationMode::Mention),
        "always" => Some(GroupActivationMode::Always),
        _ => None,
    }
}

fn parse_queue_mode(value: &str) -> Option<SessionQueueMode> {
    match normalize(value).as_str() {
        "followup" => Some(SessionQueueMode::Followup),
        "steer" => Some(SessionQueueMode::Steer),
        "collect" => Some(SessionQueueMode::Collect),
        _ => None,
    }
}

fn parse_reset_reason(value: Option<String>) -> Result<String, String> {
    let normalized = normalize_optional_text(value, 16).unwrap_or_else(|| "reset".to_owned());
    match normalize(&normalized).as_str() {
        "new" => Ok("new".to_owned()),
        "reset" => Ok("reset".to_owned()),
        _ => Err("reason must be new|reset".to_owned()),
    }
}

fn parse_wake_mode(value: Option<String>) -> Result<&'static str, String> {
    let Some(mode) = normalize_optional_text(value, 32) else {
        return Err("invalid wake params: mode required".to_owned());
    };
    match normalize(&mode).as_str() {
        "now" => Ok("now"),
        "next-heartbeat" => Ok("next-heartbeat"),
        _ => Err("invalid wake params: mode must be now|next-heartbeat".to_owned()),
    }
}

fn resolve_cron_job_id(
    id: Option<String>,
    job_id: Option<String>,
    method_name: &str,
) -> Result<String, String> {
    normalize_optional_text(id.or(job_id), 128)
        .ok_or_else(|| format!("invalid {method_name} params: missing id"))
}

fn parse_cron_run_mode(value: Option<String>) -> Result<CronRunMode, String> {
    let Some(mode) = normalize_optional_text(value, 32) else {
        return Ok(CronRunMode::Force);
    };
    match normalize(&mode).as_str() {
        "force" => Ok(CronRunMode::Force),
        "due" => Ok(CronRunMode::Due),
        _ => Err("invalid cron.run params: mode must be force|due".to_owned()),
    }
}

fn parse_cron_session_target(value: Option<String>) -> Result<String, CronRegistryError> {
    let normalized = normalize_optional_text(value, 32).unwrap_or_else(|| "main".to_owned());
    match normalize(&normalized).as_str() {
        "main" => Ok("main".to_owned()),
        "isolated" => Ok("isolated".to_owned()),
        _ => Err(CronRegistryError::Invalid(
            "sessionTarget must be main|isolated".to_owned(),
        )),
    }
}

fn parse_cron_wake_mode(value: Option<String>) -> Result<String, CronRegistryError> {
    let normalized =
        normalize_optional_text(value, 32).unwrap_or_else(|| "next-heartbeat".to_owned());
    match normalize(&normalized).as_str() {
        "now" => Ok("now".to_owned()),
        "next-heartbeat" => Ok("next-heartbeat".to_owned()),
        _ => Err(CronRegistryError::Invalid(
            "wakeMode must be now|next-heartbeat".to_owned(),
        )),
    }
}

fn normalize_cron_schedule(schedule: CronSchedule) -> Result<CronSchedule, CronRegistryError> {
    match schedule {
        CronSchedule::At { at } => {
            let at = normalize_optional_text(Some(at), 128).ok_or_else(|| {
                CronRegistryError::Invalid("schedule.at is required for kind=at".to_owned())
            })?;
            Ok(CronSchedule::At { at })
        }
        CronSchedule::Every {
            every_ms,
            anchor_ms,
        } => {
            if every_ms == 0 {
                return Err(CronRegistryError::Invalid(
                    "schedule.everyMs must be greater than 0".to_owned(),
                ));
            }
            Ok(CronSchedule::Every {
                every_ms,
                anchor_ms,
            })
        }
        CronSchedule::Cron { expr, tz } => {
            let expr = normalize_optional_text(Some(expr), 256).ok_or_else(|| {
                CronRegistryError::Invalid("schedule.expr is required for kind=cron".to_owned())
            })?;
            Ok(CronSchedule::Cron {
                expr,
                tz: normalize_optional_text(tz, 64),
            })
        }
    }
}

fn normalize_cron_payload(payload: CronPayload) -> Result<CronPayload, CronRegistryError> {
    match payload {
        CronPayload::SystemEvent { text } => {
            let text = normalize_optional_text(Some(text), 4096).ok_or_else(|| {
                CronRegistryError::Invalid(
                    "payload.kind=systemEvent requires non-empty text".to_owned(),
                )
            })?;
            Ok(CronPayload::SystemEvent { text })
        }
        CronPayload::AgentTurn {
            message,
            model,
            thinking,
            timeout_seconds,
            allow_unsafe_external_content,
            deliver,
            channel,
            to,
            best_effort_deliver,
        } => {
            let message = normalize_optional_text(Some(message), 4096).ok_or_else(|| {
                CronRegistryError::Invalid(
                    "payload.kind=agentTurn requires non-empty message".to_owned(),
                )
            })?;
            if matches!(timeout_seconds, Some(0)) {
                return Err(CronRegistryError::Invalid(
                    "payload.timeoutSeconds must be >= 1".to_owned(),
                ));
            }
            Ok(CronPayload::AgentTurn {
                message,
                model: normalize_optional_text(model, 256),
                thinking: normalize_optional_text(thinking, 64),
                timeout_seconds,
                allow_unsafe_external_content,
                deliver,
                channel: normalize_optional_text(channel, 64),
                to: normalize_optional_text(to, 1024),
                best_effort_deliver,
            })
        }
    }
}

fn normalize_cron_delivery(
    delivery: CronDelivery,
    context: &str,
) -> Result<CronDelivery, CronRegistryError> {
    let mode = normalize_optional_text(Some(delivery.mode), 32)
        .ok_or_else(|| CronRegistryError::Invalid(format!("invalid {context} delivery.mode")))?;
    let mode = match normalize(&mode).as_str() {
        "none" => "none",
        "announce" => "announce",
        "webhook" => "webhook",
        _ => {
            return Err(CronRegistryError::Invalid(format!(
                "invalid {context} delivery.mode: expected none|announce|webhook"
            )))
        }
    };
    let normalized = CronDelivery {
        mode: mode.to_owned(),
        channel: normalize_optional_text(delivery.channel, 64),
        to: normalize_optional_text(delivery.to, 1024),
        best_effort: delivery.best_effort,
    };
    if normalized.mode == "webhook" {
        let to = normalized.to.clone().ok_or_else(|| {
            CronRegistryError::Invalid(format!(
                "invalid {context} delivery.to: required for webhook"
            ))
        })?;
        let parsed = Url::parse(&to).map_err(|_| {
            CronRegistryError::Invalid(format!("invalid {context} delivery.to URL"))
        })?;
        let scheme = parsed.scheme();
        if scheme != "http" && scheme != "https" {
            return Err(CronRegistryError::Invalid(format!(
                "invalid {context} delivery.to URL scheme"
            )));
        }
    }
    Ok(normalized)
}

fn legacy_cron_delivery_from_payload(payload: &CronPayload) -> Option<CronDelivery> {
    let CronPayload::AgentTurn {
        deliver,
        channel,
        to,
        best_effort_deliver,
        ..
    } = payload
    else {
        return None;
    };
    let has_legacy_fields = deliver.is_some()
        || channel.as_ref().is_some()
        || to.as_ref().is_some()
        || best_effort_deliver.is_some();
    if !has_legacy_fields {
        return None;
    }
    let mode = if matches!(deliver, Some(false)) {
        "none"
    } else {
        "announce"
    };
    Some(CronDelivery {
        mode: mode.to_owned(),
        channel: normalize_optional_text(channel.clone(), 64),
        to: normalize_optional_text(to.clone(), 1024),
        best_effort: *best_effort_deliver,
    })
}

fn apply_cron_payload_patch(
    current: &CronPayload,
    patch: CronPayloadPatchInput,
) -> Result<(CronPayload, Option<CronDelivery>), CronRegistryError> {
    let explicit_kind = match patch.kind.as_deref().map(normalize) {
        None => None,
        Some(kind) if kind == "systemevent" || kind == "system-event" || kind == "system_event" => {
            Some("systemEvent")
        }
        Some(kind) if kind == "agentturn" || kind == "agent-turn" || kind == "agent_turn" => {
            Some("agentTurn")
        }
        _ => {
            return Err(CronRegistryError::Invalid(
                "invalid cron.update patch.payload.kind".to_owned(),
            ))
        }
    };

    let current_kind = match current {
        CronPayload::SystemEvent { .. } => "systemEvent",
        CronPayload::AgentTurn { .. } => "agentTurn",
    };
    if let Some(kind) = explicit_kind {
        if kind != current_kind {
            return Err(CronRegistryError::Invalid(
                "payload kind cannot be changed in cron.update".to_owned(),
            ));
        }
    }

    match current {
        CronPayload::SystemEvent { text } => {
            if patch.message.is_some()
                || patch.model.is_some()
                || patch.thinking.is_some()
                || patch.timeout_seconds.is_some()
                || patch.allow_unsafe_external_content.is_some()
                || patch.deliver.is_some()
                || patch.channel.is_some()
                || patch.to.is_some()
                || patch.best_effort_deliver.is_some()
            {
                return Err(CronRegistryError::Invalid(
                    "patch.payload for systemEvent cannot include agentTurn fields".to_owned(),
                ));
            }
            let next = normalize_cron_payload(CronPayload::SystemEvent {
                text: patch.text.unwrap_or_else(|| text.clone()),
            })?;
            Ok((next, None))
        }
        CronPayload::AgentTurn {
            message,
            model,
            thinking,
            timeout_seconds,
            allow_unsafe_external_content,
            deliver,
            channel,
            to,
            best_effort_deliver,
        } => {
            if patch.text.is_some() {
                return Err(CronRegistryError::Invalid(
                    "patch.payload for agentTurn cannot include systemEvent text".to_owned(),
                ));
            }
            let next = normalize_cron_payload(CronPayload::AgentTurn {
                message: patch.message.unwrap_or_else(|| message.clone()),
                model: patch.model.or_else(|| model.clone()),
                thinking: patch.thinking.or_else(|| thinking.clone()),
                timeout_seconds: patch.timeout_seconds.or(*timeout_seconds),
                allow_unsafe_external_content: patch
                    .allow_unsafe_external_content
                    .or(*allow_unsafe_external_content),
                deliver: patch.deliver.or(*deliver),
                channel: patch.channel.or_else(|| channel.clone()),
                to: patch.to.or_else(|| to.clone()),
                best_effort_deliver: patch.best_effort_deliver.or(*best_effort_deliver),
            })?;
            let legacy_delivery = legacy_cron_delivery_from_payload(&next);
            Ok((next, legacy_delivery))
        }
    }
}

fn apply_cron_delivery_patch(
    current: Option<CronDelivery>,
    patch: CronDeliveryPatchInput,
) -> Result<Option<CronDelivery>, CronRegistryError> {
    let mut delivery = current.unwrap_or(CronDelivery {
        mode: "none".to_owned(),
        channel: None,
        to: None,
        best_effort: None,
    });
    if let Some(mode) = patch.mode {
        delivery.mode = mode.unwrap_or_else(|| "none".to_owned());
    }
    if let Some(channel) = patch.channel {
        delivery.channel = channel;
    }
    if let Some(to) = patch.to {
        delivery.to = to;
    }
    if let Some(best_effort) = patch.best_effort {
        delivery.best_effort = best_effort;
    }
    let normalized = normalize_cron_delivery(delivery, "cron.update")?;
    Ok(Some(normalized))
}

fn apply_cron_job_state_patch(
    state: &mut CronJobState,
    patch: CronJobStatePatchInput,
) -> Result<(), CronRegistryError> {
    if let Some(value) = patch.next_run_at_ms {
        state.next_run_at_ms = value;
    }
    if let Some(value) = patch.running_at_ms {
        state.running_at_ms = value;
    }
    if let Some(value) = patch.last_run_at_ms {
        state.last_run_at_ms = value;
    }
    if let Some(value) = patch.last_status {
        state.last_status = value;
    }
    if let Some(value) = patch.last_error {
        state.last_error = value.and_then(|v| normalize_optional_text(Some(v), 256));
    }
    if let Some(value) = patch.last_duration_ms {
        state.last_duration_ms = value;
    }
    if let Some(value) = patch.consecutive_errors {
        state.consecutive_errors = value;
    }
    if matches!(
        (&state.last_status, &state.last_error),
        (Some(CronRunStatus::Error), None)
    ) {
        return Err(CronRegistryError::Invalid(
            "state.lastError is required when state.lastStatus=error".to_owned(),
        ));
    }
    Ok(())
}

fn estimate_next_run_at_ms(schedule: &CronSchedule, now: u64) -> Option<u64> {
    match schedule {
        CronSchedule::At { .. } => Some(now),
        CronSchedule::Every {
            every_ms,
            anchor_ms,
        } => {
            let every_ms = *every_ms;
            let anchor = anchor_ms.unwrap_or(now);
            if anchor >= now {
                return Some(anchor);
            }
            let elapsed = now.saturating_sub(anchor);
            let periods = elapsed / every_ms + 1;
            Some(anchor.saturating_add(periods.saturating_mul(every_ms)))
        }
        CronSchedule::Cron { .. } => None,
    }
}

fn build_cron_webhook_dispatch(
    job: &CronJob,
    entry: &CronRunLogEntry,
    defaults: &CronWebhookDefaults,
) -> Option<CronWebhookDispatch> {
    if !matches!(entry.status.as_ref(), Some(CronRunStatus::Ok)) {
        return None;
    }
    let has_summary = entry
        .summary
        .as_deref()
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .is_some();
    if !has_summary {
        return None;
    }
    let delivery = job.delivery.as_ref();
    let delivery_target = delivery
        .filter(|value| value.mode == "webhook")
        .and_then(|value| value.to.clone());
    let (target, source) = if let Some(target) = delivery_target {
        (target, CronWebhookSource::DeliveryMode)
    } else if job.notify.unwrap_or(false) {
        (
            defaults.webhook.clone()?,
            CronWebhookSource::LegacyNotifyFallback,
        )
    } else {
        return None;
    };
    let best_effort = delivery
        .and_then(|value| value.best_effort)
        .unwrap_or(false);
    Some(CronWebhookDispatch {
        target,
        payload: serde_json::to_value(entry).ok()?,
        best_effort,
        authorization_bearer: defaults.webhook_token.clone(),
        source,
    })
}

fn next_cron_job_id() -> String {
    let sequence = CRON_ID_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("cron-{sequence:08x}-{}", now_ms())
}

async fn dispatch_cron_webhook(dispatch: &CronWebhookDispatch) -> Result<(), String> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .build()
        .map_err(|err| format!("failed creating webhook client: {err}"))?;
    let mut request = client.post(&dispatch.target);
    if let Some(token) = dispatch.authorization_bearer.as_ref() {
        request = request.header("Authorization", format!("Bearer {token}"));
    }
    let response = request
        .json(&dispatch.payload)
        .send()
        .await
        .map_err(|err| format!("webhook request failed: {err}"))?;
    if !response.status().is_success() {
        return Err(format!(
            "webhook returned HTTP {}",
            response.status().as_u16()
        ));
    }
    Ok(())
}

fn channel_label(id: &str) -> String {
    match normalize(id).as_str() {
        "whatsapp" => "WhatsApp".to_owned(),
        "telegram" => "Telegram".to_owned(),
        "slack" => "Slack".to_owned(),
        "discord" => "Discord".to_owned(),
        "irc" => "IRC".to_owned(),
        "signal" => "Signal".to_owned(),
        "imessage" => "iMessage".to_owned(),
        "feishu" => "Feishu".to_owned(),
        "mattermost" => "Mattermost".to_owned(),
        "line" => "LINE".to_owned(),
        "nextcloud-talk" => "Nextcloud Talk".to_owned(),
        "nostr" => "Nostr".to_owned(),
        "tlon" => "Tlon".to_owned(),
        "webchat" => "WebChat".to_owned(),
        "bluebubbles" => "BlueBubbles".to_owned(),
        "googlechat" => "Google Chat".to_owned(),
        "msteams" => "Microsoft Teams".to_owned(),
        "matrix" => "Matrix".to_owned(),
        "zalo" => "Zalo".to_owned(),
        "zalouser" => "Zalo Personal".to_owned(),
        other => {
            let mut chars = other.chars();
            let Some(first) = chars.next() else {
                return String::new();
            };
            let mut out = first.to_uppercase().collect::<String>();
            out.push_str(chars.as_str());
            out
        }
    }
}

fn channel_system_image(id: &str) -> &'static str {
    match normalize(id).as_str() {
        "whatsapp" => "message.badge.waveform",
        "telegram" => "paperplane",
        "slack" => "bubble.left.and.bubble.right",
        "discord" => "bubble.left",
        "irc" => "network",
        "signal" => "lock.bubble.right",
        "imessage" => "message.fill",
        "feishu" => "message.badge",
        "mattermost" => "bubble.left.and.bubble.right",
        "line" => "message.fill",
        "nextcloud-talk" => "bubble.left.and.bubble.right",
        "nostr" => "antenna.radiowaves.left.and.right",
        "tlon" => "bubble.left",
        "webchat" => "rectangle.and.pencil.and.ellipsis",
        "bluebubbles" => "bubble.left.and.text.bubble.right",
        "googlechat" => "message.badge",
        "msteams" => "person.2",
        "matrix" => "square.grid.3x3",
        "zalo" => "message.badge",
        "zalouser" => "message.badge",
        _ => "bubble.left",
    }
}

fn parse_patch_text(
    value: Option<Option<Value>>,
    field_name: &str,
    max_len: usize,
) -> Result<PatchValue<String>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) => Ok(PatchValue::Clear),
        Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(raw))) => {
            let trimmed = raw.trim();
            if trimmed.is_empty() {
                return Err(format!("{field_name} cannot be empty"));
            }
            if trimmed.chars().count() > max_len {
                return Err(format!("{field_name} too long (max {max_len})"));
            }
            Ok(PatchValue::Set(trimmed.to_owned()))
        }
        Some(_) => Err(format!("{field_name} must be string or null")),
    }
}

fn parse_patch_u32(value: Option<Option<Value>>) -> Result<PatchValue<u32>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) => Ok(PatchValue::Clear),
        Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::Number(raw))) => raw
            .as_u64()
            .and_then(|v| u32::try_from(v).ok())
            .map(PatchValue::Set)
            .ok_or_else(|| "spawnDepth must be a non-negative integer or null".to_owned()),
        Some(_) => Err("spawnDepth must be a non-negative integer or null".to_owned()),
    }
}

fn parse_patch_send_policy(
    value: Option<Option<Value>>,
) -> Result<PatchValue<SendPolicyOverride>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) => Ok(PatchValue::Clear),
        Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(v))) => match normalize(&v).as_str() {
            "allow" => Ok(PatchValue::Set(SendPolicyOverride::Allow)),
            "deny" => Ok(PatchValue::Set(SendPolicyOverride::Deny)),
            _ => Err("sendPolicy must be allow|deny|null".to_owned()),
        },
        Some(_) => Err("sendPolicy must be string or null".to_owned()),
    }
}

fn parse_patch_group_activation(
    value: Option<Option<Value>>,
) -> Result<PatchValue<GroupActivationMode>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) => Ok(PatchValue::Clear),
        Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(v))) => parse_group_activation_mode(&v)
            .map(PatchValue::Set)
            .ok_or_else(|| "groupActivation must be mention|always|null".to_owned()),
        Some(_) => Err("groupActivation must be string or null".to_owned()),
    }
}

fn parse_patch_queue_mode(
    value: Option<Option<Value>>,
) -> Result<PatchValue<SessionQueueMode>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) => Ok(PatchValue::Clear),
        Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(v))) => parse_queue_mode(&v)
            .map(PatchValue::Set)
            .ok_or_else(|| "queueMode must be followup|steer|collect|null".to_owned()),
        Some(_) => Err("queueMode must be string or null".to_owned()),
    }
}

fn normalize_thinking_level(value: &str) -> Option<&'static str> {
    let key = normalize(value);
    let collapsed = key.replace([' ', '_', '-'], "");
    if collapsed == "xhigh" || collapsed == "extrahigh" {
        return Some("xhigh");
    }
    match key.as_str() {
        "off" => Some("off"),
        "on" | "enable" | "enabled" => Some("low"),
        "min" | "minimal" | "think" => Some("minimal"),
        "low" | "thinkhard" | "think-hard" | "think_hard" => Some("low"),
        "mid" | "med" | "medium" | "thinkharder" | "think-harder" | "harder" => Some("medium"),
        "high" | "ultra" | "ultrathink" | "thinkhardest" | "highest" | "max" => Some("high"),
        _ => None,
    }
}

fn parse_patch_thinking_level(value: Option<Option<Value>>) -> Result<PatchValue<String>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) | Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(raw))) => normalize_thinking_level(&raw)
            .map(|v| PatchValue::Set(v.to_owned()))
            .ok_or_else(|| {
                "thinkingLevel must be off|minimal|low|medium|high|xhigh|null".to_owned()
            }),
        Some(_) => Err("thinkingLevel must be string or null".to_owned()),
    }
}

fn normalize_verbose_level(value: &str) -> Option<&'static str> {
    match normalize(value).as_str() {
        "off" | "false" | "no" | "0" => Some("off"),
        "full" | "all" | "everything" => Some("full"),
        "on" | "minimal" | "true" | "yes" | "1" => Some("on"),
        _ => None,
    }
}

fn parse_patch_verbose_level(value: Option<Option<Value>>) -> Result<PatchValue<String>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) | Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(raw))) => normalize_verbose_level(&raw)
            .map(|v| PatchValue::Set(v.to_owned()))
            .ok_or_else(|| "verboseLevel must be on|off|full|null".to_owned()),
        Some(_) => Err("verboseLevel must be string or null".to_owned()),
    }
}

fn normalize_reasoning_level(value: &str) -> Option<&'static str> {
    match normalize(value).as_str() {
        "off" | "false" | "no" | "0" | "hide" | "hidden" | "disable" | "disabled" => Some("off"),
        "on" | "true" | "yes" | "1" | "show" | "visible" | "enable" | "enabled" => Some("on"),
        "stream" | "streaming" | "draft" | "live" => Some("stream"),
        _ => None,
    }
}

fn parse_patch_reasoning_level(value: Option<Option<Value>>) -> Result<PatchValue<String>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) | Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(raw))) => normalize_reasoning_level(&raw)
            .map(|v| {
                if v == "off" {
                    PatchValue::Clear
                } else {
                    PatchValue::Set(v.to_owned())
                }
            })
            .ok_or_else(|| "reasoningLevel must be on|off|stream|null".to_owned()),
        Some(_) => Err("reasoningLevel must be string or null".to_owned()),
    }
}

fn parse_response_usage_mode(value: &str) -> Option<ResponseUsageMode> {
    match normalize(value).as_str() {
        "off" => Some(ResponseUsageMode::Off),
        "tokens" | "token" | "tok" | "minimal" | "min" | "on" | "true" | "yes" | "1" | "enable"
        | "enabled" => Some(ResponseUsageMode::Tokens),
        "full" | "session" => Some(ResponseUsageMode::Full),
        _ => None,
    }
}

fn parse_patch_response_usage(
    value: Option<Option<Value>>,
) -> Result<PatchValue<ResponseUsageMode>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) => Ok(PatchValue::Clear),
        Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(v))) => parse_response_usage_mode(&v)
            .map(|mode| match mode {
                ResponseUsageMode::Off => PatchValue::Clear,
                _ => PatchValue::Set(mode),
            })
            .ok_or_else(|| "responseUsage must be off|tokens|full|on|null".to_owned()),
        Some(_) => Err("responseUsage must be string or null".to_owned()),
    }
}

fn normalize_elevated_level(value: &str) -> Option<&'static str> {
    match normalize(value).as_str() {
        "off" | "false" | "no" | "0" => Some("off"),
        "full" | "auto" | "autoapprove" | "auto-approve" => Some("full"),
        "ask" | "prompt" | "approval" | "approve" => Some("ask"),
        "on" | "true" | "yes" | "1" => Some("on"),
        _ => None,
    }
}

fn parse_patch_elevated_level(value: Option<Option<Value>>) -> Result<PatchValue<String>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) | Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(raw))) => normalize_elevated_level(&raw)
            .map(|v| PatchValue::Set(v.to_owned()))
            .ok_or_else(|| "elevatedLevel must be on|off|ask|full|null".to_owned()),
        Some(_) => Err("elevatedLevel must be string or null".to_owned()),
    }
}

fn parse_patch_exec_host(value: Option<Option<Value>>) -> Result<PatchValue<String>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) | Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(raw))) => match normalize(raw.as_str()).as_str() {
            "sandbox" => Ok(PatchValue::Set("sandbox".to_owned())),
            "gateway" => Ok(PatchValue::Set("gateway".to_owned())),
            "node" => Ok(PatchValue::Set("node".to_owned())),
            _ => Err("execHost must be sandbox|gateway|node|null".to_owned()),
        },
        Some(_) => Err("execHost must be string or null".to_owned()),
    }
}

fn parse_patch_exec_security(value: Option<Option<Value>>) -> Result<PatchValue<String>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) | Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(raw))) => match normalize(raw.as_str()).as_str() {
            "deny" => Ok(PatchValue::Set("deny".to_owned())),
            "allowlist" => Ok(PatchValue::Set("allowlist".to_owned())),
            "full" => Ok(PatchValue::Set("full".to_owned())),
            _ => Err("execSecurity must be deny|allowlist|full|null".to_owned()),
        },
        Some(_) => Err("execSecurity must be string or null".to_owned()),
    }
}

fn parse_patch_exec_ask(value: Option<Option<Value>>) -> Result<PatchValue<String>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) | Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(raw))) => match normalize(raw.as_str()).as_str() {
            "off" => Ok(PatchValue::Set("off".to_owned())),
            "on-miss" => Ok(PatchValue::Set("on-miss".to_owned())),
            "always" => Ok(PatchValue::Set("always".to_owned())),
            _ => Err("execAsk must be off|on-miss|always|null".to_owned()),
        },
        Some(_) => Err("execAsk must be string or null".to_owned()),
    }
}

fn parse_patch_model(
    value: Option<Option<Value>>,
) -> Result<PatchValue<ModelOverridePatch>, String> {
    match value {
        None => Ok(PatchValue::Keep),
        Some(None) => Ok(PatchValue::Clear),
        Some(Some(Value::Null)) => Ok(PatchValue::Clear),
        Some(Some(Value::String(raw))) => {
            let trimmed = raw.trim();
            if trimmed.is_empty() {
                return Err("model cannot be empty".to_owned());
            }
            if let Some((provider, model)) = trimmed.split_once('/') {
                let provider = provider.trim();
                let model = model.trim();
                if provider.is_empty() || model.is_empty() {
                    return Err("model must be 'provider/model' or 'model'".to_owned());
                }
                let (provider, model) = normalize_model_ref(provider, model);
                return Ok(PatchValue::Set(ModelOverridePatch {
                    provider_override: Some(provider),
                    model_override: model,
                }));
            }
            Ok(PatchValue::Set(ModelOverridePatch {
                provider_override: None,
                model_override: trimmed.to_owned(),
            }))
        }
        Some(_) => Err("model must be string or null".to_owned()),
    }
}

fn normalize_provider_id(provider: &str) -> String {
    match normalize(provider).as_str() {
        "z.ai" | "z-ai" => "zai".to_owned(),
        "zhipu-coding" | "zhipuai-coding" | "bigmodel-coding" => "zhipuai-coding".to_owned(),
        "zhipu" | "zhipu-ai" | "zhipuai" | "bigmodel" | "bigmodel-cn" => "zhipuai".to_owned(),
        "opencode-zen" => "opencode".to_owned(),
        "qwen" => "qwen-portal".to_owned(),
        "kimi-code" => "kimi-coding".to_owned(),
        "gemini" | "google-gemini-cli" => "google".to_owned(),
        "bytedance" | "doubao" => "volcengine".to_owned(),
        "claude" | "claude-code" | "claude-code-cli" | "claude-desktop" => "anthropic".to_owned(),
        "lm-studio" => "lmstudio".to_owned(),
        "local-ai" => "localai".to_owned(),
        "llama.cpp" | "llama-cpp" | "llama-cpp-server" => "llamacpp".to_owned(),
        "huggingface-tgi" | "hf-tgi" | "text-generation-inference" => "tgi".to_owned(),
        "gpt-4all" => "gpt4all".to_owned(),
        "kobold-cpp" => "koboldcpp".to_owned(),
        "text-generation-webui" | "oobabooga-webui" => "oobabooga".to_owned(),
        "deep-infra" => "deepinfra".to_owned(),
        "silicon-flow" => "siliconflow".to_owned(),
        "novita-ai" => "novita".to_owned(),
        "inference.net" | "inferencenet" => "inference-net".to_owned(),
        "aimlapi.com" => "aimlapi".to_owned(),
        "vercel-ai" | "ai-gateway" => "vercel-ai-gateway".to_owned(),
        "share-ai" => "shareai".to_owned(),
        "maxim-bifrost" | "bifrost-maxim" => "bifrost".to_owned(),
        "azure" | "azure-openai-service" => "azure-openai".to_owned(),
        "vertex" | "google-vertex" => "vertex-ai".to_owned(),
        "amazon-bedrock" => "bedrock".to_owned(),
        "github-model" => "github-models".to_owned(),
        "nvidia-nim" => "nvidia".to_owned(),
        "cerebras-cloud" => "cerebras".to_owned(),
        "chatgpt" => "openai".to_owned(),
        "codex" | "codex-cli" => "openai-codex".to_owned(),
        "claude-cli" => "anthropic".to_owned(),
        normalized => normalized.to_owned(),
    }
}

fn normalize_anthropic_model_id(model: &str) -> String {
    match normalize(model).as_str() {
        "opus-4.6" => "claude-opus-4-6".to_owned(),
        "opus-4.5" => "claude-opus-4-5".to_owned(),
        "sonnet-4.6" => "claude-sonnet-4-6".to_owned(),
        "sonnet-4.5" => "claude-sonnet-4-5".to_owned(),
        _ => model.trim().to_owned(),
    }
}

fn normalize_provider_model_id(provider: &str, model: &str) -> String {
    if provider == "anthropic" {
        return normalize_anthropic_model_id(model);
    }
    model.trim().to_owned()
}

fn should_use_openai_codex_provider(provider: &str, model: &str) -> bool {
    if provider != "openai" {
        return false;
    }
    let normalized = normalize(model);
    normalized == "gpt-5.3-codex" || normalized.starts_with("gpt-5.3-codex-")
}

fn normalize_model_ref(provider: &str, model: &str) -> (String, String) {
    let normalized_provider = normalize_provider_id(provider);
    let normalized_model = normalize_provider_model_id(&normalized_provider, model);
    if should_use_openai_codex_provider(&normalized_provider, &normalized_model) {
        return ("openai-codex".to_owned(), normalized_model);
    }
    (normalized_provider, normalized_model)
}

fn model_provider_failover_chain(provider: &str) -> Vec<String> {
    match normalize_provider_id(provider).as_str() {
        "openai-codex" => vec!["openai".to_owned(), "anthropic".to_owned()],
        "openai" => vec!["openai-codex".to_owned(), "anthropic".to_owned()],
        "anthropic" => vec!["openai".to_owned()],
        "google" | "qwen-portal" | "zai" | "zhipuai" | "zhipuai-coding" | "opencode"
        | "kimi-coding" | "groq" | "cerebras" | "xai" | "openrouter" | "deepseek"
        | "perplexity" | "fireworks" | "mistral" | "together" | "moonshot" | "nvidia"
        | "qianfan" | "volcengine" | "byteplus" | "sambanova" | "ollama" | "vllm" | "litellm"
        | "lmstudio" | "localai" | "llamacpp" | "tgi" | "gpt4all" | "koboldcpp" | "oobabooga"
        | "deepinfra" | "siliconflow" | "novita" | "hyperbolic" | "nebius" | "inference-net"
        | "aimlapi" | "cohere" => {
            vec!["openai".to_owned()]
        }
        _ => Vec::new(),
    }
}

#[derive(Debug, Clone, Copy)]
struct ProviderRuntimeDefaults {
    api_mode: &'static str,
    base_url: &'static str,
    env_vars: &'static [&'static str],
    allow_missing_api_key: bool,
}

fn provider_runtime_defaults(provider: &str) -> Option<ProviderRuntimeDefaults> {
    match normalize_provider_id(provider).as_str() {
        "openai" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.openai.com/v1",
            env_vars: &["OPENAI_API_KEY"],
            allow_missing_api_key: false,
        }),
        "openai-codex" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.openai.com/v1",
            env_vars: &["OPENAI_API_KEY", "CODEX_API_KEY"],
            allow_missing_api_key: false,
        }),
        "google" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://generativelanguage.googleapis.com/v1beta/openai",
            env_vars: &["GEMINI_API_KEY", "GOOGLE_API_KEY"],
            allow_missing_api_key: false,
        }),
        "groq" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.groq.com/openai/v1",
            env_vars: &["GROQ_API_KEY"],
            allow_missing_api_key: false,
        }),
        "cerebras" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.cerebras.ai/v1",
            env_vars: &["CEREBRAS_API_KEY"],
            allow_missing_api_key: false,
        }),
        "xai" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.x.ai/v1",
            env_vars: &["XAI_API_KEY"],
            allow_missing_api_key: false,
        }),
        "openrouter" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://openrouter.ai/api/v1",
            env_vars: &["OPENROUTER_API_KEY"],
            allow_missing_api_key: false,
        }),
        "deepseek" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.deepseek.com/v1",
            env_vars: &["DEEPSEEK_API_KEY"],
            allow_missing_api_key: false,
        }),
        "deepinfra" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.deepinfra.com/v1/openai",
            env_vars: &["DEEPINFRA_API_KEY"],
            allow_missing_api_key: false,
        }),
        "perplexity" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.perplexity.ai",
            env_vars: &["PERPLEXITY_API_KEY"],
            allow_missing_api_key: false,
        }),
        "fireworks" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.fireworks.ai/inference/v1",
            env_vars: &["FIREWORKS_API_KEY"],
            allow_missing_api_key: false,
        }),
        "sambanova" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.sambanova.ai/v1",
            env_vars: &["SAMBANOVA_API_KEY"],
            allow_missing_api_key: false,
        }),
        "mistral" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.mistral.ai/v1",
            env_vars: &["MISTRAL_API_KEY"],
            allow_missing_api_key: false,
        }),
        "cohere" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.cohere.com/compatibility/v1",
            env_vars: &["COHERE_API_KEY"],
            allow_missing_api_key: false,
        }),
        "together" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.together.xyz/v1",
            env_vars: &["TOGETHER_API_KEY"],
            allow_missing_api_key: false,
        }),
        "moonshot" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.moonshot.ai/v1",
            env_vars: &["MOONSHOT_API_KEY"],
            allow_missing_api_key: false,
        }),
        "nvidia" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://integrate.api.nvidia.com/v1",
            env_vars: &["NVIDIA_API_KEY"],
            allow_missing_api_key: false,
        }),
        "qianfan" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://qianfan.baidubce.com/v2",
            env_vars: &["QIANFAN_API_KEY"],
            allow_missing_api_key: false,
        }),
        "qwen-portal" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://portal.qwen.ai/v1",
            env_vars: &["QWEN_PORTAL_API_KEY", "QWEN_OAUTH_TOKEN"],
            allow_missing_api_key: false,
        }),
        "zai" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.z.ai/v1",
            env_vars: &["ZAI_API_KEY", "Z_AI_API_KEY"],
            allow_missing_api_key: false,
        }),
        "zhipuai" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://open.bigmodel.cn/api/paas/v4",
            env_vars: &[
                "ZHIPUAI_API_KEY",
                "BIGMODEL_API_KEY",
                "ZAI_API_KEY",
                "Z_AI_API_KEY",
            ],
            allow_missing_api_key: false,
        }),
        "zhipuai-coding" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://open.bigmodel.cn/api/coding/paas/v4",
            env_vars: &[
                "ZHIPUAI_API_KEY",
                "BIGMODEL_API_KEY",
                "ZAI_API_KEY",
                "Z_AI_API_KEY",
            ],
            allow_missing_api_key: false,
        }),
        "opencode" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://opencode.ai/zen/v1",
            env_vars: &["OPENCODE_API_KEY", "OPENCODE_ZEN_API_KEY"],
            allow_missing_api_key: true,
        }),
        "kimi-coding" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.kimi.com/coding",
            env_vars: &["KIMI_API_KEY", "KIMICODE_API_KEY"],
            allow_missing_api_key: false,
        }),
        "volcengine" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://ark.cn-beijing.volces.com/api/v3",
            env_vars: &["VOLCANO_ENGINE_API_KEY"],
            allow_missing_api_key: false,
        }),
        "byteplus" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.byteplus.com/v1",
            env_vars: &["BYTEPLUS_API_KEY"],
            allow_missing_api_key: false,
        }),
        "siliconflow" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.siliconflow.cn/v1",
            env_vars: &["SILICONFLOW_API_KEY"],
            allow_missing_api_key: false,
        }),
        "novita" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.novita.ai/v3/openai",
            env_vars: &["NOVITA_API_KEY"],
            allow_missing_api_key: false,
        }),
        "hyperbolic" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.hyperbolic.xyz/v1",
            env_vars: &["HYPERBOLIC_API_KEY"],
            allow_missing_api_key: false,
        }),
        "nebius" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.studio.nebius.com/v1",
            env_vars: &["NEBIUS_API_KEY"],
            allow_missing_api_key: false,
        }),
        "inference-net" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.inference.net/v1",
            env_vars: &["INFERENCE_NET_API_KEY"],
            allow_missing_api_key: false,
        }),
        "aimlapi" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api.aimlapi.com/v1",
            env_vars: &["AIMLAPI_API_KEY"],
            allow_missing_api_key: false,
        }),
        "ollama" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:11434/v1",
            env_vars: &["OLLAMA_API_KEY"],
            allow_missing_api_key: true,
        }),
        "vllm" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:8000/v1",
            env_vars: &["VLLM_API_KEY"],
            allow_missing_api_key: true,
        }),
        "huggingface" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "https://api-inference.huggingface.co/v1",
            env_vars: &["HUGGINGFACE_HUB_TOKEN", "HF_TOKEN"],
            allow_missing_api_key: false,
        }),
        "litellm" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:4000/v1",
            env_vars: &["LITELLM_API_KEY"],
            allow_missing_api_key: true,
        }),
        "lmstudio" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:1234/v1",
            env_vars: &["LMSTUDIO_API_KEY", "LM_STUDIO_API_KEY"],
            allow_missing_api_key: true,
        }),
        "localai" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:8080/v1",
            env_vars: &["LOCALAI_API_KEY", "LOCAL_AI_API_KEY"],
            allow_missing_api_key: true,
        }),
        "llamacpp" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:8080/v1",
            env_vars: &["LLAMACPP_API_KEY", "LLAMA_CPP_API_KEY"],
            allow_missing_api_key: true,
        }),
        "tgi" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:8080/v1",
            env_vars: &["TGI_API_KEY", "HF_TOKEN"],
            allow_missing_api_key: true,
        }),
        "gpt4all" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:4891/v1",
            env_vars: &["GPT4ALL_API_KEY"],
            allow_missing_api_key: true,
        }),
        "koboldcpp" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:5001/v1",
            env_vars: &["KOBOLDCPP_API_KEY"],
            allow_missing_api_key: true,
        }),
        "oobabooga" => Some(ProviderRuntimeDefaults {
            api_mode: "openai-completions",
            base_url: "http://127.0.0.1:5000/v1",
            env_vars: &["OOBABOOGA_API_KEY"],
            allow_missing_api_key: true,
        }),
        _ => None,
    }
}

fn provider_runtime_bridge_defaults(
    provider: &str,
) -> (Option<&'static str>, &'static [&'static str]) {
    match normalize_provider_id(provider).as_str() {
        "opencode" => (
            Some("https://opencode.ai"),
            &["https://opencode.ai/zen/v1", "https://api.opencode.ai/v1"],
        ),
        "zhipuai" | "zhipuai-coding" | "zai" => (Some("https://chat.z.ai"), &[]),
        "kimi-coding" => (Some("https://www.kimi.com"), &[]),
        "minimax-portal" => (Some("https://chat.minimax.io"), &[]),
        _ => (None, &[]),
    }
}

fn resolve_provider_runtime_config(
    config: &Value,
    provider: &str,
) -> Option<ProviderRuntimeConfig> {
    let normalized_provider = normalize_provider_id(provider);
    let defaults = provider_runtime_defaults(&normalized_provider);
    let provider_entry = resolve_provider_entry_config(config, &normalized_provider);
    let provider_options = provider_entry.and_then(provider_config_options_object);
    let mut headers = Vec::new();
    collect_provider_headers(&mut headers, provider_entry);
    collect_provider_headers(&mut headers, provider_options);

    let api_mode = read_provider_config_string(
        provider_entry,
        provider_options,
        &["api", "apiMode", "api_mode", "mode"],
        128,
    )
    .or_else(|| defaults.map(|value| value.api_mode.to_owned()))
    .unwrap_or_else(|| "openai-completions".to_owned());
    let base_url = read_provider_config_string(
        provider_entry,
        provider_options,
        &[
            "chatCompletionsUrl",
            "chat_completions_url",
            "chatEndpoint",
            "chat_endpoint",
            "baseUrl",
            "baseURL",
            "base_url",
            "url",
            "endpoint",
        ],
        2_048,
    )
    .or_else(|| defaults.map(|value| value.base_url.to_owned()));
    let api_key = resolve_provider_runtime_api_key(
        provider_entry,
        provider_options,
        &normalized_provider,
        defaults,
    );
    let timeout_ms = resolve_provider_runtime_timeout_ms(config, provider_entry, provider_options);
    let allow_missing_api_key = read_provider_config_bool(
        provider_entry,
        provider_options,
        &[
            "allowUnauthenticated",
            "allow_unauthenticated",
            "allowUnauth",
            "allow_unauth",
            "allowAnonymous",
            "allow_anonymous",
            "apiKeyOptional",
            "api_key_optional",
        ],
    )
    .unwrap_or_else(|| {
        defaults
            .map(|value| value.allow_missing_api_key)
            .unwrap_or(false)
    });
    let auth_header_name = read_provider_config_string(
        provider_entry,
        provider_options,
        &[
            "authHeaderName",
            "auth_header_name",
            "apiKeyHeader",
            "api_key_header",
            "tokenHeader",
            "token_header",
        ],
        128,
    )
    .unwrap_or_else(|| "Authorization".to_owned());
    let auth_header_prefix = read_provider_config_string(
        provider_entry,
        provider_options,
        &[
            "authHeaderPrefix",
            "auth_header_prefix",
            "apiKeyPrefix",
            "api_key_prefix",
            "tokenPrefix",
            "token_prefix",
        ],
        64,
    )
    .unwrap_or_else(|| {
        if auth_header_name.eq_ignore_ascii_case("authorization") {
            "Bearer ".to_owned()
        } else {
            String::new()
        }
    });
    let request_overrides = resolve_provider_request_overrides(provider_entry, provider_options);
    let (default_website_url, default_bridge_candidates) =
        provider_runtime_bridge_defaults(&normalized_provider);
    let website_url = read_provider_config_string(
        provider_entry,
        provider_options,
        &[
            "websiteUrl",
            "website_url",
            "siteUrl",
            "site_url",
            "homepage",
            "homepageUrl",
            "homepage_url",
        ],
        2_048,
    )
    .or_else(|| default_website_url.map(ToOwned::to_owned));
    let mut bridge_candidates = read_provider_config_string_list(
        provider_entry,
        provider_options,
        &[
            "bridgeCandidates",
            "bridge_candidates",
            "bridgeBaseUrls",
            "bridge_base_urls",
            "websiteBridgeCandidates",
            "website_bridge_candidates",
            "fallbackBaseUrls",
            "fallback_base_urls",
        ],
        16,
        2_048,
    )
    .unwrap_or_default();
    if let Some(single_candidate) = read_provider_config_string(
        provider_entry,
        provider_options,
        &[
            "bridgeBaseUrl",
            "bridge_base_url",
            "websiteBridgeBaseUrl",
            "website_bridge_base_url",
        ],
        2_048,
    ) {
        bridge_candidates.push(single_candidate);
    }
    if bridge_candidates.is_empty() {
        bridge_candidates.extend(
            default_bridge_candidates
                .iter()
                .map(|candidate| (*candidate).to_owned()),
        );
    }
    sort_and_dedup_strings(&mut bridge_candidates);
    let base_url = base_url
        .or_else(|| bridge_candidates.first().cloned())
        .and_then(|value| normalize_optional_text(Some(value), 2_048))?;

    if normalized_provider.eq_ignore_ascii_case("openrouter") {
        upsert_provider_header(
            &mut headers,
            "HTTP-Referer".to_owned(),
            "https://openclaw.ai".to_owned(),
            false,
        );
        upsert_provider_header(
            &mut headers,
            "X-Title".to_owned(),
            "OpenClaw Rust".to_owned(),
            false,
        );
    }
    if normalized_provider.eq_ignore_ascii_case("cerebras") {
        upsert_provider_header(
            &mut headers,
            "X-Cerebras-3rd-Party-Integration".to_owned(),
            "openclaw-rust".to_owned(),
            false,
        );
    }

    Some(ProviderRuntimeConfig {
        provider: normalized_provider,
        api_mode,
        base_url,
        api_key,
        allow_missing_api_key,
        website_url,
        bridge_candidates,
        auth_header_name,
        auth_header_prefix,
        timeout_ms,
        headers,
        request_overrides,
    })
}

fn provider_config_options_object(
    object: &serde_json::Map<String, Value>,
) -> Option<&serde_json::Map<String, Value>> {
    read_config_object(
        object,
        &[
            "options",
            "providerOptions",
            "provider_options",
            "runtime",
            "runtimeOptions",
            "runtime_options",
        ],
    )
}

fn read_provider_config_string(
    provider_entry: Option<&serde_json::Map<String, Value>>,
    provider_options: Option<&serde_json::Map<String, Value>>,
    keys: &[&str],
    max_len: usize,
) -> Option<String> {
    provider_entry
        .and_then(|entry| read_config_string(entry, keys, max_len))
        .or_else(|| provider_options.and_then(|entry| read_config_string(entry, keys, max_len)))
}

fn read_provider_config_bool(
    provider_entry: Option<&serde_json::Map<String, Value>>,
    provider_options: Option<&serde_json::Map<String, Value>>,
    keys: &[&str],
) -> Option<bool> {
    provider_entry
        .and_then(|entry| read_config_bool(entry, keys))
        .or_else(|| provider_options.and_then(|entry| read_config_bool(entry, keys)))
}

fn read_provider_config_string_list(
    provider_entry: Option<&serde_json::Map<String, Value>>,
    provider_options: Option<&serde_json::Map<String, Value>>,
    keys: &[&str],
    max_items: usize,
    max_len: usize,
) -> Option<Vec<String>> {
    provider_entry
        .and_then(|entry| read_config_string_list(entry, keys, max_items, max_len))
        .or_else(|| {
            provider_options
                .and_then(|entry| read_config_string_list(entry, keys, max_items, max_len))
        })
}

fn collect_provider_headers(
    target: &mut Vec<(String, String)>,
    provider_object: Option<&serde_json::Map<String, Value>>,
) {
    let Some(provider_object) = provider_object else {
        return;
    };
    for key in ["headers", "defaultHeaders", "default_headers"] {
        let Some(header_map) = provider_object.get(key).and_then(Value::as_object) else {
            continue;
        };
        for (header_name_raw, header_value_raw) in header_map {
            let Some(header_name) = normalize_optional_text(Some(header_name_raw.clone()), 128)
            else {
                continue;
            };
            let Some(raw_value) = header_value_raw.as_str() else {
                continue;
            };
            let Some(resolved) = resolve_secret_reference(raw_value)
                .and_then(|value| normalize_optional_text(Some(value), 2_048))
            else {
                continue;
            };
            upsert_provider_header(target, header_name, resolved, true);
        }
    }
}

fn upsert_provider_header(
    headers: &mut Vec<(String, String)>,
    name: String,
    value: String,
    overwrite_existing: bool,
) {
    if let Some(index) = headers
        .iter()
        .position(|(existing_name, _)| existing_name.eq_ignore_ascii_case(&name))
    {
        if overwrite_existing {
            headers[index] = (name, value);
        }
    } else {
        headers.push((name, value));
    }
}

fn resolve_provider_request_overrides(
    provider_entry: Option<&serde_json::Map<String, Value>>,
    provider_options: Option<&serde_json::Map<String, Value>>,
) -> serde_json::Map<String, Value> {
    let mut output = serde_json::Map::new();
    for object in [provider_entry, provider_options].into_iter().flatten() {
        for key in [
            "requestDefaults",
            "request_defaults",
            "request",
            "payloadDefaults",
            "payload_defaults",
            "payload",
            "params",
        ] {
            let Some(entries) = object.get(key).and_then(Value::as_object) else {
                continue;
            };
            for (field, value) in entries {
                output.insert(field.to_owned(), value.clone());
            }
        }
    }
    output
}

fn resolve_provider_entry_config<'a>(
    config: &'a Value,
    provider: &str,
) -> Option<&'a serde_json::Map<String, Value>> {
    let provider_maps = [
        config
            .pointer("/models/providers")
            .and_then(Value::as_object),
        config
            .pointer("/gateway/models/providers")
            .and_then(Value::as_object),
    ];
    for provider_map in provider_maps.into_iter().flatten() {
        for (entry_provider, entry_value) in provider_map {
            if normalize_provider_id(entry_provider).eq_ignore_ascii_case(provider) {
                if let Some(entry) = entry_value.as_object() {
                    return Some(entry);
                }
            }
        }
    }
    None
}

fn resolve_provider_runtime_api_key(
    provider_entry: Option<&serde_json::Map<String, Value>>,
    provider_options: Option<&serde_json::Map<String, Value>>,
    provider: &str,
    defaults: Option<ProviderRuntimeDefaults>,
) -> Option<String> {
    for entry in [provider_entry, provider_options].into_iter().flatten() {
        if let Some(raw) = read_config_string(
            entry,
            &[
                "apiKey",
                "api_key",
                "key",
                "token",
                "accessToken",
                "access_token",
                "bearerToken",
                "bearer_token",
            ],
            2_048,
        ) {
            if let Some(resolved) = resolve_secret_reference(&raw) {
                return Some(resolved);
            }
        }
    }
    let mut env_vars = defaults
        .map(|value| value.env_vars.to_vec())
        .unwrap_or_default();
    if provider.eq_ignore_ascii_case("anthropic") {
        env_vars.push("ANTHROPIC_API_KEY");
        env_vars.push("ANTHROPIC_OAUTH_TOKEN");
    }
    if provider.eq_ignore_ascii_case("google") {
        env_vars.push("GEMINI_API_KEY");
    }
    for env_key in env_vars {
        if let Ok(value) = env::var(env_key) {
            if let Some(normalized) = normalize_optional_text(Some(value), 4_096) {
                return Some(normalized);
            }
        }
    }
    None
}

fn resolve_secret_reference(raw: &str) -> Option<String> {
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return None;
    }
    if let Some(value) = trimmed
        .strip_prefix("${")
        .and_then(|value| value.strip_suffix('}'))
    {
        let env_name = value.trim();
        if env_name.is_empty() {
            return None;
        }
        return env::var(env_name)
            .ok()
            .and_then(|value| normalize_optional_text(Some(value), 4_096));
    }
    if let Some(value) = trimmed
        .strip_prefix("env:")
        .or_else(|| trimmed.strip_prefix("ENV:"))
    {
        let env_name = value.trim();
        if env_name.is_empty() {
            return None;
        }
        return env::var(env_name)
            .ok()
            .and_then(|value| normalize_optional_text(Some(value), 4_096));
    }
    if let Some(value) = trimmed
        .strip_prefix("shell env:")
        .or_else(|| trimmed.strip_prefix("SHELL ENV:"))
    {
        let env_name = value.trim();
        if env_name.is_empty() {
            return None;
        }
        return env::var(env_name)
            .ok()
            .and_then(|value| normalize_optional_text(Some(value), 4_096));
    }
    if trimmed
        .chars()
        .all(|ch| ch.is_ascii_uppercase() || ch.is_ascii_digit() || ch == '_')
        && trimmed.chars().any(|ch| ch == '_')
    {
        return env::var(trimmed)
            .ok()
            .and_then(|value| normalize_optional_text(Some(value), 4_096));
    }
    normalize_optional_text(Some(trimmed.to_owned()), 4_096)
}

fn resolve_provider_runtime_timeout_ms(
    config: &Value,
    provider_entry: Option<&serde_json::Map<String, Value>>,
    provider_options: Option<&serde_json::Map<String, Value>>,
) -> u64 {
    provider_entry
        .and_then(|entry| {
            read_config_u64(
                entry,
                &[
                    "timeoutMs",
                    "timeout_ms",
                    "requestTimeoutMs",
                    "request_timeout_ms",
                ],
            )
        })
        .or_else(|| {
            provider_options.and_then(|entry| {
                read_config_u64(
                    entry,
                    &[
                        "timeoutMs",
                        "timeout_ms",
                        "requestTimeoutMs",
                        "request_timeout_ms",
                    ],
                )
            })
        })
        .or_else(|| {
            config
                .pointer("/models/requestTimeoutMs")
                .and_then(config_value_as_u64)
        })
        .or_else(|| {
            config
                .pointer("/models/request_timeout_ms")
                .and_then(config_value_as_u64)
        })
        .unwrap_or(AGENT_PROVIDER_HTTP_TIMEOUT_MS)
        .max(1_000)
}

fn resolve_tool_runtime_policy_config(config: &Value) -> ToolRuntimePolicyConfig {
    let mut policy = config
        .pointer("/security/tool_runtime_policy")
        .cloned()
        .and_then(|value| serde_json::from_value::<ToolRuntimePolicyConfig>(value).ok())
        .unwrap_or_default();

    if let Some(raw_mode) = config
        .pointer("/security/wasm/tool_runtime_mode")
        .and_then(Value::as_str)
    {
        let mode = match raw_mode.trim().to_ascii_lowercase().as_str() {
            "inspection_stub" | "inspection-stub" | "stub" => {
                Some(ToolRuntimeWasmMode::InspectionStub)
            }
            "wasm_sandbox" | "wasm-sandbox" | "sandbox" => Some(ToolRuntimeWasmMode::WasmSandbox),
            _ => None,
        };
        if let Some(mode) = mode {
            policy.wasm.tool_runtime_mode = mode;
        }
    }

    if let Some(raw_wit_root) = config
        .pointer("/security/wasm/wit_root")
        .and_then(Value::as_str)
    {
        let trimmed = raw_wit_root.trim();
        if !trimmed.is_empty() {
            policy.wasm.wit_root = PathBuf::from(trimmed);
        }
    }

    if let Some(raw_dynamic) = config.pointer("/security/wasm/dynamic_wit_loading") {
        match raw_dynamic {
            Value::Bool(flag) => policy.wasm.dynamic_wit_loading = *flag,
            Value::String(text) => {
                let normalized = text.trim().to_ascii_lowercase();
                if matches!(normalized.as_str(), "1" | "true" | "yes" | "on") {
                    policy.wasm.dynamic_wit_loading = true;
                } else if matches!(normalized.as_str(), "0" | "false" | "no" | "off") {
                    policy.wasm.dynamic_wit_loading = false;
                }
            }
            _ => {}
        }
    }

    policy
}

fn resolve_tool_workspace_root_path(workspace: &str, agent_id: &str) -> PathBuf {
    let workspace = normalize_optional_text(Some(workspace.to_owned()), 2_048).unwrap_or_default();
    if workspace.is_empty() || agent_workspace_is_memory(&workspace) {
        return PathBuf::from(".openclaw-rs")
            .join("tool-runtime")
            .join(normalize_agent_id(agent_id));
    }
    PathBuf::from(workspace)
}

fn provider_api_mode_supported(api_mode: &str) -> bool {
    matches!(
        normalize(api_mode).as_str(),
        "openai-completions"
            | "openai-compatible"
            | "openai-chat"
            | "website-openai-bridge"
            | "website-bridge"
            | "official-website-bridge"
    )
}

fn provider_api_mode_uses_website_bridge(api_mode: &str) -> bool {
    matches!(
        normalize(api_mode).as_str(),
        "website-openai-bridge" | "website-bridge" | "official-website-bridge"
    )
}

fn provider_chat_completions_url(base_url: &str) -> String {
    let trimmed = base_url.trim().trim_end_matches('/');
    if trimmed.is_empty() {
        return "/v1/chat/completions".to_owned();
    }
    let lower = normalize(trimmed);
    if lower.contains("/chat/completions") {
        return trimmed.to_owned();
    }
    if lower.ends_with("/v1") {
        return format!("{trimmed}/chat/completions");
    }
    format!("{trimmed}/v1/chat/completions")
}

async fn invoke_openai_chat_completion(
    provider_runtime: &ProviderRuntimeConfig,
    model: &str,
    messages: &[Value],
    tools: &[Value],
) -> Result<OpenAiChatCompletionResponse, String> {
    let mut payload_object = provider_runtime.request_overrides.clone();
    payload_object.insert("model".to_owned(), Value::String(model.to_owned()));
    payload_object.insert("messages".to_owned(), Value::Array(messages.to_vec()));
    payload_object
        .entry("stream".to_owned())
        .or_insert(Value::Bool(false));
    if !tools.is_empty() {
        payload_object.insert("tools".to_owned(), Value::Array(tools.to_vec()));
        payload_object
            .entry("tool_choice".to_owned())
            .or_insert(Value::String("auto".to_owned()));
    }

    let should_try_website_bridge =
        provider_api_mode_uses_website_bridge(&provider_runtime.api_mode)
            || (!provider_runtime.bridge_candidates.is_empty()
                && provider_runtime.api_key.is_none()
                && provider_runtime.allow_missing_api_key);
    let mut website_bridge_error = None;
    let website_probe_url = if provider_api_mode_uses_website_bridge(&provider_runtime.api_mode) {
        provider_runtime.website_url.as_deref()
    } else {
        None
    };
    if should_try_website_bridge {
        let mut candidates = provider_runtime.bridge_candidates.clone();
        if !candidates
            .iter()
            .any(|candidate| candidate.eq_ignore_ascii_case(&provider_runtime.base_url))
        {
            candidates.push(provider_runtime.base_url.clone());
        }
        match invoke_openai_compatible(WebsiteBridgeRequest {
            provider: &provider_runtime.provider,
            model,
            messages,
            tools,
            timeout_ms: provider_runtime.timeout_ms,
            website_url: website_probe_url,
            candidate_base_urls: &candidates,
            headers: &provider_runtime.headers,
            auth_header_name: &provider_runtime.auth_header_name,
            auth_header_prefix: &provider_runtime.auth_header_prefix,
            api_key: provider_runtime.api_key.as_deref(),
            request_overrides: &payload_object,
        })
        .await
        {
            Ok(bridge_response) => {
                let bridge_body = bridge_response.body;
                let bridge_endpoint = bridge_response.endpoint;
                return serde_json::from_str::<OpenAiChatCompletionResponse>(&bridge_body).map_err(
                    |err| {
                        format!(
                            "provider response parse failed from {}: {err}; body={}",
                            bridge_endpoint,
                            truncate_text(&bridge_body, 1_024)
                        )
                    },
                );
            }
            Err(err) => {
                website_bridge_error = Some(err);
            }
        }
    }

    let timeout = Duration::from_millis(provider_runtime.timeout_ms.max(1_000));
    let client = reqwest::Client::builder()
        .timeout(timeout)
        .build()
        .map_err(|err| format!("failed creating provider client: {err}"))?;
    let endpoint = provider_chat_completions_url(&provider_runtime.base_url);
    let mut request = client
        .post(&endpoint)
        .header("Content-Type", "application/json");
    if let Some(api_key) = provider_runtime
        .api_key
        .as_ref()
        .and_then(|value| normalize_optional_text(Some(value.clone()), 4_096))
    {
        let header_value = format!("{}{}", provider_runtime.auth_header_prefix, api_key);
        request = request.header(&provider_runtime.auth_header_name, header_value);
    }
    for (name, value) in &provider_runtime.headers {
        request = request.header(name, value);
    }
    let payload = Value::Object(payload_object);

    let response = request.json(&payload).send().await.map_err(|err| {
        format!(
            "provider request failed for {}: {err}",
            provider_runtime.provider
        )
    })?;
    let status = response.status();
    let body = response
        .text()
        .await
        .map_err(|err| format!("provider response body read failed: {err}"))?;
    if !status.is_success() {
        if let Some(bridge_err) = website_bridge_error {
            return Err(format!(
                "provider request failed with status {}: {}; website bridge fallback also failed: {}",
                status.as_u16(),
                truncate_text(&body, 1_024),
                bridge_err
            ));
        }
        return Err(format!(
            "provider request failed with status {}: {}",
            status.as_u16(),
            truncate_text(&body, 1_024)
        ));
    }
    serde_json::from_str::<OpenAiChatCompletionResponse>(&body).map_err(|err| {
        let bridge_suffix = website_bridge_error
            .as_ref()
            .map(|value| format!("; website bridge fallback failed: {value}"))
            .unwrap_or_default();
        format!(
            "provider response parse failed: {err}; body={}{}",
            truncate_text(&body, 1_024),
            bridge_suffix
        )
    })
}

fn parse_tool_call_arguments(raw: &str) -> Result<Value, String> {
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return Ok(json!({}));
    }
    let parsed: Value = serde_json::from_str(trimmed)
        .map_err(|err| format!("invalid tool call arguments JSON: {err}"))?;
    if parsed.is_object() {
        Ok(parsed)
    } else {
        Ok(json!({
            "value": parsed
        }))
    }
}

fn openai_agent_tool_definitions() -> Vec<Value> {
    let definitions = [
        ("read", "Read a file from the active workspace."),
        ("write", "Write content to a file in the active workspace."),
        ("edit", "Apply focused text edits to a file."),
        (
            "apply_patch",
            "Apply a structured patch to one or more files.",
        ),
        ("exec", "Run an allowed command in the workspace."),
        ("process", "Inspect or control tracked runtime processes."),
        ("gateway", "Invoke gateway RPC methods."),
        ("sessions", "Inspect and mutate session history/state."),
        ("message", "Invoke channel/message actions."),
        ("browser", "Run browser automation actions."),
        ("canvas", "Render or inspect canvas runtime output."),
        ("nodes", "Invoke paired-node commands."),
    ];
    definitions
        .iter()
        .map(|(name, description)| openai_agent_tool_definition(name, description))
        .collect()
}

fn openai_agent_tool_definition(name: &str, description: &str) -> Value {
    json!({
        "type": "function",
        "function": {
            "name": name,
            "description": description,
            "parameters": {
                "type": "object",
                "additionalProperties": true
            }
        }
    })
}

fn build_openai_messages_from_session_history(history: &[SessionHistoryRecord]) -> Vec<Value> {
    let mut messages = Vec::new();
    for entry in history.iter().rev() {
        if entry.kind != SessionHistoryKind::Send {
            continue;
        }
        let text = entry
            .text
            .as_ref()
            .and_then(|value| normalize_optional_text(Some(value.clone()), 12_000))
            .or_else(|| {
                entry
                    .command
                    .as_ref()
                    .and_then(|value| normalize_optional_text(Some(value.clone()), 12_000))
            });
        let Some(text) = text else {
            continue;
        };
        let source = entry.source.as_deref().map(normalize).unwrap_or_default();
        let role = if source.starts_with("agent.assistant") || source.starts_with("chat.inject") {
            "assistant"
        } else {
            "user"
        };
        messages.push(json!({
            "role": role,
            "content": text
        }));
    }
    messages
}

fn latest_user_text_from_session_history(history: &[SessionHistoryRecord]) -> Option<String> {
    for entry in history {
        if entry.kind != SessionHistoryKind::Send {
            continue;
        }
        let source = entry.source.as_deref().map(normalize).unwrap_or_default();
        if source.starts_with("agent.assistant")
            || source.starts_with("chat.inject")
            || source.starts_with("agent.tool.")
        {
            continue;
        }
        if let Some(text) = entry
            .text
            .as_ref()
            .and_then(|value| normalize_optional_text(Some(value.clone()), 12_000))
        {
            return Some(text);
        }
        if let Some(command) = entry
            .command
            .as_ref()
            .and_then(|value| normalize_optional_text(Some(value.clone()), 12_000))
        {
            return Some(command);
        }
    }
    None
}

fn build_openai_assistant_tool_call_message(
    assistant_text: Option<&str>,
    tool_calls: &[OpenAiChatToolCall],
) -> Value {
    let tool_calls_payload = tool_calls
        .iter()
        .map(|tool_call| {
            let id = tool_call
                .id
                .as_ref()
                .and_then(|value| normalize_optional_text(Some(value.clone()), 128))
                .unwrap_or_else(|| format!("tool-call-{}", now_ms()));
            json!({
                "id": id,
                "type": "function",
                "function": {
                    "name": tool_call.function.name,
                    "arguments": tool_call.function.arguments
                }
            })
        })
        .collect::<Vec<_>>();
    json!({
        "role": "assistant",
        "content": assistant_text.unwrap_or(""),
        "tool_calls": tool_calls_payload
    })
}

fn extract_openai_message_text(content: Option<&Value>) -> Option<String> {
    let content = content?;
    match content {
        Value::Null => None,
        Value::String(raw) => normalize_optional_text(Some(raw.clone()), 12_000),
        Value::Array(items) => {
            let mut out = String::new();
            for item in items {
                let text = item
                    .get("text")
                    .and_then(Value::as_str)
                    .or_else(|| item.pointer("/text/value").and_then(Value::as_str))
                    .or_else(|| item.pointer("/content").and_then(Value::as_str));
                if let Some(text) = text {
                    if !out.is_empty() {
                        out.push('\n');
                    }
                    out.push_str(text.trim());
                }
            }
            normalize_optional_text(Some(out), 12_000)
        }
        Value::Object(object) => object
            .get("text")
            .and_then(Value::as_str)
            .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 12_000))
            .or_else(|| {
                object
                    .get("content")
                    .and_then(Value::as_str)
                    .and_then(|raw| normalize_optional_text(Some(raw.to_owned()), 12_000))
            }),
        _ => normalize_optional_text(Some(content.to_string()), 12_000),
    }
}

fn is_global_session(entry: &SessionEntry) -> bool {
    entry.key.eq_ignore_ascii_case("global") || entry.kind == SessionKind::Main
}

fn is_subagent_session_key(session_key: &str) -> bool {
    normalize(session_key).contains(":subagent:")
}

fn normalize_optional_text(value: Option<String>, max_len: usize) -> Option<String> {
    let value = value?;
    let trimmed = value.trim();
    if trimmed.is_empty() {
        return None;
    }
    if trimmed.len() <= max_len {
        return Some(trimmed.to_owned());
    }
    let mut end = max_len;
    while end > 0 && !trimmed.is_char_boundary(end) {
        end -= 1;
    }
    let mut out = trimmed[..end].to_owned();
    out.push_str("...");
    Some(out)
}

fn normalize_optional_seconds(value: Option<f64>) -> Option<u64> {
    let raw = value?;
    if !raw.is_finite() || raw < 0.0 {
        return None;
    }
    Some(raw.floor() as u64)
}

fn normalize_string_list(
    value: Option<Vec<String>>,
    max_items: usize,
    max_len: usize,
) -> Vec<String> {
    let mut out = Vec::new();
    for item in value.unwrap_or_default() {
        let Some(normalized) = normalize_optional_text(Some(item), max_len) else {
            continue;
        };
        if out
            .iter()
            .any(|existing: &String| existing.eq_ignore_ascii_case(&normalized))
        {
            continue;
        }
        out.push(normalized);
        if out.len() >= max_items {
            break;
        }
    }
    out
}

fn apply_patch_value<T>(target: &mut Option<T>, patch: PatchValue<T>) {
    match patch {
        PatchValue::Keep => {}
        PatchValue::Clear => *target = None,
        PatchValue::Set(value) => *target = Some(value),
    }
}

fn truncate_text(value: &str, max_len: usize) -> String {
    if value.len() <= max_len {
        return value.to_owned();
    }
    let mut end = max_len;
    while end > 0 && !value.is_char_boundary(end) {
        end -= 1;
    }
    let mut out = value[..end].to_owned();
    out.push_str("...");
    out
}

fn event_preview_text(event: &SessionHistoryEvent, max_len: usize) -> Option<String> {
    let value = event
        .text
        .as_deref()
        .or(event.command.as_deref())
        .map(str::trim)
        .filter(|v| !v.is_empty())?;
    Some(truncate_text(value, max_len))
}

fn format_utc_date(ms: u64) -> String {
    let days = (ms / 86_400_000) as i64;
    let (year, month, day) = civil_from_days(days);
    format!("{year:04}-{month:02}-{day:02}")
}

#[derive(Debug, Clone)]
struct UsageWindow {
    start_date: String,
    end_date: String,
    start_day: i64,
    end_day: i64,
    days: u32,
}

fn resolve_usage_window(
    start_date: Option<String>,
    end_date: Option<String>,
    days: Option<u32>,
) -> UsageWindow {
    let today = format_utc_date(now_ms());
    let normalized_start = normalize_date_yyyy_mm_dd(start_date);
    let normalized_end = normalize_date_yyyy_mm_dd(end_date);

    let (start, end) = match (normalized_start, normalized_end) {
        (Some(start), Some(end)) => {
            let start_days = parse_date_to_days(&start).unwrap_or(0);
            let end_days = parse_date_to_days(&end).unwrap_or(0);
            if start_days <= end_days {
                (start, end)
            } else {
                (end, start)
            }
        }
        (Some(start), None) => (start, today.clone()),
        (None, Some(end)) => {
            let span = days.unwrap_or(30).max(1);
            let end_days = parse_date_to_days(&end).unwrap_or(0);
            let start_days = end_days.saturating_sub((span - 1) as i64);
            let (y, m, d) = civil_from_days(start_days);
            (format!("{y:04}-{m:02}-{d:02}"), end)
        }
        (None, None) => {
            let span = days.unwrap_or(30).max(1);
            let end_days = parse_date_to_days(&today).unwrap_or(0);
            let start_days = end_days.saturating_sub((span - 1) as i64);
            let (y, m, d) = civil_from_days(start_days);
            (format!("{y:04}-{m:02}-{d:02}"), today)
        }
    };

    let start_day = parse_date_to_days(&start).unwrap_or(0);
    let end_day = parse_date_to_days(&end).unwrap_or(start_day);
    let day_span = end_day.saturating_sub(start_day) + 1;
    UsageWindow {
        start_date: start,
        end_date: end,
        start_day,
        end_day,
        days: day_span.max(1) as u32,
    }
}

fn normalize_usage_range(
    start_date: Option<String>,
    end_date: Option<String>,
    days: Option<u32>,
) -> Value {
    let window = resolve_usage_window(start_date, end_date, days);
    json!({
        "startDate": window.start_date,
        "endDate": window.end_date,
        "days": window.days
    })
}

fn normalize_date_yyyy_mm_dd(value: Option<String>) -> Option<String> {
    let raw = value?.trim().to_owned();
    let days = parse_date_to_days(&raw)?;
    let (y, m, d) = civil_from_days(days);
    let normalized = format!("{y:04}-{m:02}-{d:02}");
    if normalized == raw {
        Some(normalized)
    } else {
        None
    }
}

fn parse_date_to_days(value: &str) -> Option<i64> {
    let bytes = value.as_bytes();
    if bytes.len() != 10 || bytes[4] != b'-' || bytes[7] != b'-' {
        return None;
    }
    let year = value[0..4].parse::<i32>().ok()?;
    let month = value[5..7].parse::<u32>().ok()?;
    let day = value[8..10].parse::<u32>().ok()?;
    if !(1..=12).contains(&month) || !(1..=31).contains(&day) {
        return None;
    }
    let days = civil_to_days(year, month, day);
    let (cy, cm, cd) = civil_from_days(days);
    if cy == year && cm == month && cd == day {
        Some(days)
    } else {
        None
    }
}

fn civil_from_days(days_since_unix_epoch: i64) -> (i32, u32, u32) {
    let z = days_since_unix_epoch + 719_468;
    let era = if z >= 0 { z } else { z - 146_096 } / 146_097;
    let doe = z - era * 146_097;
    let yoe = (doe - doe / 1_460 + doe / 36_524 - doe / 146_096) / 365;
    let y = yoe + era * 400;
    let doy = doe - (365 * yoe + yoe / 4 - yoe / 100);
    let mp = (5 * doy + 2) / 153;
    let day = doy - (153 * mp + 2) / 5 + 1;
    let month = mp + if mp < 10 { 3 } else { -9 };
    let year = y + if month <= 2 { 1 } else { 0 };
    (year as i32, month as u32, day as u32)
}

fn civil_to_days(year: i32, month: u32, day: u32) -> i64 {
    let y = year as i64 - if month <= 2 { 1 } else { 0 };
    let era = if y >= 0 { y } else { y - 399 } / 400;
    let yoe = y - era * 400;
    let m = month as i64;
    let d = day as i64;
    let doy = (153 * (m + if m > 2 { -3 } else { 9 }) + 2) / 5 + d - 1;
    let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
    era * 146_097 + doe - 719_468
}

fn normalize(method: &str) -> String {
    method.trim().to_ascii_lowercase()
}

fn strip_disallowed_chat_control_chars(message: &str) -> String {
    let mut output = String::with_capacity(message.len());
    for ch in message.chars() {
        let code = ch as u32;
        if code == 9 || code == 10 || code == 13 || (code >= 32 && code != 127) {
            output.push(ch);
        }
    }
    output
}

fn sanitize_chat_send_message_input(message: &str) -> Result<String, String> {
    let normalized = message.nfc().collect::<String>();
    if normalized.contains('\0') {
        return Err("message must not contain null bytes".to_owned());
    }
    Ok(strip_disallowed_chat_control_chars(&normalized))
}

fn parse_agent_reset_command(message: &str) -> Option<(&'static str, Option<String>)> {
    let trimmed = message.trim();
    let lower = trimmed.to_ascii_lowercase();
    let (reason, prefix_len) = if lower.starts_with("/new") {
        ("new", 4usize)
    } else if lower.starts_with("/reset") {
        ("reset", 6usize)
    } else {
        return None;
    };
    if trimmed.len() > prefix_len {
        let separator = *trimmed.as_bytes().get(prefix_len)?;
        if !separator.is_ascii_whitespace() {
            return None;
        }
    }
    let tail = trimmed[prefix_len..].trim();
    let followup_message = if tail.is_empty() {
        None
    } else {
        Some(tail.to_owned())
    };
    Some((reason, followup_message))
}

fn is_chat_stop_command_text(text: &str) -> bool {
    let trimmed = text.trim();
    if trimmed.is_empty() {
        return false;
    }
    matches!(
        normalize(trimmed).as_str(),
        "/stop" | "stop" | "abort" | "interrupt" | "interrupts"
    )
}

fn canonicalize_session_key(raw: &str) -> String {
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return String::new();
    }
    let lowered = trimmed.to_ascii_lowercase();
    if lowered == "global" {
        return "global".to_owned();
    }
    if lowered == "main" {
        return "agent:main:main".to_owned();
    }
    if lowered.starts_with("agent:")
        || lowered.starts_with("cron:")
        || lowered.starts_with("hook:")
        || lowered.starts_with("node-")
    {
        return trimmed.to_owned();
    }
    if trimmed.contains(':') {
        return format!("agent:main:{trimmed}");
    }
    trimmed.to_owned()
}

fn normalize_session_key_input(raw: Option<String>) -> Option<String> {
    raw.map(|value| canonicalize_session_key(&value))
        .filter(|value| !value.is_empty())
}

fn parse_optional_label_filter(value: Option<String>) -> Result<Option<String>, String> {
    let Some(raw) = value else {
        return Ok(None);
    };
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return Ok(None);
    }
    if trimmed.chars().count() > 64 {
        return Err("label too long (max 64)".to_owned());
    }
    Ok(Some(trimmed.to_owned()))
}

fn now_ms() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis() as u64
}

fn next_session_id() -> String {
    let sequence = SESSION_ID_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("sess-{}-{sequence}", now_ms())
}

fn next_web_login_session_id() -> String {
    let sequence = WEB_LOGIN_ID_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("web-login-{}-{sequence}", now_ms())
}

fn next_oauth_session_id() -> String {
    let sequence = OAUTH_SESSION_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("oauth-{}-{sequence}", now_ms())
}

fn next_wizard_session_id() -> String {
    let sequence = WIZARD_ID_SEQUENCE.fetch_add(1, Ordering::Relaxed);
    format!("wizard-{}-{sequence}", now_ms())
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;
    use std::fs;
    use std::io::{Read, Write};
    use std::sync::{Arc, Mutex};
    use std::time::{Duration, Instant};

    use serde::Deserialize;
    use serde_json::{json, Value};

    use crate::protocol::MethodFamily;
    use crate::types::{ActionRequest, Decision, DecisionAction};

    use super::{
        build_cron_webhook_dispatch, now_ms, CronDelivery, CronJob, CronJobState, CronPayload,
        CronRunLogEntry, CronRunStatus, CronSchedule, CronWebhookDefaults, MethodRegistry,
        RpcDispatchOutcome, RpcDispatcher, RpcRequestFrame,
    };

    #[derive(Debug, Clone, Deserialize)]
    struct PayloadParitySuite {
        cases: Vec<PayloadParityCase>,
    }

    #[derive(Debug, Clone, Deserialize)]
    struct PayloadParityCase {
        name: String,
        #[serde(default)]
        prelude: Vec<PayloadParityRequest>,
        request: PayloadParityRequest,
        expect: PayloadParityExpectation,
    }

    #[derive(Debug, Clone, Deserialize)]
    struct PayloadParityRequest {
        id: String,
        method: String,
        #[serde(default)]
        params: Value,
        #[serde(default)]
        captures: Vec<PayloadParityCapture>,
        #[serde(rename = "sleepMs", alias = "sleep_ms", default)]
        sleep_ms: Option<u64>,
    }

    #[derive(Debug, Clone, Deserialize)]
    struct PayloadParityCapture {
        path: String,
        #[serde(rename = "as")]
        as_name: String,
    }

    #[derive(Debug, Clone, Deserialize)]
    struct PayloadParityExpectation {
        outcome: String,
        #[serde(default)]
        checks: Vec<PayloadParityCheck>,
        error: Option<PayloadParityErrorExpectation>,
        #[serde(rename = "errorChecks", default)]
        error_checks: Vec<PayloadParityCheck>,
        event: Option<PayloadParityEventExpectation>,
    }

    #[derive(Debug, Clone, Deserialize)]
    struct PayloadParityErrorExpectation {
        code: Option<i64>,
        #[serde(rename = "messageContains")]
        message_contains: Option<String>,
    }

    #[derive(Debug, Clone, Deserialize)]
    struct PayloadParityEventExpectation {
        name: String,
        #[serde(default)]
        checks: Vec<PayloadParityCheck>,
    }

    #[derive(Debug, Clone, Deserialize)]
    struct PayloadParityCheck {
        path: String,
        equals: Option<Value>,
        kind: Option<String>,
        #[serde(rename = "startsWith")]
        starts_with: Option<String>,
        contains: Option<String>,
        #[serde(rename = "nonEmpty")]
        non_empty: Option<bool>,
    }

    fn payload_outcome_name(value: &str) -> String {
        value.trim().to_ascii_lowercase()
    }

    fn assert_payload_checks(
        root: &Value,
        checks: &[PayloadParityCheck],
        case_name: &str,
        subject: &str,
    ) {
        for check in checks {
            let Some(actual) = root.pointer(&check.path) else {
                panic!("case {case_name} {subject} missing path {}", check.path);
            };

            if let Some(expected) = check.equals.as_ref() {
                assert_eq!(
                    actual, expected,
                    "case {case_name} {subject} path {} equality mismatch",
                    check.path
                );
            }

            if let Some(kind) = check.kind.as_deref() {
                match kind.trim().to_ascii_lowercase().as_str() {
                    "string" => {
                        assert!(
                            actual.is_string(),
                            "case {case_name} {subject} path {} expected string",
                            check.path
                        );
                    }
                    "number" => {
                        assert!(
                            actual.is_number(),
                            "case {case_name} {subject} path {} expected number",
                            check.path
                        );
                    }
                    "bool" | "boolean" => {
                        assert!(
                            actual.is_boolean(),
                            "case {case_name} {subject} path {} expected boolean",
                            check.path
                        );
                    }
                    "object" => {
                        assert!(
                            actual.is_object(),
                            "case {case_name} {subject} path {} expected object",
                            check.path
                        );
                    }
                    "array" => {
                        assert!(
                            actual.is_array(),
                            "case {case_name} {subject} path {} expected array",
                            check.path
                        );
                    }
                    "null" => {
                        assert!(
                            actual.is_null(),
                            "case {case_name} {subject} path {} expected null",
                            check.path
                        );
                    }
                    other => {
                        panic!(
                            "case {case_name} {subject} has unsupported check kind {other} at {}",
                            check.path
                        );
                    }
                }
            }

            if let Some(prefix) = check.starts_with.as_deref() {
                let value = actual.as_str().unwrap_or_else(|| {
                    panic!(
                        "case {case_name} {subject} path {} must be string for startsWith",
                        check.path
                    )
                });
                assert!(
                    value.starts_with(prefix),
                    "case {case_name} {subject} path {} expected prefix {prefix}, got {value}",
                    check.path
                );
            }

            if let Some(fragment) = check.contains.as_deref() {
                let value = actual.as_str().unwrap_or_else(|| {
                    panic!(
                        "case {case_name} {subject} path {} must be string for contains",
                        check.path
                    )
                });
                assert!(
                    value.contains(fragment),
                    "case {case_name} {subject} path {} expected to contain {fragment}, got {value}",
                    check.path
                );
            }

            if check.non_empty == Some(true) {
                match actual {
                    Value::String(value) => {
                        assert!(
                            !value.is_empty(),
                            "case {case_name} {subject} path {} expected non-empty string",
                            check.path
                        );
                    }
                    Value::Array(value) => {
                        assert!(
                            !value.is_empty(),
                            "case {case_name} {subject} path {} expected non-empty array",
                            check.path
                        );
                    }
                    Value::Object(value) => {
                        assert!(
                            !value.is_empty(),
                            "case {case_name} {subject} path {} expected non-empty object",
                            check.path
                        );
                    }
                    _ => {
                        panic!(
                            "case {case_name} {subject} path {} uses nonEmpty on unsupported type",
                            check.path
                        );
                    }
                }
            }
        }
    }

    fn capture_lookup_token(value: &str) -> Option<&str> {
        value
            .strip_prefix("${")
            .and_then(|inner| inner.strip_suffix('}'))
    }

    fn resolve_payload_template(value: &Value, captures: &HashMap<String, Value>) -> Value {
        match value {
            Value::String(raw) => {
                if let Some(key) = capture_lookup_token(raw) {
                    if let Some(captured) = captures.get(key) {
                        return captured.clone();
                    }
                }
                Value::String(raw.clone())
            }
            Value::Array(items) => Value::Array(
                items
                    .iter()
                    .map(|entry| resolve_payload_template(entry, captures))
                    .collect::<Vec<_>>(),
            ),
            Value::Object(map) => Value::Object(
                map.iter()
                    .map(|(key, entry)| (key.clone(), resolve_payload_template(entry, captures)))
                    .collect(),
            ),
            _ => value.clone(),
        }
    }

    #[test]
    fn resolves_known_method() {
        let registry = MethodRegistry::default_registry();
        let resolved = registry.resolve("sessions.patch");
        assert!(resolved.known);
        let spec = resolved.spec.expect("spec");
        assert_eq!(spec.family, MethodFamily::Sessions);
        assert!(spec.requires_auth);

        let connect = registry.resolve("connect");
        assert!(connect.known);
        let connect_spec = connect.spec.expect("connect spec");
        assert_eq!(connect_spec.family, MethodFamily::Connect);
        assert!(connect_spec.requires_auth);

        let voicewake = registry.resolve("voicewake.set");
        assert!(voicewake.known);
        let voicewake_spec = voicewake.spec.expect("voicewake spec");
        assert_eq!(voicewake_spec.family, MethodFamily::Gateway);
        assert!(voicewake_spec.requires_auth);

        let oauth = registry.resolve("auth.oauth.providers");
        assert!(oauth.known);
        let oauth_spec = oauth.spec.expect("oauth spec");
        assert_eq!(oauth_spec.family, MethodFamily::Gateway);
        assert!(oauth_spec.requires_auth);
    }

    #[test]
    fn flags_unknown_method() {
        let registry = MethodRegistry::default_registry();
        for method in ["foo.bar", "gateway.restart", "message.send"] {
            let resolved = registry.resolve(method);
            assert!(!resolved.known);
            assert!(resolved.spec.is_none());
        }
    }

    #[tokio::test]
    async fn dispatcher_rejects_connect_method_after_handshake() {
        let dispatcher = RpcDispatcher::new();
        let req = RpcRequestFrame {
            id: "req-connect-after-handshake".to_owned(),
            method: "connect".to_owned(),
            params: serde_json::json!({
                "client": {
                    "id": "openclaw-cli",
                    "mode": "cli"
                }
            }),
        };
        match dispatcher.handle_request(&req).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert_eq!(message, "connect is only valid as the first request");
            }
            _ => panic!("expected connect rejection after handshake"),
        }
    }

    #[tokio::test]
    async fn dispatcher_patches_and_lists_sessions() {
        let dispatcher = RpcDispatcher::new();
        let patch = RpcRequestFrame {
            id: "req-1".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": "agent:main:discord:group:g1",
                "sendPolicy": "deny",
                "groupActivation": "mention",
                "queueMode": "steer"
            }),
        };
        let out = dispatcher.handle_request(&patch).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:main:discord:group:g1")
                );
                assert_eq!(
                    payload
                        .pointer("/entry/key")
                        .and_then(serde_json::Value::as_str),
                    Some("agent:main:discord:group:g1")
                );
                assert_eq!(
                    payload
                        .pointer("/entry/sendPolicy")
                        .and_then(serde_json::Value::as_str),
                    Some("deny")
                );
            }
            _ => panic!("expected handled patch"),
        }

        let list = RpcRequestFrame {
            id: "req-2".to_owned(),
            method: "sessions.list".to_owned(),
            params: serde_json::json!({"limit": 10}),
        };
        let out = dispatcher.handle_request(&list).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/path").and_then(serde_json::Value::as_str),
                    Some(super::SESSION_STORE_PATH)
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/key")
                        .and_then(serde_json::Value::as_str),
                    Some("agent:main:discord:group:g1")
                );
            }
            _ => panic!("expected handled list"),
        }
    }

    #[tokio::test]
    async fn dispatcher_rejects_invalid_patch_params() {
        let dispatcher = RpcDispatcher::new();
        for (idx, params) in [
            serde_json::json!({
                "sessionKey": "agent:main:discord:group:g1",
                "queueMode": "invalid"
            }),
            serde_json::json!({
                "key": "agent:main:discord:group:g1",
                "thinkingLevel": "banana"
            }),
            serde_json::json!({
                "key": "agent:main:discord:group:g1",
                "reasoningLevel": "mystery"
            }),
            serde_json::json!({
                "key": "agent:main:discord:group:g1",
                "execHost": "remote"
            }),
            serde_json::json!({
                "key": "agent:main:discord:group:g1",
                "sendPolicy": "inherit"
            }),
            serde_json::json!({
                "key": "agent:main:discord:group:g1",
                "label": "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm"
            }),
        ]
        .into_iter()
        .enumerate()
        {
            let patch = RpcRequestFrame {
                id: format!("req-invalid-{idx}"),
                method: "sessions.patch".to_owned(),
                params,
            };
            let out = dispatcher.handle_request(&patch).await;
            assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
        }
    }

    #[tokio::test]
    async fn dispatcher_patch_supports_extended_fields_and_null_clear() {
        let dispatcher = RpcDispatcher::new();
        let key = "agent:main:discord:subagent:g-extended";

        let patch_set = RpcRequestFrame {
            id: "req-patch-extended-set".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "sendPolicy": "deny",
                "groupActivation": "mention",
                "queueMode": "steer",
                "thinkingLevel": "medium",
                "verboseLevel": "off",
                "reasoningLevel": "stream",
                "responseUsage": "tokens",
                "elevatedLevel": "ask",
                "execHost": "sandbox",
                "execSecurity": "allowlist",
                "execAsk": "on-miss",
                "execNode": "node-a",
                "model": "openai/gpt-4o-mini",
                "spawnDepth": 2
            }),
        };
        let out = dispatcher.handle_request(&patch_set).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/entry/thinkingLevel")
                        .and_then(serde_json::Value::as_str),
                    Some("medium")
                );
                assert_eq!(
                    payload
                        .pointer("/entry/modelOverride")
                        .and_then(serde_json::Value::as_str),
                    Some("gpt-4o-mini")
                );
                assert_eq!(
                    payload
                        .pointer("/entry/providerOverride")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
                assert_eq!(
                    payload
                        .pointer("/resolved/model")
                        .and_then(serde_json::Value::as_str),
                    Some("gpt-4o-mini")
                );
                assert_eq!(
                    payload
                        .pointer("/entry/spawnDepth")
                        .and_then(serde_json::Value::as_u64),
                    Some(2)
                );
            }
            _ => panic!("expected extended patch handled"),
        }

        let patch_clear = RpcRequestFrame {
            id: "req-patch-extended-clear".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "sendPolicy": null,
                "groupActivation": null,
                "queueMode": null,
                "verboseLevel": null,
                "responseUsage": null,
                "model": null
            }),
        };
        let out = dispatcher.handle_request(&patch_clear).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(payload.pointer("/entry/sendPolicy").is_none());
                assert!(payload.pointer("/entry/groupActivation").is_none());
                assert!(payload.pointer("/entry/queueMode").is_none());
                assert!(payload.pointer("/entry/verboseLevel").is_none());
                assert!(payload.pointer("/entry/responseUsage").is_none());
                assert_eq!(
                    payload
                        .pointer("/entry/spawnDepth")
                        .and_then(serde_json::Value::as_u64),
                    Some(2)
                );
                assert!(payload.pointer("/entry/modelOverride").is_none());
                assert!(payload.pointer("/entry/providerOverride").is_none());
            }
            _ => panic!("expected clear patch handled"),
        }

        let patch_toggle_off = RpcRequestFrame {
            id: "req-patch-extended-off-clears".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "reasoningLevel": "off",
                "responseUsage": "off"
            }),
        };
        let out = dispatcher.handle_request(&patch_toggle_off).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(payload.pointer("/entry/reasoningLevel").is_none());
                assert!(payload.pointer("/entry/responseUsage").is_none());
            }
            _ => panic!("expected off-clear patch handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_patch_model_normalizes_provider_aliases_and_failover_provider_rules() {
        let dispatcher = RpcDispatcher::new();
        let key = "agent:main:discord:group:g-model-normalize";

        let patch_provider_alias = RpcRequestFrame {
            id: "req-patch-model-provider-alias".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "model": "z.ai/glm-4.5"
            }),
        };
        match dispatcher.handle_request(&patch_provider_alias).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/entry/providerOverride")
                        .and_then(serde_json::Value::as_str),
                    Some("zai")
                );
                assert_eq!(
                    payload
                        .pointer("/entry/modelOverride")
                        .and_then(serde_json::Value::as_str),
                    Some("glm-4.5")
                );
            }
            _ => panic!("expected alias-normalized model patch"),
        }

        let patch_codex = RpcRequestFrame {
            id: "req-patch-model-codex-provider".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "model": "openai/gpt-5.3-codex"
            }),
        };
        match dispatcher.handle_request(&patch_codex).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/entry/providerOverride")
                        .and_then(serde_json::Value::as_str),
                    Some("openai-codex")
                );
                assert_eq!(
                    payload
                        .pointer("/entry/modelOverride")
                        .and_then(serde_json::Value::as_str),
                    Some("gpt-5.3-codex")
                );
            }
            _ => panic!("expected codex provider model patch"),
        }

        let patch_anthropic_alias = RpcRequestFrame {
            id: "req-patch-model-anthropic-alias".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "model": "anthropic/sonnet-4.5"
            }),
        };
        match dispatcher.handle_request(&patch_anthropic_alias).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/entry/providerOverride")
                        .and_then(serde_json::Value::as_str),
                    Some("anthropic")
                );
                assert_eq!(
                    payload
                        .pointer("/entry/modelOverride")
                        .and_then(serde_json::Value::as_str),
                    Some("claude-sonnet-4-5")
                );
            }
            _ => panic!("expected anthropic alias model patch"),
        }
    }

    #[test]
    fn model_provider_failover_chain_normalizes_aliases() {
        assert_eq!(
            super::model_provider_failover_chain("openai-codex"),
            vec!["openai".to_owned(), "anthropic".to_owned()]
        );
        assert_eq!(
            super::model_provider_failover_chain("openai"),
            vec!["openai-codex".to_owned(), "anthropic".to_owned()]
        );
        assert_eq!(
            super::model_provider_failover_chain("z.ai"),
            vec!["openai".to_owned()]
        );
        assert_eq!(
            super::model_provider_failover_chain("qwen"),
            vec!["openai".to_owned()]
        );
        assert_eq!(
            super::model_provider_failover_chain("cerebras"),
            vec!["openai".to_owned()]
        );
        assert_eq!(
            super::model_provider_failover_chain("zhipu"),
            vec!["openai".to_owned()]
        );
        assert!(super::model_provider_failover_chain("unknown-provider").is_empty());
    }

    #[test]
    fn normalize_provider_id_maps_major_aliases() {
        assert_eq!(super::normalize_provider_id("z.ai"), "zai");
        assert_eq!(super::normalize_provider_id("doubao"), "volcengine");
        assert_eq!(super::normalize_provider_id("Bytedance"), "volcengine");
        assert_eq!(super::normalize_provider_id("chatgpt"), "openai");
        assert_eq!(super::normalize_provider_id("codex-cli"), "openai-codex");
        assert_eq!(super::normalize_provider_id("qwen"), "qwen-portal");
        assert_eq!(super::normalize_provider_id("gemini"), "google");
        assert_eq!(super::normalize_provider_id("claude"), "anthropic");
        assert_eq!(super::normalize_provider_id("lm-studio"), "lmstudio");
        assert_eq!(super::normalize_provider_id("local-ai"), "localai");
        assert_eq!(super::normalize_provider_id("zhipu"), "zhipuai");
        assert_eq!(super::normalize_provider_id("llama-cpp"), "llamacpp");
        assert_eq!(super::normalize_provider_id("hf-tgi"), "tgi");
        assert_eq!(super::normalize_provider_id("deep-infra"), "deepinfra");
        assert_eq!(super::normalize_provider_id("google-vertex"), "vertex-ai");
        assert_eq!(super::normalize_provider_id("amazon-bedrock"), "bedrock");
        assert_eq!(
            super::normalize_provider_id("zhipu-coding"),
            "zhipuai-coding"
        );
    }

    #[test]
    fn model_registry_defaults_include_opencode_and_zhipuai_choices() {
        let registry = super::ModelRegistry::new();
        let models = registry.list();
        assert!(models.iter().any(|entry| {
            entry.provider.eq_ignore_ascii_case("opencode")
                && entry.id.eq_ignore_ascii_case("glm-5-free")
        }));
        assert!(models.iter().any(|entry| {
            entry.provider.eq_ignore_ascii_case("opencode")
                && entry.id.eq_ignore_ascii_case("kimi-k2.5-free")
        }));
        assert!(models.iter().any(|entry| {
            entry.provider.eq_ignore_ascii_case("opencode")
                && entry.id.eq_ignore_ascii_case("minimax-m2.5-free")
        }));
        assert!(models.iter().any(|entry| {
            entry.provider.eq_ignore_ascii_case("zhipuai") && entry.id.eq_ignore_ascii_case("glm-5")
        }));
        assert!(models.iter().any(|entry| {
            entry.provider.eq_ignore_ascii_case("openrouter")
                && entry
                    .id
                    .eq_ignore_ascii_case("google/gemini-2.0-flash-exp:free")
        }));
    }

    #[test]
    fn model_catalog_from_provider_entries_parses_nested_provider_models() {
        let config = json!({
            "models": {
                "providers": {
                    "cerebras": {
                        "api": "openai-completions",
                        "baseUrl": "https://api.cerebras.ai/v1",
                        "models": [
                            {
                                "id": "llama-4-scout-17b-16e-instruct",
                                "name": "Cerebras Scout",
                                "reasoning": true,
                                "contextWindow": 131072
                            }
                        ]
                    }
                }
            }
        });
        let mut catalog = super::model_catalog_from_config(&config);
        super::ModelRegistry::sort_models(&mut catalog);
        assert_eq!(catalog.len(), 1);
        assert_eq!(catalog[0].provider, "cerebras");
        assert_eq!(catalog[0].id, "llama-4-scout-17b-16e-instruct");
        assert_eq!(catalog[0].name, "Cerebras Scout");
        assert_eq!(catalog[0].context_window, Some(131072));
        assert_eq!(catalog[0].reasoning, Some(true));
    }

    #[test]
    fn resolve_provider_runtime_config_supports_cerebras_format() {
        let config = json!({
            "models": {
                "providers": {
                    "cerebras": {
                        "api": "openai-completions",
                        "baseUrl": "https://api.cerebras.ai/v1",
                        "apiKey": "cerebras-test-key",
                        "timeoutMs": 35000
                    }
                }
            }
        });
        let resolved = super::resolve_provider_runtime_config(&config, "cerebras")
            .expect("cerebras runtime config");
        assert_eq!(resolved.provider, "cerebras");
        assert_eq!(resolved.api_mode, "openai-completions");
        assert_eq!(resolved.base_url, "https://api.cerebras.ai/v1");
        assert_eq!(resolved.api_key.as_deref(), Some("cerebras-test-key"));
        assert!(!resolved.allow_missing_api_key);
        assert_eq!(resolved.auth_header_name, "Authorization");
        assert_eq!(resolved.auth_header_prefix, "Bearer ");
        assert!(resolved.headers.iter().any(|(name, value)| {
            name.eq_ignore_ascii_case("X-Cerebras-3rd-Party-Integration")
                && value == "openclaw-rust"
        }));
        assert_eq!(resolved.timeout_ms, 35_000);
    }

    #[test]
    fn resolve_provider_runtime_config_supports_zhipu_openai_defaults() {
        let config = json!({});
        let resolved =
            super::resolve_provider_runtime_config(&config, "zhipu").expect("zhipu runtime config");
        assert_eq!(resolved.provider, "zhipuai");
        assert_eq!(resolved.api_mode, "openai-completions");
        assert_eq!(resolved.base_url, "https://open.bigmodel.cn/api/paas/v4");
        assert!(!resolved.allow_missing_api_key);
    }

    #[test]
    fn resolve_provider_runtime_config_supports_opencode_zen_keyless_defaults() {
        let config = json!({});
        let resolved = super::resolve_provider_runtime_config(&config, "opencode")
            .expect("opencode runtime config");
        assert_eq!(resolved.provider, "opencode");
        assert_eq!(resolved.api_mode, "openai-completions");
        assert_eq!(resolved.base_url, "https://opencode.ai/zen/v1");
        assert!(resolved.allow_missing_api_key);
        assert_eq!(resolved.website_url.as_deref(), Some("https://opencode.ai"));
        assert!(resolved
            .bridge_candidates
            .iter()
            .any(|candidate| candidate == "https://opencode.ai/zen/v1"));
    }

    #[test]
    fn resolve_provider_runtime_config_supports_additional_openai_compatible_presets() {
        let config = json!({});
        let deepinfra = super::resolve_provider_runtime_config(&config, "deep-infra")
            .expect("deepinfra runtime config");
        assert_eq!(deepinfra.provider, "deepinfra");
        assert_eq!(deepinfra.base_url, "https://api.deepinfra.com/v1/openai");
        assert!(!deepinfra.allow_missing_api_key);

        let llamacpp = super::resolve_provider_runtime_config(&config, "llama-cpp")
            .expect("llamacpp runtime config");
        assert_eq!(llamacpp.provider, "llamacpp");
        assert_eq!(llamacpp.base_url, "http://127.0.0.1:8080/v1");
        assert!(llamacpp.allow_missing_api_key);
    }

    #[test]
    fn resolve_provider_runtime_config_supports_nested_options_custom_auth_and_payload_defaults() {
        let config = json!({
            "models": {
                "providers": {
                    "custom-openai": {
                        "options": {
                            "baseURL": "https://proxy.example/v1",
                            "apiKey": "custom-token",
                            "authHeaderName": "api-key",
                            "authHeaderPrefix": "",
                            "headers": {
                                "X-Workspace": "team-alpha"
                            },
                            "requestDefaults": {
                                "temperature": 0.2,
                                "reasoning_effort": "medium"
                            }
                        }
                    }
                }
            }
        });
        let resolved = super::resolve_provider_runtime_config(&config, "custom-openai")
            .expect("custom runtime config");
        assert_eq!(resolved.provider, "custom-openai");
        assert_eq!(resolved.base_url, "https://proxy.example/v1");
        assert_eq!(resolved.api_key.as_deref(), Some("custom-token"));
        assert_eq!(resolved.auth_header_name, "api-key");
        assert_eq!(resolved.auth_header_prefix, "");
        assert!(
            resolved
                .headers
                .iter()
                .any(|(name, value)| name.eq_ignore_ascii_case("X-Workspace")
                    && value == "team-alpha")
        );
        assert_eq!(
            resolved
                .request_overrides
                .get("temperature")
                .and_then(Value::as_f64),
            Some(0.2)
        );
        assert_eq!(
            resolved
                .request_overrides
                .get("reasoning_effort")
                .and_then(Value::as_str),
            Some("medium")
        );
    }

    #[test]
    fn resolve_provider_runtime_config_supports_website_bridge_options() {
        let config = json!({
            "models": {
                "providers": {
                    "zhipuai": {
                        "options": {
                            "apiMode": "website-openai-bridge",
                            "websiteUrl": "https://chat.z.ai",
                            "bridgeBaseUrls": [
                                "https://chat.z.ai/api/paas/v4",
                                "https://chat.z.ai/api/paas/v4"
                            ],
                            "allowUnauthenticated": true
                        }
                    }
                }
            }
        });
        let resolved = super::resolve_provider_runtime_config(&config, "zhipu")
            .expect("zhipu website bridge config");
        assert_eq!(resolved.provider, "zhipuai");
        assert_eq!(resolved.api_mode, "website-openai-bridge");
        assert_eq!(resolved.website_url.as_deref(), Some("https://chat.z.ai"));
        assert_eq!(resolved.bridge_candidates.len(), 1);
        assert!(resolved.allow_missing_api_key);
    }

    #[test]
    fn resolve_provider_runtime_config_allows_unauthenticated_local_defaults() {
        let config = json!({});
        let resolved = super::resolve_provider_runtime_config(&config, "ollama")
            .expect("ollama runtime config");
        assert_eq!(resolved.provider, "ollama");
        assert!(resolved.api_key.is_none());
        assert!(resolved.allow_missing_api_key);
        assert_eq!(resolved.base_url, "http://127.0.0.1:11434/v1");
    }

    #[test]
    fn provider_chat_completions_url_preserves_explicit_endpoint_with_query() {
        let endpoint = "https://example.openai.azure.com/openai/deployments/my-deploy/chat/completions?api-version=2024-10-21";
        assert_eq!(super::provider_chat_completions_url(endpoint), endpoint);
    }

    #[test]
    fn provider_api_mode_supported_includes_website_bridge_modes() {
        assert!(super::provider_api_mode_supported("openai-completions"));
        assert!(super::provider_api_mode_supported("website-openai-bridge"));
        assert!(super::provider_api_mode_supported("website-bridge"));
        assert!(!super::provider_api_mode_supported("custom-mode-unknown"));
    }

    #[tokio::test]
    async fn invoke_openai_chat_completion_applies_custom_auth_header_and_payload_defaults() {
        let listener = std::net::TcpListener::bind("127.0.0.1:0").expect("bind provider listener");
        let provider_addr = listener.local_addr().expect("provider addr");
        let captured_request: Arc<Mutex<Option<String>>> = Arc::new(Mutex::new(None));
        let captured_request_server = Arc::clone(&captured_request);
        let server = std::thread::spawn(move || {
            let (mut stream, _) = listener.accept().expect("accept request");
            let mut buffer = vec![0_u8; 64 * 1024];
            let read = stream.read(&mut buffer).expect("read request");
            let request_text = String::from_utf8_lossy(&buffer[..read]).to_string();
            if let Ok(mut guard) = captured_request_server.lock() {
                *guard = Some(request_text);
            }
            let payload = json!({
                "id": "cmpl-custom-auth",
                "choices": [
                    {
                        "message": {
                            "content": "ok"
                        }
                    }
                ]
            });
            let body = payload.to_string();
            let response = format!(
                "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: {}\r\nConnection: close\r\n\r\n{}",
                body.len(),
                body
            );
            stream
                .write_all(response.as_bytes())
                .expect("write response");
        });

        let mut request_overrides = serde_json::Map::new();
        request_overrides.insert("temperature".to_owned(), json!(0.3));
        request_overrides.insert("top_p".to_owned(), json!(0.95));
        let provider_runtime = super::ProviderRuntimeConfig {
            provider: "custom-openai".to_owned(),
            api_mode: "openai-completions".to_owned(),
            base_url: format!("http://{provider_addr}/v1"),
            api_key: Some("custom-token".to_owned()),
            allow_missing_api_key: false,
            website_url: None,
            bridge_candidates: Vec::new(),
            auth_header_name: "api-key".to_owned(),
            auth_header_prefix: String::new(),
            timeout_ms: 30_000,
            headers: vec![("X-Custom".to_owned(), "abc".to_owned())],
            request_overrides,
        };
        let messages = vec![json!({
            "role": "user",
            "content": "hello"
        })];
        let tools = vec![json!({
            "type": "function",
            "function": {
                "name": "read",
                "parameters": {
                    "type": "object"
                }
            }
        })];

        let completion = super::invoke_openai_chat_completion(
            &provider_runtime,
            "test-model",
            &messages,
            &tools,
        )
        .await
        .expect("completion request");
        assert_eq!(completion.choices.len(), 1);

        server.join().expect("join provider server");
        let request_text = captured_request
            .lock()
            .expect("lock captured request")
            .clone()
            .expect("captured request");
        let request_lower = request_text.to_ascii_lowercase();
        assert!(request_lower.contains("\r\napi-key: custom-token\r\n"));
        assert!(request_lower.contains("\r\nx-custom: abc\r\n"));
        let body = request_text
            .split("\r\n\r\n")
            .nth(1)
            .unwrap_or_default()
            .to_owned();
        let payload: Value = serde_json::from_str(&body).expect("parse request payload");
        assert_eq!(
            payload.pointer("/temperature").and_then(Value::as_f64),
            Some(0.3)
        );
        assert_eq!(
            payload.pointer("/top_p").and_then(Value::as_f64),
            Some(0.95)
        );
        assert_eq!(
            payload.pointer("/tool_choice").and_then(Value::as_str),
            Some("auto")
        );
    }

    #[tokio::test]
    #[ignore = "live network smoke against OpenCode Zen free tier"]
    async fn live_openai_compatible_opencode_smoke_when_credentials_are_configured() {
        let api_key = std::env::var("OPENCODE_API_KEY")
            .ok()
            .or_else(|| std::env::var("OPENAI_API_KEY").ok())
            .and_then(|value| super::normalize_optional_text(Some(value), 4_096));
        let model = std::env::var("OPENCODE_SMOKE_MODEL")
            .ok()
            .and_then(|value| super::normalize_optional_text(Some(value), 256))
            .unwrap_or_else(|| "glm-5-free".to_owned());
        let base_url = std::env::var("OPENCODE_BASE_URL")
            .ok()
            .and_then(|value| super::normalize_optional_text(Some(value), 2_048))
            .unwrap_or_else(|| "https://opencode.ai/zen/v1".to_owned());
        let runtime = super::ProviderRuntimeConfig {
            provider: "opencode".to_owned(),
            api_mode: "openai-completions".to_owned(),
            base_url,
            api_key,
            allow_missing_api_key: true,
            website_url: Some("https://opencode.ai".to_owned()),
            bridge_candidates: vec!["https://opencode.ai/zen/v1".to_owned()],
            auth_header_name: "Authorization".to_owned(),
            auth_header_prefix: "Bearer ".to_owned(),
            timeout_ms: 60_000,
            headers: Vec::new(),
            request_overrides: serde_json::Map::new(),
        };
        let messages = vec![json!({
            "role": "user",
            "content": "Reply with exactly: ok"
        })];
        let completion =
            super::invoke_openai_chat_completion(&runtime, &model, &messages, &[]).await;
        let completion = completion.expect("live completion response");
        let assistant = completion
            .choices
            .first()
            .and_then(|choice| super::extract_openai_message_text(choice.message.content.as_ref()))
            .unwrap_or_default();
        assert!(
            !assistant.trim().is_empty(),
            "live provider response should contain assistant text"
        );
    }

    #[test]
    fn oauth_provider_aliases_normalize_major_providers() {
        assert_eq!(
            super::normalize_oauth_provider_id("chatgpt"),
            Some("openai".to_owned())
        );
        assert_eq!(
            super::normalize_oauth_provider_id("codex-cli"),
            Some("openai-codex".to_owned())
        );
        assert_eq!(
            super::normalize_oauth_provider_id("claude"),
            Some("anthropic".to_owned())
        );
        assert_eq!(
            super::normalize_oauth_provider_id("gemini"),
            Some("google-gemini-cli".to_owned())
        );
        assert_eq!(
            super::normalize_oauth_provider_id("kimi"),
            Some("kimi-coding".to_owned())
        );
        assert_eq!(
            super::normalize_oauth_provider_id("opencode-zen"),
            Some("opencode".to_owned())
        );
        assert_eq!(
            super::normalize_oauth_provider_id("zhipu"),
            Some("zhipuai".to_owned())
        );
    }

    #[tokio::test]
    async fn dispatcher_patch_model_clears_auth_profile_override_fields() {
        let dispatcher = RpcDispatcher::new();
        let key = "agent:main:discord:group:g-model-auth-clear";

        let initial_patch = RpcRequestFrame {
            id: "req-model-auth-clear-init".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "model": "anthropic/claude-opus-4-5"
            }),
        };
        let out = dispatcher.handle_request(&initial_patch).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let _ = dispatcher
            .sessions
            .apply_auth_profile_resolution(
                key,
                Some("anthropic:default".to_owned()),
                Some(super::AuthProfileSource::User),
                Some(3),
            )
            .await;

        let next_patch = RpcRequestFrame {
            id: "req-model-auth-clear-next".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "model": "openai/gpt-5.3"
            }),
        };
        match dispatcher.handle_request(&next_patch).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(payload.pointer("/entry/authProfileOverride").is_none());
                assert!(payload
                    .pointer("/entry/authProfileOverrideSource")
                    .is_none());
                assert!(payload
                    .pointer("/entry/authProfileOverrideCompactionCount")
                    .is_none());
            }
            _ => panic!("expected model patch handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_agent_runtime_failover_uses_fallback_provider_on_profile_cooldown() {
        let dispatcher = RpcDispatcher::new();
        let key = "agent:main:discord:group:g-model-failover";

        let patch = RpcRequestFrame {
            id: "req-model-failover-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "model": "openai/gpt-5.3-codex"
            }),
        };
        let out = dispatcher.handle_request(&patch).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        dispatcher
            .auth_profiles
            .set_provider_cooldown_until("openai-codex", Some(super::now_ms() + 60_000))
            .await;

        let run = RpcRequestFrame {
            id: "req-model-failover-agent".to_owned(),
            method: "agent".to_owned(),
            params: serde_json::json!({
                "sessionKey": key,
                "idempotencyKey": "idem-model-failover-agent",
                "message": "test fallback"
            }),
        };
        match dispatcher.handle_request(&run).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/resolved/modelProvider")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
                assert_eq!(
                    payload
                        .pointer("/resolved/attempts/0/provider")
                        .and_then(serde_json::Value::as_str),
                    Some("openai-codex")
                );
                assert_eq!(
                    payload
                        .pointer("/resolved/attempts/0/status")
                        .and_then(serde_json::Value::as_str),
                    Some("skipped")
                );
                assert_eq!(
                    payload
                        .pointer("/resolved/attempts/0/reason")
                        .and_then(serde_json::Value::as_str),
                    Some("profile_cooldown")
                );
                assert_eq!(
                    payload
                        .pointer("/resolved/attempts/1/provider")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
            }
            _ => panic!("expected agent run handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_agent_runtime_self_heals_with_fallback_provider_retry() {
        let listener = std::net::TcpListener::bind("127.0.0.1:0").expect("bind provider listener");
        let provider_addr = listener.local_addr().expect("provider addr");
        let server = std::thread::spawn(move || {
            let (mut stream, _) = listener.accept().expect("accept provider request");
            let mut buffer = vec![0_u8; 64 * 1024];
            let _ = stream.read(&mut buffer).expect("read provider request");
            let payload = json!({
                "id": "cmpl-self-heal-1",
                "object": "chat.completion",
                "choices": [
                    {
                        "index": 0,
                        "message": {
                            "role": "assistant",
                            "content": "self-heal-ok"
                        }
                    }
                ]
            });
            let body = payload.to_string();
            let response = format!(
                "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: {}\r\nConnection: close\r\n\r\n{}",
                body.len(),
                body
            );
            stream
                .write_all(response.as_bytes())
                .expect("write provider response");
        });

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "models": {
                    "providers": {
                        "ollama": {
                            "api": "openai-completions",
                            "baseUrl": "http://127.0.0.1:1/v1",
                            "allowUnauthenticated": true,
                            "models": [{ "id": "tiny-local", "name": "Tiny Local" }]
                        },
                        "openai": {
                            "api": "openai-completions",
                            "baseUrl": format!("http://{provider_addr}/v1"),
                            "apiKey": "test-openai-key",
                            "models": [{ "id": "gpt-5.3", "name": "GPT-5.3" }]
                        }
                    }
                }
            }),
        )
        .await;

        let session_key = "agent:main:discord:group:g-self-heal-retry";
        let patch_model = RpcRequestFrame {
            id: "req-self-heal-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: json!({
                "key": session_key,
                "model": "ollama/tiny-local"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&patch_model).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let run_agent = RpcRequestFrame {
            id: "req-self-heal-run".to_owned(),
            method: "agent".to_owned(),
            params: json!({
                "sessionKey": session_key,
                "idempotencyKey": "self-heal-run-1",
                "message": "recover this run"
            }),
        };
        match dispatcher.handle_request(&run_agent).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/status").and_then(Value::as_str),
                    Some("started")
                );
                assert_eq!(
                    payload.pointer("/runtime/provider").and_then(Value::as_str),
                    Some("openai")
                );
                assert_eq!(
                    payload
                        .pointer("/runtime/selfHealing/enabled")
                        .and_then(Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/runtime/selfHealing/recovered")
                        .and_then(Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/runtime/selfHealing/profile")
                        .and_then(Value::as_str),
                    Some("core")
                );
                assert_eq!(
                    payload
                        .pointer("/runtime/selfHealing/maxAttempts")
                        .and_then(Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/runtime/selfHealing/backoffMs")
                        .and_then(Value::as_u64),
                    Some(250)
                );
                assert!(payload
                    .pointer("/runtime/selfHealing/attempts")
                    .and_then(Value::as_array)
                    .is_some_and(|items| {
                        items.iter().any(|entry| {
                            entry.pointer("/provider").and_then(Value::as_str) == Some("openai")
                                && entry.pointer("/status").and_then(Value::as_str)
                                    == Some("recovered")
                        })
                    }));
            }
            _ => panic!("expected runtime agent request to be handled"),
        }

        let wait = RpcRequestFrame {
            id: "req-self-heal-wait".to_owned(),
            method: "agent.wait".to_owned(),
            params: json!({
                "runId": "self-heal-run-1",
                "timeoutMs": 0
            }),
        };
        match dispatcher.handle_request(&wait).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/status").and_then(Value::as_str),
                    Some("ok")
                );
            }
            _ => panic!("expected agent.wait handled"),
        }

        server.join().expect("join self-heal provider server");
    }

    #[tokio::test]
    async fn dispatcher_compact_rotates_auto_auth_profile_override() {
        let dispatcher = RpcDispatcher::new();
        let key = "agent:main:discord:group:g-model-rotate";

        let patch = RpcRequestFrame {
            id: "req-model-rotate-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "model": "anthropic/claude-sonnet-4-5"
            }),
        };
        let out = dispatcher.handle_request(&patch).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let agent = RpcRequestFrame {
            id: "req-model-rotate-agent".to_owned(),
            method: "agent".to_owned(),
            params: serde_json::json!({
                "sessionKey": key,
                "idempotencyKey": "idem-model-rotate-agent",
                "message": "initialize profile"
            }),
        };
        let out = dispatcher.handle_request(&agent).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        for idx in 0..3 {
            let send = RpcRequestFrame {
                id: format!("req-model-rotate-send-{idx}"),
                method: "sessions.send".to_owned(),
                params: serde_json::json!({
                    "sessionKey": key,
                    "message": format!("line-{idx}")
                }),
            };
            let out = dispatcher.handle_request(&send).await;
            assert!(matches!(out, RpcDispatchOutcome::Handled(_)));
        }

        let compact = RpcRequestFrame {
            id: "req-model-rotate-compact".to_owned(),
            method: "sessions.compact".to_owned(),
            params: serde_json::json!({
                "sessionKey": key,
                "maxLines": 1
            }),
        };
        match dispatcher.handle_request(&compact).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/resolved/authProfile")
                        .and_then(serde_json::Value::as_str),
                    Some("anthropic:backup")
                );
            }
            _ => panic!("expected compact handled"),
        }

        let status = RpcRequestFrame {
            id: "req-model-rotate-status".to_owned(),
            method: "session.status".to_owned(),
            params: serde_json::json!({
                "sessionKey": key
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/session/authProfileOverride")
                        .and_then(serde_json::Value::as_str),
                    Some("anthropic:backup")
                );
                assert_eq!(
                    payload
                        .pointer("/session/authProfileOverrideSource")
                        .and_then(serde_json::Value::as_str),
                    Some("auto")
                );
            }
            _ => panic!("expected session.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_patch_enforces_spawned_by_and_spawn_depth_rules() {
        let dispatcher = RpcDispatcher::new();

        let non_subagent = RpcRequestFrame {
            id: "req-patch-non-subagent".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": "agent:main:discord:group:g-rules",
                "spawnedBy": "agent:main:main"
            }),
        };
        let out = dispatcher.handle_request(&non_subagent).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let key = "agent:main:discord:subagent:g-rules";
        let initial = RpcRequestFrame {
            id: "req-patch-subagent-init".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "spawnedBy": "agent:main:main",
                "spawnDepth": 1
            }),
        };
        let out = dispatcher.handle_request(&initial).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let change_spawned_by = RpcRequestFrame {
            id: "req-patch-subagent-change-spawned".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "spawnedBy": "agent:main:other"
            }),
        };
        let out = dispatcher.handle_request(&change_spawned_by).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let change_spawn_depth = RpcRequestFrame {
            id: "req-patch-subagent-change-depth".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "spawnDepth": 2
            }),
        };
        let out = dispatcher.handle_request(&change_spawn_depth).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let clear_spawned_by = RpcRequestFrame {
            id: "req-patch-subagent-clear-spawned".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "spawnedBy": null
            }),
        };
        let out = dispatcher.handle_request(&clear_spawned_by).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let clear_spawn_depth = RpcRequestFrame {
            id: "req-patch-subagent-clear-depth".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "spawnDepth": null
            }),
        };
        let out = dispatcher.handle_request(&clear_spawn_depth).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_status_returns_not_found_for_unknown_session() {
        let dispatcher = RpcDispatcher::new();
        let req = RpcRequestFrame {
            id: "req-1".to_owned(),
            method: "session.status".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:missing"
            }),
        };
        let out = dispatcher.handle_request(&req).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 404, .. }));
    }

    #[tokio::test]
    async fn dispatcher_send_and_history_roundtrip() {
        let dispatcher = RpcDispatcher::new();
        let send = RpcRequestFrame {
            id: "req-send".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g2",
                "message": "hello from rpc",
                "requestId": "out-1",
                "channel": "discord"
            }),
        };
        let out = dispatcher.handle_request(&send).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/accepted")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/recorded/kind")
                        .and_then(serde_json::Value::as_str),
                    Some("send")
                );
            }
            _ => panic!("expected handled send"),
        }

        let history = RpcRequestFrame {
            id: "req-history".to_owned(),
            method: "sessions.history".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g2",
                "limit": 5
            }),
        };
        let out = dispatcher.handle_request(&history).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/count")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/history/0/sessionKey")
                        .and_then(serde_json::Value::as_str),
                    Some("agent:main:discord:group:g2")
                );
                assert_eq!(
                    payload
                        .pointer("/history/0/text")
                        .and_then(serde_json::Value::as_str),
                    Some("hello from rpc")
                );
            }
            _ => panic!("expected handled history"),
        }
    }

    #[tokio::test]
    async fn dispatcher_session_store_path_persists_and_recovers_sessions_across_dispatchers() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-session-store-{}", now_ms()));
        fs::create_dir_all(&root).expect("create temp session root");
        let store_path = root.join("sessions").join("registry.json");
        let store_path_text = store_path.to_string_lossy().to_string();
        let session_key = "agent:main:discord:group:persisted";

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "session": {
                    "storePath": store_path_text
                }
            }),
        )
        .await;

        let send = RpcRequestFrame {
            id: "req-session-persist-send".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "message": "persisted hello",
                "source": "rpc",
                "channel": "discord"
            }),
        };
        let out = dispatcher.handle_request(&send).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let patch = RpcRequestFrame {
            id: "req-session-persist-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "label": "persisted-session"
            }),
        };
        let out = dispatcher.handle_request(&patch).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        assert!(
            store_path.exists(),
            "session store should be created on disk"
        );
        let disk_snapshot = fs::read_to_string(&store_path).expect("read session store");
        let disk_json =
            serde_json::from_str::<Value>(&disk_snapshot).expect("parse session store JSON");
        let disk_entries = disk_json
            .pointer("/entries")
            .and_then(Value::as_array)
            .cloned()
            .unwrap_or_default();
        assert!(disk_entries.iter().any(|entry| {
            entry
                .pointer("/key")
                .and_then(Value::as_str)
                .map(|value| value == session_key)
                .unwrap_or(false)
        }));

        let restarted = RpcDispatcher::new();
        patch_config(
            &restarted,
            json!({
                "session": {
                    "storePath": store_path.to_string_lossy().to_string()
                }
            }),
        )
        .await;

        let resolve = RpcRequestFrame {
            id: "req-session-persist-resolve".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "label": "persisted-session"
            }),
        };
        match restarted.handle_request(&resolve).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/key").and_then(Value::as_str),
                    Some(session_key)
                );
            }
            _ => panic!("expected sessions.resolve handled"),
        }

        let history = RpcRequestFrame {
            id: "req-session-persist-history".to_owned(),
            method: "sessions.history".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "limit": 1
            }),
        };
        match restarted.handle_request(&history).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/count").and_then(Value::as_u64), Some(1));
                assert_eq!(
                    payload.pointer("/history/0/text").and_then(Value::as_str),
                    Some("persisted hello")
                );
            }
            _ => panic!("expected sessions.history handled"),
        }

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_send_method_follows_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        let missing_text_or_media = RpcRequestFrame {
            id: "req-send-empty".to_owned(),
            method: "send".to_owned(),
            params: serde_json::json!({
                "to": "+15550001111",
                "message": "   ",
                "idempotencyKey": "send-empty"
            }),
        };
        let out = dispatcher.handle_request(&missing_text_or_media).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let webchat_channel = RpcRequestFrame {
            id: "req-send-webchat".to_owned(),
            method: "send".to_owned(),
            params: serde_json::json!({
                "to": "+15550001111",
                "message": "hello",
                "channel": "webchat",
                "idempotencyKey": "send-webchat"
            }),
        };
        match dispatcher.handle_request(&webchat_channel).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert!(message.contains("Use `chat.send`"));
            }
            _ => panic!("expected webchat channel rejection"),
        }

        let unsupported_channel = RpcRequestFrame {
            id: "req-send-unsupported".to_owned(),
            method: "send".to_owned(),
            params: serde_json::json!({
                "to": "+15550001111",
                "message": "hello",
                "channel": "unknown-channel",
                "idempotencyKey": "send-unsupported"
            }),
        };
        let out = dispatcher.handle_request(&unsupported_channel).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let send = RpcRequestFrame {
            id: "req-send-default".to_owned(),
            method: "send".to_owned(),
            params: serde_json::json!({
                "to": "+15550001111",
                "message": "hello outbound",
                "idempotencyKey": "send-1"
            }),
        };
        let first_message_id = match dispatcher.handle_request(&send).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/runId")
                        .and_then(serde_json::Value::as_str),
                    Some("send-1")
                );
                assert_eq!(
                    payload
                        .pointer("/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("whatsapp")
                );
                payload
                    .pointer("/messageId")
                    .and_then(serde_json::Value::as_str)
                    .map(str::to_owned)
                    .expect("message id")
            }
            _ => panic!("expected send handled response"),
        };

        match dispatcher.handle_request(&send).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/messageId")
                        .and_then(serde_json::Value::as_str),
                    Some(first_message_id.as_str())
                );
            }
            _ => panic!("expected send idempotent replay"),
        }

        let derived_session_key = super::derive_outbound_session_key("whatsapp", "+15550001111");
        let history = RpcRequestFrame {
            id: "req-send-history-derived".to_owned(),
            method: "sessions.history".to_owned(),
            params: serde_json::json!({
                "sessionKey": derived_session_key,
                "limit": 1
            }),
        };
        match dispatcher.handle_request(&history).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/count")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/history/0/text")
                        .and_then(serde_json::Value::as_str),
                    Some("hello outbound")
                );
                assert_eq!(
                    payload
                        .pointer("/history/0/source")
                        .and_then(serde_json::Value::as_str),
                    Some("send")
                );
            }
            _ => panic!("expected derived send history"),
        }

        let send_with_context = RpcRequestFrame {
            id: "req-send-with-context".to_owned(),
            method: "send".to_owned(),
            params: serde_json::json!({
                "to": "channel:C1",
                "message": "hello thread",
                "channel": "slack",
                "accountId": "work",
                "threadId": "1710000.1",
                "replyTo": "1710000.0",
                "sessionKey": "main",
                "idempotencyKey": "send-2"
            }),
        };
        match dispatcher.handle_request(&send_with_context).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("work")
                );
                assert_eq!(
                    payload
                        .pointer("/threadId")
                        .and_then(serde_json::Value::as_str),
                    Some("1710000.1")
                );
                assert_eq!(
                    payload
                        .pointer("/replyTo")
                        .and_then(serde_json::Value::as_str),
                    Some("1710000.0")
                );
                assert_eq!(
                    payload
                        .pointer("/transport/adapter")
                        .and_then(serde_json::Value::as_str),
                    Some("slack")
                );
                assert_eq!(
                    payload
                        .pointer("/transport/action")
                        .and_then(serde_json::Value::as_str),
                    Some("send")
                );
                assert_eq!(
                    payload
                        .pointer("/transport/replyTo")
                        .and_then(serde_json::Value::as_str),
                    Some("1710000.0")
                );
            }
            _ => panic!("expected send with context handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_send_store_path_persists_and_recovers_idempotency_across_dispatchers() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-send-store-{}", now_ms()));
        fs::create_dir_all(&root).expect("create temp send root");
        let store_path = root.join("idempotency").join("send-cache.json");
        let store_path_text = store_path.to_string_lossy().to_string();

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "idempotency": {
                    "sendStorePath": store_path_text,
                    "ttlSecs": 600,
                    "maxEntries": 1024
                }
            }),
        )
        .await;

        let send = RpcRequestFrame {
            id: "req-send-persist".to_owned(),
            method: "send".to_owned(),
            params: serde_json::json!({
                "to": "+15550003333",
                "message": "persist this send result",
                "idempotencyKey": "send-persist-1"
            }),
        };
        let first_message_id = match dispatcher.handle_request(&send).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/messageId")
                .and_then(serde_json::Value::as_str)
                .map(str::to_owned)
                .expect("message id"),
            _ => panic!("expected send handled response"),
        };

        assert!(store_path.exists(), "send idempotency store should exist");
        let disk_snapshot = fs::read_to_string(&store_path).expect("read send cache store");
        let disk_json = serde_json::from_str::<Value>(&disk_snapshot).expect("parse send cache");
        let disk_entries = disk_json
            .pointer("/entries")
            .and_then(Value::as_array)
            .cloned()
            .unwrap_or_default();
        assert!(disk_entries.iter().any(|entry| {
            entry
                .pointer("/idempotencyKey")
                .and_then(Value::as_str)
                .map(|value| value == "send-persist-1")
                .unwrap_or(false)
        }));

        let restarted = RpcDispatcher::new();
        patch_config(
            &restarted,
            json!({
                "idempotency": {
                    "sendStorePath": store_path.to_string_lossy().to_string()
                }
            }),
        )
        .await;

        match restarted.handle_request(&send).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/messageId").and_then(Value::as_str),
                    Some(first_message_id.as_str())
                );
            }
            _ => panic!("expected persisted send replay"),
        }

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_channel_runtime_store_path_persists_and_recovers_across_dispatchers() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-channel-runtime-{}", now_ms()));
        fs::create_dir_all(&root).expect("create temp channel runtime root");
        let store_path = root.join("channels").join("runtime.json");
        let store_path_text = store_path.to_string_lossy().to_string();

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "channels": {
                    "runtimeStorePath": store_path_text
                }
            }),
        )
        .await;

        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "event": "telegram.connected",
                "payload": {
                    "channel": "telegram",
                    "accountId": "acct-1"
                }
            }))
            .await;

        let sessions_send = RpcRequestFrame {
            id: "req-channel-runtime-store-send".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "runtime outbound persisted",
                "channel": "telegram",
                "to": "chat:12345",
                "accountId": "acct-1",
                "source": "parity-test"
            }),
        };
        match dispatcher.handle_request(&sessions_send).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/accepted").and_then(Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected sessions.send handled"),
        }

        assert!(
            store_path.exists(),
            "channel runtime store should be created on disk"
        );
        let disk_snapshot = fs::read_to_string(&store_path).expect("read channel runtime store");
        assert!(
            disk_snapshot.contains("telegram"),
            "channel runtime store should include channel id"
        );
        assert!(
            disk_snapshot.contains("acct-1"),
            "channel runtime store should include account id"
        );

        let restarted = RpcDispatcher::new();
        patch_config(
            &restarted,
            json!({
                "runtime": {
                    "channelRuntimeStorePath": store_path.to_string_lossy().to_string()
                }
            }),
        )
        .await;

        let status = RpcRequestFrame {
            id: "req-channel-runtime-store-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({}),
        };
        match restarted.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/accountId")
                        .and_then(Value::as_str),
                    Some("acct-1")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/connected")
                        .and_then(Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/running")
                        .and_then(Value::as_bool),
                    Some(true)
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastOutboundAt")
                        .and_then(Value::as_u64)
                        .is_some(),
                    "expected outbound activity recovered from runtime store"
                );
            }
            _ => panic!("expected channels.status handled"),
        }

        let logout = RpcRequestFrame {
            id: "req-channel-runtime-store-logout".to_owned(),
            method: "channels.logout".to_owned(),
            params: serde_json::json!({
                "channel": "telegram",
                "accountId": "acct-1"
            }),
        };
        match restarted.handle_request(&logout).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/loggedOut").and_then(Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.logout handled"),
        }

        let restarted_again = RpcDispatcher::new();
        patch_config(
            &restarted_again,
            json!({
                "channelRuntime": {
                    "storePath": store_path.to_string_lossy().to_string()
                }
            }),
        )
        .await;
        match restarted_again.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/accountId")
                        .and_then(Value::as_str),
                    Some("acct-1")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/connected")
                        .and_then(Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/running")
                        .and_then(Value::as_bool),
                    Some(false)
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastStopAt")
                        .and_then(Value::as_u64)
                        .is_some(),
                    "expected logout state recovered from runtime store"
                );
            }
            _ => panic!("expected channels.status handled"),
        }

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_sessions_send_reply_back_uses_last_delivery_context() {
        let dispatcher = RpcDispatcher::new();
        let session_key = "agent:main:telegram:group:chat-99:topic:12";

        let seeded = RpcRequestFrame {
            id: "req-session-send-seed".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "message": "seed context",
                "channel": "telegram",
                "to": "chat-99",
                "accountId": "acc-seed",
                "threadId": "12"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&seeded).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let reply_back = RpcRequestFrame {
            id: "req-session-send-reply-back".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "message": "reply back followup",
                "replyBack": true
            }),
        };
        match dispatcher.handle_request(&reply_back).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/recorded/replyBack")
                        .and_then(Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/recorded/channel").and_then(Value::as_str),
                    Some("telegram")
                );
                assert_eq!(
                    payload.pointer("/recorded/to").and_then(Value::as_str),
                    Some("chat-99")
                );
                assert_eq!(
                    payload
                        .pointer("/recorded/accountId")
                        .and_then(Value::as_str),
                    Some("acc-seed")
                );
                assert_eq!(
                    payload
                        .pointer("/recorded/threadId")
                        .and_then(Value::as_str),
                    Some("12")
                );
            }
            _ => panic!("expected reply-back sessions.send handled"),
        }

        let list = RpcRequestFrame {
            id: "req-session-send-reply-back-list".to_owned(),
            method: "sessions.list".to_owned(),
            params: serde_json::json!({
                "channel": "telegram",
                "to": "chat-99",
                "accountId": "acc-seed",
                "threadId": "12",
                "includeDerivedTitles": true,
                "includeLastMessage": true
            }),
        };
        match dispatcher.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/threadId")
                        .and_then(Value::as_str),
                    Some("12")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/lastThreadId")
                        .and_then(Value::as_str),
                    Some("12")
                );
            }
            _ => panic!("expected sessions.list handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_sessions_send_reply_back_resolves_session_from_route_selectors() {
        let dispatcher = RpcDispatcher::new();
        let session_key = "agent:main:discord:group:route-room:topic:77";

        let seeded = RpcRequestFrame {
            id: "req-session-send-route-seed".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "message": "seed route context",
                "channel": "discord",
                "to": "route-room",
                "accountId": "acc-route",
                "threadId": "77"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&seeded).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let reply_back = RpcRequestFrame {
            id: "req-session-send-route-reply-back".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "message": "route selector followup",
                "replyBack": true,
                "channel": "discord",
                "to": "route-room",
                "accountId": "acc-route",
                "threadId": "77"
            }),
        };
        match dispatcher.handle_request(&reply_back).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/recorded/replyBack")
                        .and_then(Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/session/key").and_then(Value::as_str),
                    Some(session_key)
                );
                assert_eq!(
                    payload
                        .pointer("/recorded/threadId")
                        .and_then(Value::as_str),
                    Some("77")
                );
            }
            _ => panic!("expected route-selector sessions.send handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_sessions_send_accepts_session_id_alias() {
        let dispatcher = RpcDispatcher::new();
        let session_key = "agent:main:telegram:dm:+15550001111";

        let seeded = RpcRequestFrame {
            id: "req-session-send-session-id-seed".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "message": "seed session id context",
                "channel": "telegram",
                "to": "+15550001111",
                "accountId": "acct-session-id"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&seeded).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let status = RpcRequestFrame {
            id: "req-session-send-session-id-status".to_owned(),
            method: "session.status".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key
            }),
        };
        let session_id = match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/session/sessionId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("session id"),
            _ => panic!("expected session.status handled"),
        };

        let by_session_id = RpcRequestFrame {
            id: "req-session-send-by-session-id".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionId": session_id,
                "message": "sent by session id",
                "replyBack": true
            }),
        };
        match dispatcher.handle_request(&by_session_id).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/session/key").and_then(Value::as_str),
                    Some(session_key)
                );
                assert_eq!(
                    payload
                        .pointer("/recorded/replyBack")
                        .and_then(Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/recorded/channel").and_then(Value::as_str),
                    Some("telegram")
                );
            }
            _ => panic!("expected sessions.send by sessionId handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_sessions_resolve_supports_thread_selector() {
        let dispatcher = RpcDispatcher::new();

        let send_a = RpcRequestFrame {
            id: "req-session-thread-a".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:room-x:topic:100",
                "message": "thread a",
                "channel": "discord",
                "to": "room-x",
                "accountId": "acc-room",
                "threadId": "100"
            }),
        };
        let send_b = RpcRequestFrame {
            id: "req-session-thread-b".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:room-x:topic:200",
                "message": "thread b",
                "channel": "discord",
                "to": "room-x",
                "accountId": "acc-room",
                "threadId": "200"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&send_a).await,
            RpcDispatchOutcome::Handled(_)
        ));
        assert!(matches!(
            dispatcher.handle_request(&send_b).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let resolve = RpcRequestFrame {
            id: "req-session-resolve-thread".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "channel": "discord",
                "to": "room-x",
                "accountId": "acc-room",
                "threadId": "100"
            }),
        };
        match dispatcher.handle_request(&resolve).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/key").and_then(Value::as_str),
                    Some("agent:main:discord:group:room-x:topic:100")
                );
            }
            _ => panic!("expected sessions.resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_send_store_prunes_expired_entries_before_replay() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-send-expire-{}", now_ms()));
        fs::create_dir_all(&root).expect("create temp send root");
        let store_path = root.join("idempotency").join("send-cache.json");
        if let Some(parent) = store_path.parent() {
            fs::create_dir_all(parent).expect("create send store parent");
        }
        let seeded = json!({
            "version": 1,
            "ttlMs": 100,
            "maxEntries": 128,
            "entries": [
                {
                    "idempotencyKey": "send-expired-1",
                    "payload": {
                        "runId": "send-expired-1",
                        "messageId": "old-message-id",
                        "channel": "whatsapp"
                    },
                    "createdAtMs": now_ms().saturating_sub(2_000)
                }
            ]
        });
        fs::write(
            &store_path,
            serde_json::to_string_pretty(&seeded).expect("serialize seeded send cache"),
        )
        .expect("write seeded send cache");

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "idempotency": {
                    "sendStorePath": store_path.to_string_lossy().to_string()
                }
            }),
        )
        .await;

        let send = RpcRequestFrame {
            id: "req-send-expired".to_owned(),
            method: "send".to_owned(),
            params: serde_json::json!({
                "to": "+15550004444",
                "message": "should bypass expired cache",
                "idempotencyKey": "send-expired-1"
            }),
        };
        let first_message_id = match dispatcher.handle_request(&send).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/messageId")
                .and_then(Value::as_str)
                .map(str::to_owned)
                .expect("message id"),
            _ => panic!("expected send handled response"),
        };
        assert_ne!(first_message_id, "old-message-id");

        match dispatcher.handle_request(&send).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/messageId").and_then(Value::as_str),
                    Some(first_message_id.as_str())
                );
            }
            _ => panic!("expected send replay response"),
        }

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_send_accepts_wave2_channel_aliases() {
        let dispatcher = RpcDispatcher::new();
        let cases = vec![
            ("google-chat", "googlechat"),
            ("teams", "msteams"),
            ("bb", "bluebubbles"),
            ("zl", "zalo"),
            ("zlu", "zalouser"),
        ];
        for (channel, expected) in cases {
            let req = RpcRequestFrame {
                id: format!("req-send-{channel}"),
                method: "send".to_owned(),
                params: serde_json::json!({
                    "to": "target:demo",
                    "message": "hello alias",
                    "channel": channel,
                    "idempotencyKey": format!("send-{channel}")
                }),
            };
            match dispatcher.handle_request(&req).await {
                RpcDispatchOutcome::Handled(payload) => {
                    assert_eq!(
                        payload
                            .pointer("/channel")
                            .and_then(serde_json::Value::as_str),
                        Some(expected),
                        "{channel}"
                    );
                }
                _ => panic!("expected send handled for alias channel"),
            }
        }
    }

    #[tokio::test]
    async fn dispatcher_send_accepts_wave3_channel_aliases() {
        let dispatcher = RpcDispatcher::new();
        let cases = vec![("internet-relay-chat", "irc"), ("imsg", "imessage")];
        for (channel, expected) in cases {
            let req = RpcRequestFrame {
                id: format!("req-send-{channel}"),
                method: "send".to_owned(),
                params: serde_json::json!({
                    "to": "target:demo",
                    "message": "hello alias",
                    "channel": channel,
                    "idempotencyKey": format!("send-{channel}")
                }),
            };
            match dispatcher.handle_request(&req).await {
                RpcDispatchOutcome::Handled(payload) => {
                    assert_eq!(
                        payload
                            .pointer("/channel")
                            .and_then(serde_json::Value::as_str),
                        Some(expected),
                        "{channel}"
                    );
                }
                _ => panic!("expected send handled for alias channel"),
            }
        }
    }

    #[tokio::test]
    async fn dispatcher_send_accepts_wave4_channel_aliases() {
        let dispatcher = RpcDispatcher::new();
        let cases = vec![
            ("lark", "feishu"),
            ("nc-talk", "nextcloud-talk"),
            ("urbit", "tlon"),
        ];
        for (channel, expected) in cases {
            let req = RpcRequestFrame {
                id: format!("req-send-{channel}"),
                method: "send".to_owned(),
                params: serde_json::json!({
                    "to": "target:demo",
                    "message": "hello alias",
                    "channel": channel,
                    "idempotencyKey": format!("send-{channel}")
                }),
            };
            match dispatcher.handle_request(&req).await {
                RpcDispatchOutcome::Handled(payload) => {
                    assert_eq!(
                        payload
                            .pointer("/channel")
                            .and_then(serde_json::Value::as_str),
                        Some(expected),
                        "{channel}"
                    );
                }
                _ => panic!("expected send handled for alias channel"),
            }
        }
    }

    #[tokio::test]
    async fn dispatcher_poll_method_follows_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        let invalid_options = RpcRequestFrame {
            id: "req-poll-invalid-options".to_owned(),
            method: "poll".to_owned(),
            params: serde_json::json!({
                "to": "+15550001111",
                "question": "Lunch?",
                "options": ["Pizza"],
                "idempotencyKey": "poll-invalid-options"
            }),
        };
        let out = dispatcher.handle_request(&invalid_options).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let unsupported_channel = RpcRequestFrame {
            id: "req-poll-unsupported".to_owned(),
            method: "poll".to_owned(),
            params: serde_json::json!({
                "to": "+15550001111",
                "question": "Lunch?",
                "options": ["Pizza", "Sushi"],
                "channel": "unknown-channel",
                "idempotencyKey": "poll-unsupported"
            }),
        };
        match dispatcher.handle_request(&unsupported_channel).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert!(message.contains("unsupported poll channel"));
            }
            _ => panic!("expected unsupported channel rejection"),
        }

        let no_poll_support = RpcRequestFrame {
            id: "req-poll-no-support".to_owned(),
            method: "poll".to_owned(),
            params: serde_json::json!({
                "to": "channel:C1",
                "question": "Lunch?",
                "options": ["Pizza", "Sushi"],
                "channel": "slack",
                "idempotencyKey": "poll-no-support"
            }),
        };
        match dispatcher.handle_request(&no_poll_support).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert_eq!(message, "unsupported poll channel: slack");
            }
            _ => panic!("expected poll capability rejection"),
        }

        let non_telegram_duration = RpcRequestFrame {
            id: "req-poll-non-telegram-duration".to_owned(),
            method: "poll".to_owned(),
            params: serde_json::json!({
                "to": "+15550001111",
                "question": "Lunch?",
                "options": ["Pizza", "Sushi"],
                "channel": "whatsapp",
                "durationSeconds": 3600,
                "idempotencyKey": "poll-non-telegram-duration"
            }),
        };
        match dispatcher.handle_request(&non_telegram_duration).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert!(message.contains("durationSeconds is only supported for Telegram polls"));
            }
            _ => panic!("expected telegram duration guard"),
        }

        let non_telegram_anonymous = RpcRequestFrame {
            id: "req-poll-non-telegram-anonymous".to_owned(),
            method: "poll".to_owned(),
            params: serde_json::json!({
                "to": "+15550001111",
                "question": "Lunch?",
                "options": ["Pizza", "Sushi"],
                "channel": "whatsapp",
                "isAnonymous": false,
                "idempotencyKey": "poll-non-telegram-anonymous"
            }),
        };
        match dispatcher.handle_request(&non_telegram_anonymous).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert!(message.contains("isAnonymous is only supported for Telegram polls"));
            }
            _ => panic!("expected telegram anonymity guard"),
        }

        let telegram_poll = RpcRequestFrame {
            id: "req-poll-telegram".to_owned(),
            method: "poll".to_owned(),
            params: serde_json::json!({
                "to": "@openclaw",
                "question": "Lunch?",
                "options": ["Pizza", "Sushi"],
                "channel": "telegram",
                "durationSeconds": 3600,
                "isAnonymous": false,
                "threadId": "42",
                "accountId": "team",
                "idempotencyKey": "poll-1"
            }),
        };
        let (first_message_id, first_poll_id) =
            match dispatcher.handle_request(&telegram_poll).await {
                RpcDispatchOutcome::Handled(payload) => {
                    assert_eq!(
                        payload
                            .pointer("/runId")
                            .and_then(serde_json::Value::as_str),
                        Some("poll-1")
                    );
                    assert_eq!(
                        payload
                            .pointer("/channel")
                            .and_then(serde_json::Value::as_str),
                        Some("telegram")
                    );
                    assert_eq!(
                        payload
                            .pointer("/threadId")
                            .and_then(serde_json::Value::as_str),
                        Some("42")
                    );
                    assert_eq!(
                        payload
                            .pointer("/accountId")
                            .and_then(serde_json::Value::as_str),
                        Some("team")
                    );
                    assert_eq!(
                        payload
                            .pointer("/transport/adapter")
                            .and_then(serde_json::Value::as_str),
                        Some("telegram")
                    );
                    assert_eq!(
                        payload
                            .pointer("/transport/action")
                            .and_then(serde_json::Value::as_str),
                        Some("poll")
                    );
                    assert_eq!(
                        payload
                            .pointer("/transport/threadId")
                            .and_then(serde_json::Value::as_str),
                        Some("42")
                    );
                    let message_id = payload
                        .pointer("/messageId")
                        .and_then(serde_json::Value::as_str)
                        .map(str::to_owned)
                        .expect("message id");
                    let poll_id = payload
                        .pointer("/pollId")
                        .and_then(serde_json::Value::as_str)
                        .map(str::to_owned)
                        .expect("poll id");
                    (message_id, poll_id)
                }
                _ => panic!("expected poll handled response"),
            };

        match dispatcher.handle_request(&telegram_poll).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/messageId")
                        .and_then(serde_json::Value::as_str),
                    Some(first_message_id.as_str())
                );
                assert_eq!(
                    payload
                        .pointer("/pollId")
                        .and_then(serde_json::Value::as_str),
                    Some(first_poll_id.as_str())
                );
            }
            _ => panic!("expected poll idempotent replay"),
        }

        let default_channel_poll = RpcRequestFrame {
            id: "req-poll-default-channel".to_owned(),
            method: "poll".to_owned(),
            params: serde_json::json!({
                "to": "+15550001111",
                "question": "Dinner?",
                "options": ["Burrito", "Pasta"],
                "idempotencyKey": "poll-2"
            }),
        };
        match dispatcher.handle_request(&default_channel_poll).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("whatsapp")
                );
                assert_eq!(
                    payload
                        .pointer("/transport/adapter")
                        .and_then(serde_json::Value::as_str),
                    Some("whatsapp")
                );
            }
            _ => panic!("expected default-channel poll response"),
        }
    }

    #[tokio::test]
    async fn dispatcher_rejects_sessions_send_webchat_channel() {
        let dispatcher = RpcDispatcher::new();
        let send = RpcRequestFrame {
            id: "req-send-webchat".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:main",
                "message": "hello webchat",
                "channel": "webchat"
            }),
        };
        match dispatcher.handle_request(&send).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert!(message.contains("Use `chat.send`"));
            }
            _ => panic!("expected sessions.send webchat channel rejection"),
        }
    }

    #[tokio::test]
    async fn dispatcher_history_supports_key_alias_and_session_id() {
        let dispatcher = RpcDispatcher::new();
        let session_key = "agent:main:discord:group:g-history-id";
        let send = RpcRequestFrame {
            id: "req-send-history-id".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "message": "hello from history id"
            }),
        };
        let _ = dispatcher.handle_request(&send).await;

        let status = RpcRequestFrame {
            id: "req-status-history-id".to_owned(),
            method: "session.status".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key
            }),
        };
        let session_id = match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/session/sessionId")
                .and_then(serde_json::Value::as_str)
                .map(str::to_owned)
                .expect("missing session id"),
            _ => panic!("expected status handled"),
        };

        let history_by_key = RpcRequestFrame {
            id: "req-history-by-key".to_owned(),
            method: "sessions.history".to_owned(),
            params: serde_json::json!({
                "key": "discord:group:g-history-id",
                "limit": 5
            }),
        };
        let out = dispatcher.handle_request(&history_by_key).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/history/0/sessionKey")
                        .and_then(serde_json::Value::as_str),
                    Some(session_key)
                );
            }
            _ => panic!("expected history by key handled"),
        }

        let history_by_session_id = RpcRequestFrame {
            id: "req-history-by-session-id".to_owned(),
            method: "sessions.history".to_owned(),
            params: serde_json::json!({
                "sessionId": session_id,
                "limit": 5
            }),
        };
        let out = dispatcher.handle_request(&history_by_session_id).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/history/0/sessionKey")
                        .and_then(serde_json::Value::as_str),
                    Some(session_key)
                );
            }
            _ => panic!("expected history by session id handled"),
        }

        let missing = RpcRequestFrame {
            id: "req-history-missing-session-id".to_owned(),
            method: "sessions.history".to_owned(),
            params: serde_json::json!({
                "sessionId": "sess-missing",
                "limit": 5
            }),
        };
        let out = dispatcher.handle_request(&missing).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 404, .. }));
    }

    #[tokio::test]
    async fn dispatcher_list_includes_delivery_context_fields() {
        let dispatcher = RpcDispatcher::new();
        let send = RpcRequestFrame {
            id: "req-send-delivery".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:whatsapp:dm:+15551234567",
                "message": "hello delivery context",
                "channel": "whatsapp",
                "to": "+15551234567",
                "accountId": "work"
            }),
        };
        let _ = dispatcher.handle_request(&send).await;

        let list = RpcRequestFrame {
            id: "req-list-delivery".to_owned(),
            method: "sessions.list".to_owned(),
            params: serde_json::json!({
                "limit": 10,
                "includeGlobal": false,
                "includeUnknown": true
            }),
        };
        let out = dispatcher.handle_request(&list).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/sessions/0/key")
                        .and_then(serde_json::Value::as_str),
                    Some("agent:main:whatsapp:dm:+15551234567")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/lastAccountId")
                        .and_then(serde_json::Value::as_str),
                    Some("work")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("whatsapp")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/to")
                        .and_then(serde_json::Value::as_str),
                    Some("+15551234567")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("work")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/totalTokensFresh")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert!(payload.pointer("/sessions/0/totalTokens").is_none());
            }
            _ => panic!("expected delivery context list handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_history_includes_recorded_decisions() {
        let dispatcher = RpcDispatcher::new();
        let request = ActionRequest {
            id: "req-42".to_owned(),
            source: "agent".to_owned(),
            session_id: Some("agent:main:discord:group:g3".to_owned()),
            prompt: Some("review me".to_owned()),
            command: Some("rm -rf /tmp".to_owned()),
            tool_name: Some("exec".to_owned()),
            channel: Some("discord".to_owned()),
            url: None,
            file_path: None,
            raw: serde_json::json!({}),
        };
        let decision = Decision {
            action: DecisionAction::Review,
            risk_score: 71,
            reasons: vec!["unsafe".to_owned()],
            tags: vec!["risk".to_owned()],
            source: "openclaw-agent-rs".to_owned(),
        };
        dispatcher.record_decision(&request, &decision).await;

        let history = RpcRequestFrame {
            id: "req-history".to_owned(),
            method: "sessions.history".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g3",
                "limit": 5
            }),
        };
        let out = dispatcher.handle_request(&history).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/history/0/kind")
                        .and_then(serde_json::Value::as_str),
                    Some("decision")
                );
                assert_eq!(
                    payload
                        .pointer("/history/0/action")
                        .and_then(serde_json::Value::as_str),
                    Some("review")
                );
                assert_eq!(
                    payload
                        .pointer("/history/0/riskScore")
                        .and_then(serde_json::Value::as_u64),
                    Some(71)
                );
            }
            _ => panic!("expected handled history"),
        }
    }

    #[tokio::test]
    async fn dispatcher_record_decision_populates_delivery_context_hints() {
        let dispatcher = RpcDispatcher::new();
        let session_key = "agent:ops:whatsapp:group:g-hints";
        let request = ActionRequest {
            id: "req-hints-1".to_owned(),
            source: "agent".to_owned(),
            session_id: Some(session_key.to_owned()),
            prompt: Some("route this decision".to_owned()),
            command: None,
            tool_name: Some("exec".to_owned()),
            channel: None,
            url: None,
            file_path: None,
            raw: serde_json::json!({
                "deliveryContext": {
                    "channel": "wa",
                    "to": "+15550001111",
                    "accountId": "work"
                }
            }),
        };
        let decision = Decision {
            action: DecisionAction::Allow,
            risk_score: 10,
            reasons: vec!["ok".to_owned()],
            tags: vec![],
            source: "openclaw-agent-rs".to_owned(),
        };
        dispatcher.record_decision(&request, &decision).await;

        let list = RpcRequestFrame {
            id: "req-list-hints".to_owned(),
            method: "sessions.list".to_owned(),
            params: serde_json::json!({
                "channel": "whatsapp",
                "to": "+15550001111",
                "accountId": "work",
                "limit": 5
            }),
        };
        match dispatcher.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/sessions/0/key")
                        .and_then(serde_json::Value::as_str),
                    Some(session_key)
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("whatsapp")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/to")
                        .and_then(serde_json::Value::as_str),
                    Some("+15550001111")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("work")
                );
            }
            _ => panic!("expected delivery-context hinted session list"),
        }
    }

    #[tokio::test]
    async fn dispatcher_resolves_session_from_delivery_hints() {
        let dispatcher = RpcDispatcher::new();
        let send = RpcRequestFrame {
            id: "req-send-hints".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:ops:telegram:group:g-bridge-hints",
                "message": "seed route",
                "channel": "telegram",
                "to": "peer-bridge",
                "accountId": "acct-bridge"
            }),
        };
        match dispatcher.handle_request(&send).await {
            RpcDispatchOutcome::Handled(_) => {}
            _ => panic!("expected seeded sessions.send"),
        }

        let resolved = dispatcher
            .resolve_session_for_delivery_hints(&serde_json::json!({
                "deliveryContext": {
                    "channel": "tg",
                    "to": "peer-bridge",
                    "accountId": "acct-bridge"
                }
            }))
            .await;
        assert_eq!(
            resolved.as_deref(),
            Some("agent:ops:telegram:group:g-bridge-hints")
        );
    }

    #[tokio::test]
    async fn dispatcher_rejects_sessions_send_without_payload() {
        let dispatcher = RpcDispatcher::new();
        let send = RpcRequestFrame {
            id: "req-send".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g2"
            }),
        };
        let out = dispatcher.handle_request(&send).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_resolve_finds_existing_session_key() {
        let dispatcher = RpcDispatcher::new();
        let patch = RpcRequestFrame {
            id: "req-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-resolve",
                "queueMode": "followup"
            }),
        };
        let patch_out = dispatcher.handle_request(&patch).await;
        let session_id = match patch_out {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/session/sessionId")
                .and_then(serde_json::Value::as_str)
                .map(str::to_owned)
                .expect("missing session id"),
            _ => panic!("expected patch handled"),
        };

        let resolve = RpcRequestFrame {
            id: "req-resolve".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "sessionId": session_id
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:main:discord:group:g-resolve")
                );
            }
            _ => panic!("expected resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_normalizes_alias_and_short_session_keys() {
        let dispatcher = RpcDispatcher::new();

        let patch_main = RpcRequestFrame {
            id: "req-patch-main".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": "main",
                "queueMode": "followup"
            }),
        };
        let out = dispatcher.handle_request(&patch_main).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:main:main")
                );
                assert_eq!(
                    payload
                        .pointer("/session/key")
                        .and_then(serde_json::Value::as_str),
                    Some("agent:main:main")
                );
            }
            _ => panic!("expected main patch handled"),
        }

        let patch_short = RpcRequestFrame {
            id: "req-patch-short".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": "discord:group:g-short",
                "queueMode": "followup"
            }),
        };
        let out = dispatcher.handle_request(&patch_short).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:main:discord:group:g-short")
                );
            }
            _ => panic!("expected short patch handled"),
        }

        let resolve_short = RpcRequestFrame {
            id: "req-resolve-short".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "key": "discord:group:g-short"
            }),
        };
        let out = dispatcher.handle_request(&resolve_short).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:main:discord:group:g-short")
                );
            }
            _ => panic!("expected short resolve handled"),
        }

        let status_short = RpcRequestFrame {
            id: "req-status-short".to_owned(),
            method: "session.status".to_owned(),
            params: serde_json::json!({
                "sessionKey": "discord:group:g-short"
            }),
        };
        let out = dispatcher.handle_request(&status_short).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/session/key")
                        .and_then(serde_json::Value::as_str),
                    Some("agent:main:discord:group:g-short")
                );
            }
            _ => panic!("expected short status handled"),
        }

        let delete_short = RpcRequestFrame {
            id: "req-delete-short".to_owned(),
            method: "sessions.delete".to_owned(),
            params: serde_json::json!({
                "key": "discord:group:g-short"
            }),
        };
        let out = dispatcher.handle_request(&delete_short).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:main:discord:group:g-short")
                );
                assert_eq!(
                    payload
                        .pointer("/deleted")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected short delete handled"),
        }

        let list = RpcRequestFrame {
            id: "req-list-canon".to_owned(),
            method: "sessions.list".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&list).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                let keys = payload
                    .pointer("/sessions")
                    .and_then(serde_json::Value::as_array)
                    .map(|sessions| {
                        sessions
                            .iter()
                            .filter_map(|session| {
                                session.get("key").and_then(serde_json::Value::as_str)
                            })
                            .collect::<Vec<_>>()
                    })
                    .unwrap_or_default();
                assert!(keys.iter().any(|key| *key == "agent:main:main"));
                assert!(keys.iter().all(|key| *key != "main"));
            }
            _ => panic!("expected canonical list handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_resolve_supports_label_agent_and_spawn_filters() {
        let dispatcher = RpcDispatcher::new();
        for (id, key, label, spawned_by, account_id, to) in [
            (
                "req-patch-a",
                "agent:ops:discord:subagent:resolved-a",
                "deploy",
                "main",
                "ops",
                "channel:C1",
            ),
            (
                "req-patch-b",
                "agent:ops:discord:subagent:resolved-b",
                "deploy",
                "other",
                "backup",
                "channel:C2",
            ),
        ] {
            let patch = RpcRequestFrame {
                id: id.to_owned(),
                method: "sessions.patch".to_owned(),
                params: serde_json::json!({
                    "sessionKey": key,
                    "label": label,
                    "spawnedBy": spawned_by
                }),
            };
            let _ = dispatcher.handle_request(&patch).await;

            let send = RpcRequestFrame {
                id: format!("{id}-send"),
                method: "sessions.send".to_owned(),
                params: serde_json::json!({
                    "sessionKey": key,
                    "message": format!("seed for {key}"),
                    "requestId": format!("{id}-request"),
                    "channel": "discord",
                    "accountId": account_id,
                    "to": to
                }),
            };
            let _ = dispatcher.handle_request(&send).await;
        }

        let resolve = RpcRequestFrame {
            id: "req-resolve-filtered".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "label": "deploy",
                "agentId": "ops",
                "spawnedBy": "main",
                "channel": "discord",
                "accountId": "ops",
                "to": "channel:C1",
                "includeUnknown": true,
                "includeGlobal": false
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:ops:discord:subagent:resolved-a")
                );
            }
            _ => panic!("expected filtered resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_list_route_selectors_disambiguate_shared_peer_by_account_and_channel() {
        let dispatcher = RpcDispatcher::new();
        for (id, key, channel, to, account_id) in [
            (
                "req-list-route-shared-a",
                "agent:ops:slack:group:peer-shared-a",
                "slack",
                "peer-shared",
                "acct-a",
            ),
            (
                "req-list-route-shared-b",
                "agent:sales:slack:group:peer-shared-b",
                "slack",
                "peer-shared",
                "acct-b",
            ),
            (
                "req-list-route-shared-c",
                "agent:ops:telegram:group:peer-shared-c",
                "telegram",
                "peer-shared",
                "acct-a",
            ),
        ] {
            let send = RpcRequestFrame {
                id: id.to_owned(),
                method: "sessions.send".to_owned(),
                params: serde_json::json!({
                    "sessionKey": key,
                    "message": format!("seed for {key}"),
                    "requestId": format!("{id}-request"),
                    "channel": channel,
                    "to": to,
                    "accountId": account_id
                }),
            };
            let _ = dispatcher.handle_request(&send).await;
        }

        let list = RpcRequestFrame {
            id: "req-list-route-shared-filter".to_owned(),
            method: "sessions.list".to_owned(),
            params: serde_json::json!({
                "limit": 10,
                "includeGlobal": false,
                "includeUnknown": false,
                "channel": "slack",
                "to": "peer-shared",
                "accountId": "acct-b"
            }),
        };
        let out = dispatcher.handle_request(&list).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/count")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/key")
                        .and_then(serde_json::Value::as_str),
                    Some("agent:sales:slack:group:peer-shared-b")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("slack")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/to")
                        .and_then(serde_json::Value::as_str),
                    Some("peer-shared")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("acct-b")
                );
            }
            _ => panic!("expected route-disambiguated list handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_resolve_route_selectors_disambiguate_shared_peer_by_account_and_channel() {
        let dispatcher = RpcDispatcher::new();
        for (id, key, channel, to, account_id) in [
            (
                "req-resolve-route-shared-a",
                "agent:ops:slack:group:peer-shared-a",
                "slack",
                "peer-shared",
                "acct-a",
            ),
            (
                "req-resolve-route-shared-b",
                "agent:sales:slack:group:peer-shared-b",
                "slack",
                "peer-shared",
                "acct-b",
            ),
            (
                "req-resolve-route-shared-c",
                "agent:ops:telegram:group:peer-shared-c",
                "telegram",
                "peer-shared",
                "acct-a",
            ),
        ] {
            let send = RpcRequestFrame {
                id: id.to_owned(),
                method: "sessions.send".to_owned(),
                params: serde_json::json!({
                    "sessionKey": key,
                    "message": format!("seed for {key}"),
                    "requestId": format!("{id}-request"),
                    "channel": channel,
                    "to": to,
                    "accountId": account_id
                }),
            };
            let _ = dispatcher.handle_request(&send).await;
        }

        let resolve = RpcRequestFrame {
            id: "req-resolve-route-shared-filter".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "channel": "slack",
                "to": "peer-shared",
                "accountId": "acct-b",
                "includeGlobal": false,
                "includeUnknown": false
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:sales:slack:group:peer-shared-b")
                );
            }
            _ => panic!("expected route-disambiguated resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_resolve_prefers_explicit_session_key_over_route_selectors() {
        let dispatcher = RpcDispatcher::new();
        for (id, key, channel, to, account_id) in [
            (
                "req-resolve-precedence-explicit",
                "agent:ops:discord:group:g-explicit",
                "discord",
                "peer-explicit",
                "acct-explicit",
            ),
            (
                "req-resolve-precedence-route",
                "agent:sales:slack:group:g-route",
                "slack",
                "peer-route",
                "acct-route",
            ),
        ] {
            let send = RpcRequestFrame {
                id: id.to_owned(),
                method: "sessions.send".to_owned(),
                params: serde_json::json!({
                    "sessionKey": key,
                    "message": format!("seed for {key}"),
                    "requestId": format!("{id}-request"),
                    "channel": channel,
                    "to": to,
                    "accountId": account_id
                }),
            };
            let _ = dispatcher.handle_request(&send).await;
        }

        let resolve = RpcRequestFrame {
            id: "req-resolve-precedence".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:ops:discord:group:g-explicit",
                "channel": "slack",
                "to": "peer-route",
                "accountId": "acct-route",
                "includeGlobal": false,
                "includeUnknown": false
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:ops:discord:group:g-explicit")
                );
            }
            _ => panic!("expected explicit sessionKey precedence resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_resolve_prefers_session_id_over_label_and_route_selectors() {
        let dispatcher = RpcDispatcher::new();

        let explicit_key = "agent:ops:discord:group:g-session-id-priority";
        let patch_explicit = RpcRequestFrame {
            id: "req-resolve-session-id-priority-explicit-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "sessionKey": explicit_key,
                "label": "hybrid-session-id"
            }),
        };
        let explicit_session_id = match dispatcher.handle_request(&patch_explicit).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/session/sessionId")
                .and_then(serde_json::Value::as_str)
                .map(str::to_owned)
                .expect("expected sessionId from patch result"),
            _ => panic!("expected explicit session patch handled"),
        };

        let conflicting_key = "agent:sales:slack:group:g-session-id-conflict";
        let patch_conflict = RpcRequestFrame {
            id: "req-resolve-session-id-priority-conflict-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "sessionKey": conflicting_key,
                "label": "hybrid-conflict"
            }),
        };
        let _ = dispatcher.handle_request(&patch_conflict).await;

        let send_conflict = RpcRequestFrame {
            id: "req-resolve-session-id-priority-conflict-send".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": conflicting_key,
                "message": "seed conflict route",
                "requestId": "req-resolve-session-id-priority-conflict-send",
                "channel": "slack",
                "to": "peer-hybrid",
                "accountId": "acct-hybrid"
            }),
        };
        let _ = dispatcher.handle_request(&send_conflict).await;

        let resolve = RpcRequestFrame {
            id: "req-resolve-session-id-priority".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "sessionId": explicit_session_id,
                "label": "hybrid-conflict",
                "channel": "slack",
                "to": "peer-hybrid",
                "accountId": "acct-hybrid",
                "includeGlobal": false,
                "includeUnknown": false
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some(explicit_key)
                );
            }
            _ => panic!("expected sessionId precedence resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_resolve_supports_label_plus_route_selectors() {
        let dispatcher = RpcDispatcher::new();

        let target_key = "agent:ops:telegram:group:g-label-route";
        let patch_target = RpcRequestFrame {
            id: "req-resolve-label-route-target-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "sessionKey": target_key,
                "label": "label-route-target"
            }),
        };
        let _ = dispatcher.handle_request(&patch_target).await;

        let send_target = RpcRequestFrame {
            id: "req-resolve-label-route-target-send".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": target_key,
                "message": "seed target route",
                "requestId": "req-resolve-label-route-target-send",
                "channel": "telegram",
                "to": "peer-label-route",
                "accountId": "acct-target"
            }),
        };
        let _ = dispatcher.handle_request(&send_target).await;

        let other_key = "agent:sales:telegram:group:g-label-route-other";
        let patch_other = RpcRequestFrame {
            id: "req-resolve-label-route-other-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "sessionKey": other_key,
                "label": "label-route-other"
            }),
        };
        let _ = dispatcher.handle_request(&patch_other).await;

        let send_other = RpcRequestFrame {
            id: "req-resolve-label-route-other-send".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": other_key,
                "message": "seed other route",
                "requestId": "req-resolve-label-route-other-send",
                "channel": "telegram",
                "to": "peer-label-route",
                "accountId": "acct-other"
            }),
        };
        let _ = dispatcher.handle_request(&send_other).await;

        let resolve = RpcRequestFrame {
            id: "req-resolve-label-route".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "label": "label-route-target",
                "channel": "telegram",
                "to": "peer-label-route",
                "includeGlobal": false,
                "includeUnknown": false
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some(target_key)
                );
            }
            _ => panic!("expected label+route resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_resolve_accepts_partial_route_selectors_without_account_id() {
        let dispatcher = RpcDispatcher::new();

        let target_key = "agent:ops:slack:group:g-partial-route";
        let send = RpcRequestFrame {
            id: "req-resolve-partial-route-send".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": target_key,
                "message": "seed partial route",
                "requestId": "req-resolve-partial-route-send",
                "channel": "slack",
                "to": "peer-partial",
                "accountId": "acct-partial"
            }),
        };
        let _ = dispatcher.handle_request(&send).await;

        let resolve = RpcRequestFrame {
            id: "req-resolve-partial-route".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "channel": "slack",
                "to": "peer-partial",
                "includeGlobal": false,
                "includeUnknown": false
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some(target_key)
                );
            }
            _ => panic!("expected partial-route resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_resolve_partial_route_collision_prefers_most_recent_update() {
        let dispatcher = RpcDispatcher::new();

        let older = RpcRequestFrame {
            id: "req-resolve-partial-collision-older".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:ops:slack:group:g-partial-collision-older",
                "message": "older partial route",
                "requestId": "req-resolve-partial-collision-older",
                "channel": "slack",
                "to": "peer-partial-collision",
                "accountId": "acct-older"
            }),
        };
        let _ = dispatcher.handle_request(&older).await;
        tokio::time::sleep(std::time::Duration::from_millis(5)).await;

        let newer = RpcRequestFrame {
            id: "req-resolve-partial-collision-newer".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:ops:slack:group:g-partial-collision-newer",
                "message": "newer partial route",
                "requestId": "req-resolve-partial-collision-newer",
                "channel": "slack",
                "to": "peer-partial-collision",
                "accountId": "acct-newer"
            }),
        };
        let _ = dispatcher.handle_request(&newer).await;

        let resolve = RpcRequestFrame {
            id: "req-resolve-partial-collision".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "channel": "slack",
                "to": "peer-partial-collision",
                "includeGlobal": false,
                "includeUnknown": false
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some("agent:ops:slack:group:g-partial-collision-newer")
                );
            }
            _ => panic!("expected partial collision resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_resolve_partial_route_collision_uses_key_tiebreak_when_timestamps_match() {
        let dispatcher = RpcDispatcher::new();
        let key_a = "agent:ops:slack:group:g-partial-collision-a";
        let key_b = "agent:ops:slack:group:g-partial-collision-b";

        for (id, key, account_id) in [
            (
                "req-resolve-partial-collision-key-a",
                key_a,
                "acct-partial-collision-a",
            ),
            (
                "req-resolve-partial-collision-key-b",
                key_b,
                "acct-partial-collision-b",
            ),
        ] {
            let send = RpcRequestFrame {
                id: id.to_owned(),
                method: "sessions.send".to_owned(),
                params: serde_json::json!({
                    "sessionKey": key,
                    "message": format!("seed for {key}"),
                    "requestId": id,
                    "channel": "slack",
                    "to": "peer-partial-collision-key-tie",
                    "accountId": account_id
                }),
            };
            let _ = dispatcher.handle_request(&send).await;
        }

        {
            let mut guard = dispatcher.sessions.entries.lock().await;
            let tie_timestamp = 1_762_000_000_000_u64;
            guard.get_mut(key_a).expect("missing key_a").updated_at_ms = tie_timestamp;
            guard.get_mut(key_b).expect("missing key_b").updated_at_ms = tie_timestamp;
        }

        let resolve = RpcRequestFrame {
            id: "req-resolve-partial-collision-key-tie".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "channel": "slack",
                "to": "peer-partial-collision-key-tie",
                "includeGlobal": false,
                "includeUnknown": false
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/key").and_then(serde_json::Value::as_str),
                    Some(key_a)
                );
            }
            _ => panic!("expected key tie-break resolve handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_reset_clears_session_counters() {
        let dispatcher = RpcDispatcher::new();
        let session_key = "agent:main:discord:group:g-reset";
        let request = ActionRequest {
            id: "req-reset".to_owned(),
            source: "agent".to_owned(),
            session_id: Some(session_key.to_owned()),
            prompt: Some("hello".to_owned()),
            command: None,
            tool_name: None,
            channel: Some("discord".to_owned()),
            url: None,
            file_path: None,
            raw: serde_json::json!({}),
        };
        let decision = Decision {
            action: DecisionAction::Allow,
            risk_score: 2,
            reasons: vec!["ok".to_owned()],
            tags: vec![],
            source: "openclaw-agent-rs".to_owned(),
        };
        dispatcher.record_decision(&request, &decision).await;

        let status = RpcRequestFrame {
            id: "req-status-before-reset".to_owned(),
            method: "session.status".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key
            }),
        };
        let before_reset = dispatcher.handle_request(&status).await;
        let before_session_id = match before_reset {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/session/sessionId")
                .and_then(serde_json::Value::as_str)
                .map(str::to_owned)
                .expect("missing pre-reset session id"),
            _ => panic!("expected status handled"),
        };

        let reset = RpcRequestFrame {
            id: "req-reset".to_owned(),
            method: "sessions.reset".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "reason": "new"
            }),
        };
        let out = dispatcher.handle_request(&reset).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/session/totalRequests")
                        .and_then(serde_json::Value::as_u64),
                    Some(0)
                );
                assert_eq!(
                    payload
                        .pointer("/reason")
                        .and_then(serde_json::Value::as_str),
                    Some("new")
                );
                let after_session_id = payload
                    .pointer("/session/sessionId")
                    .and_then(serde_json::Value::as_str)
                    .expect("missing post-reset session id");
                assert_ne!(after_session_id, before_session_id);
            }
            _ => panic!("expected reset handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_reset_rejects_invalid_reason() {
        let dispatcher = RpcDispatcher::new();
        let reset = RpcRequestFrame {
            id: "req-reset-invalid".to_owned(),
            method: "sessions.reset".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-reset-invalid",
                "reason": "banana"
            }),
        };
        let out = dispatcher.handle_request(&reset).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_delete_removes_session_and_blocks_main() {
        let dispatcher = RpcDispatcher::new();
        let patch = RpcRequestFrame {
            id: "req-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-delete",
            }),
        };
        let _ = dispatcher.handle_request(&patch).await;

        let delete = RpcRequestFrame {
            id: "req-delete".to_owned(),
            method: "sessions.delete".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-delete"
            }),
        };
        let out = dispatcher.handle_request(&delete).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/path").and_then(serde_json::Value::as_str),
                    Some(super::SESSION_STORE_PATH)
                );
                assert_eq!(
                    payload
                        .pointer("/deleted")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/archived/0")
                        .and_then(serde_json::Value::as_str),
                    Some("memory://session-registry/archives/agent:main:discord:group:g-delete.deleted")
                );
            }
            _ => panic!("expected delete handled"),
        }

        let deny_main = RpcRequestFrame {
            id: "req-main-delete".to_owned(),
            method: "sessions.delete".to_owned(),
            params: serde_json::json!({"sessionKey": "main"}),
        };
        let out = dispatcher.handle_request(&deny_main).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_delete_honors_delete_transcript_flag() {
        let dispatcher = RpcDispatcher::new();
        let patch = RpcRequestFrame {
            id: "req-patch-delete-flag".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-delete-flag",
            }),
        };
        let _ = dispatcher.handle_request(&patch).await;

        let delete = RpcRequestFrame {
            id: "req-delete-flag".to_owned(),
            method: "sessions.delete".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-delete-flag",
                "deleteTranscript": false
            }),
        };
        let out = dispatcher.handle_request(&delete).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/deleted")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/archived")
                        .and_then(serde_json::Value::as_array)
                        .map(Vec::len),
                    Some(0)
                );
            }
            _ => panic!("expected delete handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_preview_returns_items_for_requested_keys() {
        let dispatcher = RpcDispatcher::new();
        let send = RpcRequestFrame {
            id: "req-send-preview".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-preview",
                "message": "preview payload that is long enough",
                "requestId": "preview-1"
            }),
        };
        let _ = dispatcher.handle_request(&send).await;

        let preview = RpcRequestFrame {
            id: "req-preview".to_owned(),
            method: "sessions.preview".to_owned(),
            params: serde_json::json!({
                "keys": ["agent:main:discord:group:g-preview", "agent:main:discord:group:missing"],
                "limit": 10,
                "maxChars": 12
            }),
        };
        let out = dispatcher.handle_request(&preview).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/previews/0/status")
                        .and_then(serde_json::Value::as_str),
                    Some("ok")
                );
                let preview_text = payload
                    .pointer("/previews/0/items/0/text")
                    .and_then(serde_json::Value::as_str)
                    .unwrap_or_default();
                assert!(preview_text.starts_with("preview payload"));
                assert!(preview_text.ends_with("..."));
                assert_eq!(
                    payload
                        .pointer("/previews/1/status")
                        .and_then(serde_json::Value::as_str),
                    Some("missing")
                );
            }
            _ => panic!("expected preview handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_preview_preserves_requested_alias_key() {
        let dispatcher = RpcDispatcher::new();
        let send = RpcRequestFrame {
            id: "req-send-preview-alias".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-preview-alias",
                "message": "preview alias payload",
            }),
        };
        let _ = dispatcher.handle_request(&send).await;

        let preview = RpcRequestFrame {
            id: "req-preview-alias".to_owned(),
            method: "sessions.preview".to_owned(),
            params: serde_json::json!({
                "keys": ["discord:group:g-preview-alias"],
                "limit": 10,
                "maxChars": 32
            }),
        };
        let out = dispatcher.handle_request(&preview).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/previews/0/key")
                        .and_then(serde_json::Value::as_str),
                    Some("discord:group:g-preview-alias")
                );
                assert_eq!(
                    payload
                        .pointer("/previews/0/status")
                        .and_then(serde_json::Value::as_str),
                    Some("ok")
                );
            }
            _ => panic!("expected preview alias handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_compact_trims_history_buffer() {
        let dispatcher = RpcDispatcher::new();
        for idx in 0..5 {
            let send = RpcRequestFrame {
                id: format!("req-send-{idx}"),
                method: "sessions.send".to_owned(),
                params: serde_json::json!({
                    "sessionKey": "agent:main:discord:group:g-compact",
                    "message": format!("msg-{idx}"),
                }),
            };
            let _ = dispatcher.handle_request(&send).await;
        }

        let compact = RpcRequestFrame {
            id: "req-compact".to_owned(),
            method: "sessions.compact".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-compact",
                "maxLines": 2
            }),
        };
        let out = dispatcher.handle_request(&compact).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/path").and_then(serde_json::Value::as_str),
                    Some(super::SESSION_STORE_PATH)
                );
                assert_eq!(
                    payload
                        .pointer("/compacted")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/kept").and_then(serde_json::Value::as_u64),
                    Some(2)
                );
                assert_eq!(
                    payload
                        .pointer("/removed")
                        .and_then(serde_json::Value::as_u64),
                    Some(3)
                );
                assert_eq!(
                    payload
                        .pointer("/archived/0")
                        .and_then(serde_json::Value::as_str),
                    Some("memory://session-registry/archives/agent:main:discord:group:g-compact.compact")
                );
            }
            _ => panic!("expected compact handled"),
        }

        let history = RpcRequestFrame {
            id: "req-history-after-compact".to_owned(),
            method: "sessions.history".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-compact",
                "limit": 10
            }),
        };
        let out = dispatcher.handle_request(&history).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/count")
                        .and_then(serde_json::Value::as_u64),
                    Some(2)
                );
            }
            _ => panic!("expected history handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_compact_defaults_to_400_lines() {
        let dispatcher = RpcDispatcher::new();
        for idx in 0..120 {
            let send = RpcRequestFrame {
                id: format!("req-send-default-{idx}"),
                method: "sessions.send".to_owned(),
                params: serde_json::json!({
                    "sessionKey": "agent:main:discord:group:g-compact-default",
                    "message": format!("msg-default-{idx}"),
                }),
            };
            let _ = dispatcher.handle_request(&send).await;
        }

        let compact = RpcRequestFrame {
            id: "req-compact-default".to_owned(),
            method: "sessions.compact".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-compact-default"
            }),
        };
        let out = dispatcher.handle_request(&compact).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/compacted")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload.pointer("/kept").and_then(serde_json::Value::as_u64),
                    Some(120)
                );
                assert_eq!(
                    payload
                        .pointer("/reason")
                        .and_then(serde_json::Value::as_str),
                    Some("below limit")
                );
            }
            _ => panic!("expected compact handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_compact_rejects_zero_max_lines() {
        let dispatcher = RpcDispatcher::new();
        let compact = RpcRequestFrame {
            id: "req-compact-zero".to_owned(),
            method: "sessions.compact".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-compact-zero",
                "maxLines": 0
            }),
        };
        let out = dispatcher.handle_request(&compact).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_usage_reports_action_counters() {
        let dispatcher = RpcDispatcher::new();
        let make_request = |id: &str, action: DecisionAction| {
            let request = ActionRequest {
                id: id.to_owned(),
                source: "agent".to_owned(),
                session_id: Some("agent:main:discord:group:g-usage".to_owned()),
                prompt: Some("usage".to_owned()),
                command: None,
                tool_name: None,
                channel: Some("discord".to_owned()),
                url: None,
                file_path: None,
                raw: serde_json::json!({}),
            };
            let decision = Decision {
                action,
                risk_score: 10,
                reasons: vec![],
                tags: vec![],
                source: "openclaw-agent-rs".to_owned(),
            };
            (request, decision)
        };

        for (id, action) in [
            ("u1", DecisionAction::Allow),
            ("u2", DecisionAction::Review),
            ("u3", DecisionAction::Block),
        ] {
            let (request, decision) = make_request(id, action);
            dispatcher.record_decision(&request, &decision).await;
        }

        let usage = RpcRequestFrame {
            id: "req-usage".to_owned(),
            method: "sessions.usage".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-usage",
                "limit": 5
            }),
        };
        let out = dispatcher.handle_request(&usage).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/sessions/0/totalRequests")
                        .and_then(serde_json::Value::as_u64),
                    Some(3)
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/allowedCount")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/reviewCount")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/blockedCount")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
            }
            _ => panic!("expected usage handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_usage_honors_range_and_context_weight_flag() {
        let dispatcher = RpcDispatcher::new();
        let request = ActionRequest {
            id: "req-usage-range-1".to_owned(),
            source: "agent".to_owned(),
            session_id: Some("agent:main:discord:group:g-usage-range".to_owned()),
            prompt: Some("hello".to_owned()),
            command: None,
            tool_name: None,
            channel: Some("discord".to_owned()),
            url: None,
            file_path: None,
            raw: serde_json::json!({}),
        };
        let decision = Decision {
            action: DecisionAction::Allow,
            risk_score: 5,
            reasons: vec![],
            tags: vec![],
            source: "openclaw-agent-rs".to_owned(),
        };
        dispatcher.record_decision(&request, &decision).await;

        let today = super::format_utc_date(super::now_ms());
        let usage = RpcRequestFrame {
            id: "req-usage-range".to_owned(),
            method: "sessions.usage".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-usage-range",
                "startDate": today,
                "endDate": today,
                "includeContextWeight": true
            }),
        };
        let out = dispatcher.handle_request(&usage).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/range/startDate")
                        .and_then(serde_json::Value::as_str),
                    payload
                        .pointer("/range/endDate")
                        .and_then(serde_json::Value::as_str)
                );
                assert_eq!(
                    payload
                        .pointer("/startDate")
                        .and_then(serde_json::Value::as_str),
                    payload
                        .pointer("/endDate")
                        .and_then(serde_json::Value::as_str)
                );
                assert!(
                    payload
                        .pointer("/updatedAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert_eq!(
                    payload
                        .pointer("/totals/totalTokens")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/aggregates/messages/total")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert!(payload.pointer("/sessions/0/contextWeight").is_some());
            }
            _ => panic!("expected ranged usage handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_usage_timeseries_and_logs_from_history() {
        let dispatcher = RpcDispatcher::new();
        let session_key = "agent:main:discord:group:g-usage-detail";

        let send = RpcRequestFrame {
            id: "req-send-ud".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "message": "hello"
            }),
        };
        let _ = dispatcher.handle_request(&send).await;

        let request = ActionRequest {
            id: "req-dec-ud".to_owned(),
            source: "agent".to_owned(),
            session_id: Some(session_key.to_owned()),
            prompt: Some("do this".to_owned()),
            command: Some("git status".to_owned()),
            tool_name: Some("exec".to_owned()),
            channel: Some("discord".to_owned()),
            url: None,
            file_path: None,
            raw: serde_json::json!({}),
        };
        let decision = Decision {
            action: DecisionAction::Review,
            risk_score: 55,
            reasons: vec!["risk".to_owned()],
            tags: vec!["tag".to_owned()],
            source: "openclaw-agent-rs".to_owned(),
        };
        dispatcher.record_decision(&request, &decision).await;

        let logs = RpcRequestFrame {
            id: "req-usage-logs".to_owned(),
            method: "sessions.usage.logs".to_owned(),
            params: serde_json::json!({
                "key": session_key,
                "limit": 10
            }),
        };
        let out = dispatcher.handle_request(&logs).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/count")
                        .and_then(serde_json::Value::as_u64),
                    Some(2)
                );
                assert_eq!(
                    payload
                        .pointer("/logs/0/kind")
                        .and_then(serde_json::Value::as_str),
                    Some("decision")
                );
            }
            _ => panic!("expected usage logs handled"),
        }

        let timeseries = RpcRequestFrame {
            id: "req-usage-ts".to_owned(),
            method: "sessions.usage.timeseries".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "maxPoints": 20
            }),
        };
        let out = dispatcher.handle_request(&timeseries).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/count")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/points/0/sendEvents")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/points/0/decisionEvents")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/points/0/reviewCount")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
            }
            _ => panic!("expected usage timeseries handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_list_applies_agent_unknown_and_global_filters() {
        let dispatcher = RpcDispatcher::new();
        for session_key in [
            "agent:ops:discord:group:help",
            "custom:other:session",
            "main",
        ] {
            let patch = RpcRequestFrame {
                id: format!("req-{session_key}"),
                method: "sessions.patch".to_owned(),
                params: serde_json::json!({
                    "sessionKey": session_key
                }),
            };
            let _ = dispatcher.handle_request(&patch).await;
        }

        let filtered = RpcRequestFrame {
            id: "req-list-filtered".to_owned(),
            method: "sessions.list".to_owned(),
            params: serde_json::json!({
                "includeUnknown": false,
                "includeGlobal": false,
                "agentId": "ops",
                "search": "help",
                "limit": 20
            }),
        };
        let out = dispatcher.handle_request(&filtered).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/count")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/key")
                        .and_then(serde_json::Value::as_str),
                    Some("agent:ops:discord:group:help")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/agentId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
            }
            _ => panic!("expected filtered list handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_list_supports_label_spawn_filters_and_message_hints() {
        let dispatcher = RpcDispatcher::new();
        let key = "agent:main:discord:subagent:g-label";
        let patch = RpcRequestFrame {
            id: "req-list-label-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": key,
                "label": "Briefing",
                "spawnedBy": "agent:main:main"
            }),
        };
        let _ = dispatcher.handle_request(&patch).await;

        let send = RpcRequestFrame {
            id: "req-list-label-send".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": key,
                "message": "first operator update",
                "requestId": "req-list-label-send-1",
                "channel": "discord",
                "to": "group:briefing",
                "accountId": "ops"
            }),
        };
        let _ = dispatcher.handle_request(&send).await;

        let list = RpcRequestFrame {
            id: "req-list-label".to_owned(),
            method: "sessions.list".to_owned(),
            params: serde_json::json!({
                "label": "Briefing",
                "spawnedBy": "agent:main:main",
                "channel": "discord",
                "to": "group:briefing",
                "accountId": "ops",
                "includeDerivedTitles": true,
                "includeLastMessage": true,
                "limit": 5
            }),
        };
        let out = dispatcher.handle_request(&list).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/path").and_then(serde_json::Value::as_str),
                    Some(super::SESSION_STORE_PATH)
                );
                assert_eq!(
                    payload
                        .pointer("/defaults/modelProvider")
                        .and_then(|v| if v.is_null() { Some(()) } else { None }),
                    Some(())
                );
                assert_eq!(
                    payload
                        .pointer("/count")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/key")
                        .and_then(serde_json::Value::as_str),
                    Some(key)
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/displayName")
                        .and_then(serde_json::Value::as_str),
                    Some("Briefing")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/derivedTitle")
                        .and_then(serde_json::Value::as_str),
                    Some("first operator update")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/lastMessagePreview")
                        .and_then(serde_json::Value::as_str),
                    Some("first operator update")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("discord")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/to")
                        .and_then(serde_json::Value::as_str),
                    Some("group:briefing")
                );
                assert_eq!(
                    payload
                        .pointer("/sessions/0/deliveryContext/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
            }
            _ => panic!("expected filtered list handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_rejects_overlong_label_filters() {
        let dispatcher = RpcDispatcher::new();
        let too_long_label = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklm";

        let list = RpcRequestFrame {
            id: "req-list-long-label".to_owned(),
            method: "sessions.list".to_owned(),
            params: serde_json::json!({
                "label": too_long_label
            }),
        };
        let out = dispatcher.handle_request(&list).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let resolve = RpcRequestFrame {
            id: "req-resolve-long-label".to_owned(),
            method: "sessions.resolve".to_owned(),
            params: serde_json::json!({
                "label": too_long_label
            }),
        };
        let out = dispatcher.handle_request(&resolve).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_health_and_status_return_runtime_metadata() {
        let dispatcher = RpcDispatcher::new();
        let health = RpcRequestFrame {
            id: "req-health".to_owned(),
            method: "health".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&health).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/service")
                        .and_then(serde_json::Value::as_str),
                    Some("openclaw-agent-rs")
                );
            }
            _ => panic!("expected health handled"),
        }

        let status = RpcRequestFrame {
            id: "req-status".to_owned(),
            method: "status".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&status).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/runtime/name")
                        .and_then(serde_json::Value::as_str),
                    Some("openclaw-agent-rs")
                );
                assert!(
                    payload
                        .pointer("/rpc/count")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        >= 10
                );
            }
            _ => panic!("expected status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_usage_status_and_cost_return_totals_and_range() {
        let dispatcher = RpcDispatcher::new();
        let request = ActionRequest {
            id: "req-usage-cost-1".to_owned(),
            source: "agent".to_owned(),
            session_id: Some("agent:main:discord:group:g-usage-cost".to_owned()),
            prompt: Some("hello".to_owned()),
            command: None,
            tool_name: None,
            channel: Some("discord".to_owned()),
            url: None,
            file_path: None,
            raw: serde_json::json!({}),
        };
        let decision = Decision {
            action: DecisionAction::Block,
            risk_score: 90,
            reasons: vec![],
            tags: vec![],
            source: "openclaw-agent-rs".to_owned(),
        };
        dispatcher.record_decision(&request, &decision).await;

        let usage_status = RpcRequestFrame {
            id: "req-usage-status".to_owned(),
            method: "usage.status".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&usage_status).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/totals/blockedCount")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
            }
            _ => panic!("expected usage.status handled"),
        }

        let usage_cost = RpcRequestFrame {
            id: "req-usage-cost".to_owned(),
            method: "usage.cost".to_owned(),
            params: serde_json::json!({
                "startDate": "2026-01-01",
                "endDate": "2026-01-15"
            }),
        };
        let out = dispatcher.handle_request(&usage_cost).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/range/startDate")
                        .and_then(serde_json::Value::as_str),
                    Some("2026-01-01")
                );
                assert_eq!(
                    payload
                        .pointer("/actions/block")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
            }
            _ => panic!("expected usage.cost handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_system_methods_toggle_heartbeats_and_read_last_event() {
        let dispatcher = RpcDispatcher::new();

        let missing_enabled = RpcRequestFrame {
            id: "req-set-heartbeats-missing".to_owned(),
            method: "set-heartbeats".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&missing_enabled).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let toggle_off = RpcRequestFrame {
            id: "req-set-heartbeats-off".to_owned(),
            method: "set-heartbeats".to_owned(),
            params: serde_json::json!({ "enabled": false }),
        };
        let out = dispatcher.handle_request(&toggle_off).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/enabled")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected set-heartbeats handled"),
        }

        let last_heartbeat = RpcRequestFrame {
            id: "req-last-heartbeat-empty".to_owned(),
            method: "last-heartbeat".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&last_heartbeat).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => assert!(payload.is_null()),
            _ => panic!("expected null last-heartbeat before events"),
        }

        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "heartbeat",
                "payload": {
                    "status": "sent",
                    "to": "+123"
                }
            }))
            .await;

        let out = dispatcher.handle_request(&last_heartbeat).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("sent")
                );
                assert!(payload
                    .pointer("/ts")
                    .and_then(serde_json::Value::as_u64)
                    .is_some());
            }
            _ => panic!("expected populated last-heartbeat"),
        }
    }

    #[tokio::test]
    async fn dispatcher_system_event_requires_text_and_updates_presence() {
        let dispatcher = RpcDispatcher::new();

        let invalid = RpcRequestFrame {
            id: "req-system-event-invalid".to_owned(),
            method: "system-event".to_owned(),
            params: serde_json::json!({
                "text": "   "
            }),
        };
        let out = dispatcher.handle_request(&invalid).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let valid = RpcRequestFrame {
            id: "req-system-event-valid".to_owned(),
            method: "system-event".to_owned(),
            params: serde_json::json!({
                "text": "Node: node-a online",
                "host": "node-a",
                "mode": "daemon",
                "version": "1.2.3",
                "roles": ["operator", "operator"],
                "scopes": ["operator.read", "operator.write"],
                "tags": ["prod"],
                "lastInputSeconds": 12.7
            }),
        };
        let out = dispatcher.handle_request(&valid).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let presence = RpcRequestFrame {
            id: "req-system-presence".to_owned(),
            method: "system-presence".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&presence).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                let entries = payload.as_array().expect("presence array");
                assert_eq!(entries.len(), 1);
                assert_eq!(
                    entries[0].get("host").and_then(serde_json::Value::as_str),
                    Some("node-a")
                );
                assert_eq!(
                    entries[0]
                        .get("lastInputSeconds")
                        .and_then(serde_json::Value::as_u64),
                    Some(12)
                );
                let roles = entries[0]
                    .get("roles")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert_eq!(roles.len(), 1);
            }
            _ => panic!("expected system-presence handled"),
        }

        let alias_presence = RpcRequestFrame {
            id: "req-presence-alias".to_owned(),
            method: "presence".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&alias_presence).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));
    }

    #[tokio::test]
    async fn dispatcher_ingests_presence_events_from_gateway() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "presence",
                "payload": {
                    "presence": [
                        { "host": "node-a", "ts": 1 },
                        { "instanceId": "abc", "ts": 2 }
                    ]
                }
            }))
            .await;

        let system_presence = RpcRequestFrame {
            id: "req-system-presence-ingested".to_owned(),
            method: "system-presence".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&system_presence).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                let entries = payload.as_array().expect("presence array");
                assert_eq!(entries.len(), 2);
                assert!(entries.iter().any(|entry| entry
                    .get("host")
                    .and_then(serde_json::Value::as_str)
                    == Some("node-a")));
                assert!(entries.iter().any(|entry| {
                    entry.get("instanceId").and_then(serde_json::Value::as_str) == Some("abc")
                }));
            }
            _ => panic!("expected system-presence handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_wake_validates_mode_and_updates_heartbeat() {
        let dispatcher = RpcDispatcher::new();

        let missing_mode = RpcRequestFrame {
            id: "req-wake-missing-mode".to_owned(),
            method: "wake".to_owned(),
            params: serde_json::json!({
                "text": "ping"
            }),
        };
        let out = dispatcher.handle_request(&missing_mode).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let wake = RpcRequestFrame {
            id: "req-wake-now".to_owned(),
            method: "wake".to_owned(),
            params: serde_json::json!({
                "mode": "now",
                "text": "wake now"
            }),
        };
        let out = dispatcher.handle_request(&wake).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected wake handled"),
        }

        let last_heartbeat = RpcRequestFrame {
            id: "req-wake-last-heartbeat".to_owned(),
            method: "last-heartbeat".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&last_heartbeat).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("wake-requested")
                );
                assert_eq!(
                    payload.pointer("/mode").and_then(serde_json::Value::as_str),
                    Some("now")
                );
            }
            _ => panic!("expected last-heartbeat after wake"),
        }
    }

    #[tokio::test]
    async fn dispatcher_talk_methods_return_config_and_track_mode() {
        let dispatcher = RpcDispatcher::new();

        let config = RpcRequestFrame {
            id: "req-talk-config".to_owned(),
            method: "talk.config".to_owned(),
            params: serde_json::json!({
                "includeSecrets": false
            }),
        };
        let out = dispatcher.handle_request(&config).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/config/talk/outputFormat")
                        .and_then(serde_json::Value::as_str),
                    Some("pcm16")
                );
                assert_eq!(
                    payload
                        .pointer("/config/session/mainKey")
                        .and_then(serde_json::Value::as_str),
                    Some("main")
                );
            }
            _ => panic!("expected talk.config handled"),
        }

        let invalid_mode = RpcRequestFrame {
            id: "req-talk-mode-invalid".to_owned(),
            method: "talk.mode".to_owned(),
            params: serde_json::json!({
                "phase": "listen"
            }),
        };
        let out = dispatcher.handle_request(&invalid_mode).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let set_mode = RpcRequestFrame {
            id: "req-talk-mode-valid".to_owned(),
            method: "talk.mode".to_owned(),
            params: serde_json::json!({
                "enabled": true,
                "phase": "listen",
                "inputDevice": "mic-array-1",
                "outputDevice": "speaker-main-1"
            }),
        };
        let out = dispatcher.handle_request(&set_mode).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/enabled")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/phase")
                        .and_then(serde_json::Value::as_str),
                    Some("listen")
                );
                assert_eq!(
                    payload
                        .pointer("/inputDevice")
                        .and_then(serde_json::Value::as_str),
                    Some("mic-array-1")
                );
                assert_eq!(
                    payload
                        .pointer("/outputDevice")
                        .and_then(serde_json::Value::as_str),
                    Some("speaker-main-1")
                );
                assert!(payload
                    .pointer("/ts")
                    .and_then(serde_json::Value::as_u64)
                    .is_some());
            }
            _ => panic!("expected talk.mode handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_tts_methods_follow_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        let status = RpcRequestFrame {
            id: "req-tts-status".to_owned(),
            method: "tts.status".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/enabled")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/provider")
                        .and_then(serde_json::Value::as_str),
                    Some("edge")
                );
                assert_eq!(
                    payload
                        .pointer("/prefsPath")
                        .and_then(serde_json::Value::as_str),
                    Some(super::TTS_PREFS_PATH)
                );
            }
            _ => panic!("expected tts.status handled"),
        }

        let invalid_provider = RpcRequestFrame {
            id: "req-tts-set-provider-invalid".to_owned(),
            method: "tts.setProvider".to_owned(),
            params: serde_json::json!({
                "provider": "invalid-provider"
            }),
        };
        match dispatcher.handle_request(&invalid_provider).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert_eq!(
                    message,
                    "Invalid provider. Use openai, elevenlabs, kittentts, or edge."
                );
            }
            _ => panic!("expected invalid provider rejection"),
        }

        let set_provider = RpcRequestFrame {
            id: "req-tts-set-provider".to_owned(),
            method: "tts.setProvider".to_owned(),
            params: serde_json::json!({
                "provider": "openai"
            }),
        };
        match dispatcher.handle_request(&set_provider).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/provider")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
            }
            _ => panic!("expected tts.setProvider handled"),
        }

        let enable = RpcRequestFrame {
            id: "req-tts-enable".to_owned(),
            method: "tts.enable".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&enable).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/enabled")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected tts.enable handled"),
        }

        let convert_missing = RpcRequestFrame {
            id: "req-tts-convert-missing".to_owned(),
            method: "tts.convert".to_owned(),
            params: serde_json::json!({
                "text": "   "
            }),
        };
        match dispatcher.handle_request(&convert_missing).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert_eq!(message, "tts.convert requires text");
            }
            _ => panic!("expected missing text rejection"),
        }

        let convert = RpcRequestFrame {
            id: "req-tts-convert".to_owned(),
            method: "tts.convert".to_owned(),
            params: serde_json::json!({
                "text": "hello voice",
                "channel": "telegram",
                "outputDevice": "speaker-main-1"
            }),
        };
        match dispatcher.handle_request(&convert).await {
            RpcDispatchOutcome::Handled(payload) => {
                let audio_path = payload
                    .pointer("/audioPath")
                    .and_then(serde_json::Value::as_str)
                    .unwrap_or_default();
                assert!(audio_path.starts_with("memory://tts/audio-"));
                assert!(audio_path.ends_with(".opus"));
                assert_eq!(
                    payload
                        .pointer("/provider")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
                assert_eq!(
                    payload
                        .pointer("/providerUsed")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
                assert!(payload
                    .pointer("/synthSource")
                    .and_then(serde_json::Value::as_str)
                    .is_some_and(|value| value == "simulated" || value == "remote"));
                assert_eq!(
                    payload
                        .pointer("/outputFormat")
                        .and_then(serde_json::Value::as_str),
                    Some("opus")
                );
                assert_eq!(
                    payload
                        .pointer("/voiceCompatible")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert!(payload
                    .pointer("/audioBytes")
                    .and_then(serde_json::Value::as_u64)
                    .is_some_and(|value| value > 0));
                assert!(payload
                    .pointer("/audioBase64")
                    .and_then(serde_json::Value::as_str)
                    .is_some_and(|value| !value.trim().is_empty()));
                assert!(payload
                    .pointer("/durationMs")
                    .and_then(serde_json::Value::as_u64)
                    .is_some_and(|value| value >= 400));
                assert_eq!(
                    payload
                        .pointer("/sampleRateHz")
                        .and_then(serde_json::Value::as_u64),
                    Some(24_000)
                );
                assert_eq!(
                    payload
                        .pointer("/playback/outputDevice")
                        .and_then(serde_json::Value::as_str),
                    Some("speaker-main-1")
                );
            }
            _ => panic!("expected tts.convert handled"),
        }

        let providers = RpcRequestFrame {
            id: "req-tts-providers".to_owned(),
            method: "tts.providers".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&providers).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/active")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
                let providers = payload
                    .pointer("/providers")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(providers.iter().any(|entry| {
                    entry.pointer("/id").and_then(serde_json::Value::as_str) == Some("openai")
                }));
                assert!(providers.iter().any(|entry| {
                    entry.pointer("/id").and_then(serde_json::Value::as_str) == Some("kittentts")
                }));
                assert!(providers.iter().any(|entry| {
                    entry.pointer("/id").and_then(serde_json::Value::as_str) == Some("edge")
                        && entry
                            .pointer("/configured")
                            .and_then(serde_json::Value::as_bool)
                            == Some(true)
                }));
            }
            _ => panic!("expected tts.providers handled"),
        }

        let set_kittentts = RpcRequestFrame {
            id: "req-tts-set-provider-kittentts".to_owned(),
            method: "tts.setProvider".to_owned(),
            params: serde_json::json!({
                "provider": "kittentts"
            }),
        };
        match dispatcher.handle_request(&set_kittentts).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/provider")
                        .and_then(serde_json::Value::as_str),
                    Some("kittentts")
                );
            }
            _ => panic!("expected kittentts provider set"),
        }

        let convert_kittentts = RpcRequestFrame {
            id: "req-tts-convert-kittentts".to_owned(),
            method: "tts.convert".to_owned(),
            params: serde_json::json!({
                "text": "offline voice check"
            }),
        };
        match dispatcher.handle_request(&convert_kittentts).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/provider")
                        .and_then(serde_json::Value::as_str),
                    Some("kittentts")
                );
                assert_eq!(
                    payload
                        .pointer("/providerUsed")
                        .and_then(serde_json::Value::as_str),
                    Some("kittentts")
                );
                assert!(payload
                    .pointer("/audioBytes")
                    .and_then(serde_json::Value::as_u64)
                    .is_some_and(|value| value > 0));
            }
            _ => panic!("expected kittentts convert handled"),
        }

        let disable = RpcRequestFrame {
            id: "req-tts-disable".to_owned(),
            method: "tts.disable".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&disable).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/enabled")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected tts.disable handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_tts_status_runtime_profile_controls_offline_defaults() {
        let dispatcher = RpcDispatcher::new();

        patch_config(&dispatcher, json!({ "runtime": { "profile": "core" } })).await;
        let status_core = RpcRequestFrame {
            id: "req-tts-status-core-profile".to_owned(),
            method: "tts.status".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&status_core).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/runtimeProfile").and_then(Value::as_str),
                    Some("core")
                );
                assert_eq!(
                    payload
                        .pointer("/offlineVoice/kittenttsDefaultEnabled")
                        .and_then(Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/offlineVoice/recommendedProvider")
                        .and_then(Value::as_str),
                    Some("edge")
                );
                assert!(payload
                    .pointer("/fallbackProviders")
                    .and_then(Value::as_array)
                    .is_some_and(|items| !items
                        .iter()
                        .any(|entry| entry.as_str() == Some("kittentts"))));
            }
            _ => panic!("expected tts.status handled for core profile"),
        }

        patch_config(&dispatcher, json!({ "runtime": { "profile": "edge" } })).await;
        let status_edge = RpcRequestFrame {
            id: "req-tts-status-edge-profile".to_owned(),
            method: "tts.status".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&status_edge).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/runtimeProfile").and_then(Value::as_str),
                    Some("edge")
                );
                assert_eq!(
                    payload
                        .pointer("/offlineVoice/kittenttsDefaultEnabled")
                        .and_then(Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/offlineVoice/recommendedProvider")
                        .and_then(Value::as_str),
                    Some("kittentts")
                );
                assert!(payload
                    .pointer("/fallbackProviders")
                    .and_then(Value::as_array)
                    .is_some_and(|items| items
                        .iter()
                        .any(|entry| entry.as_str() == Some("kittentts"))));
            }
            _ => panic!("expected tts.status handled for edge profile"),
        }
    }

    #[tokio::test]
    async fn dispatcher_voicewake_methods_follow_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        let get = RpcRequestFrame {
            id: "req-voicewake-get-default".to_owned(),
            method: "voicewake.get".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&get).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/triggers").cloned(),
                    Some(serde_json::json!(["openclaw", "claude", "computer"]))
                );
            }
            _ => panic!("expected voicewake.get handled"),
        }

        let set_missing = RpcRequestFrame {
            id: "req-voicewake-set-missing".to_owned(),
            method: "voicewake.set".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&set_missing).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert_eq!(message, "voicewake.set requires triggers: string[]");
            }
            _ => panic!("expected missing triggers rejection"),
        }

        let set_non_array = RpcRequestFrame {
            id: "req-voicewake-set-non-array".to_owned(),
            method: "voicewake.set".to_owned(),
            params: serde_json::json!({
                "triggers": "openclaw"
            }),
        };
        match dispatcher.handle_request(&set_non_array).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert_eq!(message, "voicewake.set requires triggers: string[]");
            }
            _ => panic!("expected non-array triggers rejection"),
        }

        let set = RpcRequestFrame {
            id: "req-voicewake-set".to_owned(),
            method: "voicewake.set".to_owned(),
            params: serde_json::json!({
                "triggers": ["  hello  ", "", "world", 42]
            }),
        };
        match dispatcher.handle_request(&set).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/triggers").cloned(),
                    Some(serde_json::json!(["hello", "world"]))
                );
            }
            _ => panic!("expected voicewake.set handled"),
        }

        let get_after = RpcRequestFrame {
            id: "req-voicewake-get-after".to_owned(),
            method: "voicewake.get".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&get_after).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/triggers").cloned(),
                    Some(serde_json::json!(["hello", "world"]))
                );
            }
            _ => panic!("expected voicewake.get after set"),
        }
    }

    #[tokio::test]
    async fn dispatcher_voice_runtime_tracks_capture_and_playback_state() {
        let dispatcher = RpcDispatcher::new();

        let talk_enable = RpcRequestFrame {
            id: "req-talk-enable-audio".to_owned(),
            method: "talk.mode".to_owned(),
            params: serde_json::json!({
                "enabled": true,
                "phase": "listen"
            }),
        };
        match dispatcher.handle_request(&talk_enable).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/capture/active").and_then(Value::as_bool),
                    Some(true)
                );
                assert!(payload
                    .pointer("/capture/sessionId")
                    .and_then(Value::as_str)
                    .is_some());
            }
            _ => panic!("expected talk.mode enable handled"),
        }

        let convert = RpcRequestFrame {
            id: "req-voice-runtime-tts-convert".to_owned(),
            method: "tts.convert".to_owned(),
            params: serde_json::json!({
                "text": "voice runtime playback check",
                "channel": "telegram",
                "outputDevice": "spk-runtime"
            }),
        };
        let (last_audio_path, duration_ms) = match dispatcher.handle_request(&convert).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/playback/active").and_then(Value::as_bool),
                    Some(true)
                );
                assert!(payload
                    .pointer("/playback/sessionId")
                    .and_then(Value::as_str)
                    .is_some());
                (
                    payload
                        .pointer("/audioPath")
                        .and_then(Value::as_str)
                        .map(ToOwned::to_owned)
                        .expect("tts.convert audioPath"),
                    payload
                        .pointer("/durationMs")
                        .and_then(Value::as_u64)
                        .expect("tts.convert durationMs"),
                )
            }
            _ => panic!("expected tts.convert handled"),
        };

        let status = RpcRequestFrame {
            id: "req-voice-runtime-tts-status".to_owned(),
            method: "tts.status".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/capture/active").and_then(Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/playback/lastAudioPath")
                        .and_then(Value::as_str),
                    Some(last_audio_path.as_str())
                );
                assert_eq!(
                    payload
                        .pointer("/playback/outputDevice")
                        .and_then(Value::as_str),
                    Some("spk-runtime")
                );
                assert_eq!(
                    payload.pointer("/playback/active").and_then(Value::as_bool),
                    Some(true)
                );
                assert!(payload
                    .pointer("/playback/sessionId")
                    .and_then(Value::as_str)
                    .is_some());
            }
            _ => panic!("expected tts.status handled"),
        }

        tokio::time::sleep(Duration::from_millis(duration_ms.saturating_add(50))).await;
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/playback/active").and_then(Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/playback/queueDepth")
                        .and_then(Value::as_u64),
                    Some(0)
                );
                assert!(payload
                    .pointer("/playback/lastCompletedAtMs")
                    .and_then(Value::as_u64)
                    .is_some());
                assert!(payload
                    .pointer("/playback/sessionId")
                    .is_some_and(Value::is_null));
            }
            _ => panic!("expected tts.status handled after playback completion"),
        }

        let talk_disable = RpcRequestFrame {
            id: "req-talk-disable-audio".to_owned(),
            method: "talk.mode".to_owned(),
            params: serde_json::json!({
                "enabled": false
            }),
        };
        match dispatcher.handle_request(&talk_disable).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/capture/active").and_then(Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected talk.mode disable handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_voice_runtime_queues_playback_sessions_fifo() {
        let dispatcher = RpcDispatcher::new();

        let first = RpcRequestFrame {
            id: "req-voice-queue-first".to_owned(),
            method: "tts.convert".to_owned(),
            params: serde_json::json!({
                "text": "first",
                "channel": "telegram",
                "outputDevice": "spk-a"
            }),
        };
        let (first_audio, first_duration_ms) = match dispatcher.handle_request(&first).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/playback/active").and_then(Value::as_bool),
                    Some(true)
                );
                (
                    payload
                        .pointer("/audioPath")
                        .and_then(Value::as_str)
                        .map(ToOwned::to_owned)
                        .expect("first audio path"),
                    payload
                        .pointer("/durationMs")
                        .and_then(Value::as_u64)
                        .expect("first duration"),
                )
            }
            _ => panic!("expected first tts.convert handled"),
        };

        let second = RpcRequestFrame {
            id: "req-voice-queue-second".to_owned(),
            method: "tts.convert".to_owned(),
            params: serde_json::json!({
                "text": "second",
                "channel": "telegram",
                "outputDevice": "spk-b"
            }),
        };
        let (second_audio, second_duration_ms) = match dispatcher.handle_request(&second).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/playback/active").and_then(Value::as_bool),
                    Some(true)
                );
                assert!(payload
                    .pointer("/playback/queueDepth")
                    .and_then(Value::as_u64)
                    .is_some_and(|depth| depth >= 1));
                (
                    payload
                        .pointer("/audioPath")
                        .and_then(Value::as_str)
                        .map(ToOwned::to_owned)
                        .expect("second audio path"),
                    payload
                        .pointer("/durationMs")
                        .and_then(Value::as_u64)
                        .expect("second duration"),
                )
            }
            _ => panic!("expected second tts.convert handled"),
        };

        assert_ne!(first_audio, second_audio);

        let status = RpcRequestFrame {
            id: "req-voice-queue-status".to_owned(),
            method: "tts.status".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/playback/active").and_then(Value::as_bool),
                    Some(true)
                );
                assert!(payload
                    .pointer("/playback/queueDepth")
                    .and_then(Value::as_u64)
                    .is_some_and(|depth| depth >= 1));
            }
            _ => panic!("expected tts.status handled"),
        }

        let wait_budget_ms = first_duration_ms
            .saturating_add(second_duration_ms)
            .saturating_add(2_000);
        wait_for_playback_drain(&dispatcher, wait_budget_ms).await;
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/playback/active").and_then(Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/playback/queueDepth")
                        .and_then(Value::as_u64),
                    Some(0)
                );
                assert_eq!(
                    payload
                        .pointer("/playback/lastAudioPath")
                        .and_then(Value::as_str),
                    Some(second_audio.as_str())
                );
                assert_eq!(
                    payload
                        .pointer("/playback/outputDevice")
                        .and_then(Value::as_str),
                    Some("spk-b")
                );
            }
            _ => panic!("expected tts.status handled after queue drain"),
        }
    }

    #[tokio::test]
    async fn dispatcher_voice_runtime_live_capture_stream_advances_frames_without_manual_touch() {
        let dispatcher = RpcDispatcher::new();

        let enable = RpcRequestFrame {
            id: "req-voice-live-capture-enable".to_owned(),
            method: "talk.mode".to_owned(),
            params: serde_json::json!({
                "enabled": true,
                "phase": "listen",
                "inputDevice": "mic-live"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&enable).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let first_frames = {
            let guard = dispatcher.voice_io.state.lock().await;
            guard.capture_frames
        };
        tokio::time::sleep(Duration::from_millis(140)).await;
        let second_frames = {
            let guard = dispatcher.voice_io.state.lock().await;
            assert!(guard.capture_active, "capture should still be active");
            guard.capture_frames
        };
        assert!(
            second_frames > first_frames,
            "capture frame count should advance while capture is active"
        );

        let disable = RpcRequestFrame {
            id: "req-voice-live-capture-disable".to_owned(),
            method: "talk.mode".to_owned(),
            params: serde_json::json!({
                "enabled": false
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&disable).await,
            RpcDispatchOutcome::Handled(_)
        ));
    }

    #[tokio::test]
    async fn dispatcher_voice_runtime_live_playback_worker_drains_queue_without_snapshot_calls() {
        let dispatcher = RpcDispatcher::new();

        let first = RpcRequestFrame {
            id: "req-voice-live-worker-first".to_owned(),
            method: "tts.convert".to_owned(),
            params: serde_json::json!({
                "text": "first live worker sample",
                "channel": "telegram"
            }),
        };
        let first_duration = match dispatcher.handle_request(&first).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/durationMs")
                .and_then(Value::as_u64)
                .expect("first duration"),
            _ => panic!("expected first tts.convert handled"),
        };

        let second = RpcRequestFrame {
            id: "req-voice-live-worker-second".to_owned(),
            method: "tts.convert".to_owned(),
            params: serde_json::json!({
                "text": "second live worker sample",
                "channel": "telegram"
            }),
        };
        let second_duration = match dispatcher.handle_request(&second).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/durationMs")
                .and_then(Value::as_u64)
                .expect("second duration"),
            _ => panic!("expected second tts.convert handled"),
        };

        let wait_budget_ms = first_duration
            .saturating_add(second_duration)
            .saturating_add(2_000);
        wait_for_playback_drain(&dispatcher, wait_budget_ms).await;

        let guard = dispatcher.voice_io.state.lock().await;
        assert!(
            !guard.playback_active,
            "playback should be inactive after queued items drain"
        );
        assert!(
            guard.playback_queue.is_empty(),
            "playback queue should be empty after worker drain"
        );
        assert!(
            guard.playback_last_completed_at_ms.is_some(),
            "playback completion timestamp should be populated"
        );
    }

    async fn wait_for_playback_drain(dispatcher: &RpcDispatcher, wait_budget_ms: u64) {
        let deadline = Instant::now() + Duration::from_millis(wait_budget_ms.max(250));
        loop {
            {
                let guard = dispatcher.voice_io.state.lock().await;
                if !guard.playback_active && guard.playback_queue.is_empty() {
                    return;
                }
            }
            if Instant::now() >= deadline {
                return;
            }
            tokio::time::sleep(Duration::from_millis(40)).await;
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_methods_report_status_and_validate_logout() {
        let dispatcher = RpcDispatcher::new();

        let status = RpcRequestFrame {
            id: "req-channels-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": true,
                "timeoutMs": 2500
            }),
        };
        let out = dispatcher.handle_request(&status).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                let order = payload
                    .pointer("/channelOrder")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(!order.is_empty());
                assert!(order.iter().any(|v| v.as_str() == Some("discord")));
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/discord")
                        .and_then(serde_json::Value::as_str),
                    Some("default")
                );
                assert_eq!(
                    payload
                        .pointer("/channelSystemImages/discord")
                        .and_then(serde_json::Value::as_str),
                    Some("bubble.left")
                );
                assert!(payload
                    .pointer("/channelAccounts/discord/0/probe/ok")
                    .and_then(serde_json::Value::as_bool)
                    .unwrap_or(false));
                assert!(
                    payload
                        .pointer("/channels/discord/lastProbeAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert_eq!(
                    payload
                        .pointer("/channels/discord/probe/ok")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.status handled"),
        }

        let invalid_logout = RpcRequestFrame {
            id: "req-channels-logout-invalid".to_owned(),
            method: "channels.logout".to_owned(),
            params: serde_json::json!({
                "channel": "unknown"
            }),
        };
        let out = dispatcher.handle_request(&invalid_logout).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let valid_logout = RpcRequestFrame {
            id: "req-channels-logout-valid".to_owned(),
            method: "channels.logout".to_owned(),
            params: serde_json::json!({
                "channel": "discord"
            }),
        };
        let out = dispatcher.handle_request(&valid_logout).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("discord")
                );
                assert_eq!(
                    payload
                        .pointer("/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("default")
                );
                assert_eq!(
                    payload
                        .pointer("/supported")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/loggedOut")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/envToken")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected channels.logout handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_rejects_unknown_params() {
        let dispatcher = RpcDispatcher::new();
        let status = RpcRequestFrame {
            id: "req-channels-status-unknown".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": true,
                "unexpected": true
            }),
        };
        let out = dispatcher.handle_request(&status).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_channels_status_probe_false_sets_null_channel_last_probe_at() {
        let dispatcher = RpcDispatcher::new();
        let status = RpcRequestFrame {
            id: "req-channels-status-probe-false".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(payload
                    .pointer("/channels/discord/lastProbeAt")
                    .is_some_and(|value| value.is_null()));
                assert!(payload.pointer("/channels/discord/probe").is_none());
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_logout_rejects_unknown_params() {
        let dispatcher = RpcDispatcher::new();
        let logout = RpcRequestFrame {
            id: "req-channels-logout-unknown".to_owned(),
            method: "channels.logout".to_owned(),
            params: serde_json::json!({
                "channel": "discord",
                "extra": "value"
            }),
        };
        let out = dispatcher.handle_request(&logout).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_channels_logout_accepts_channel_alias() {
        let dispatcher = RpcDispatcher::new();
        let logout = RpcRequestFrame {
            id: "req-channels-logout-alias".to_owned(),
            method: "channels.logout".to_owned(),
            params: serde_json::json!({
                "channel": "tg"
            }),
        };
        match dispatcher.handle_request(&logout).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("telegram")
                );
                assert_eq!(
                    payload
                        .pointer("/supported")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.logout handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_reflects_runtime_event_snapshots() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "telegram.status",
                "payload": {
                    "accountId": "ops",
                    "running": true,
                    "connected": true,
                    "linked": true,
                    "configured": true,
                    "enabled": true,
                    "mode": "webhook",
                    "reconnectAttempts": 3,
                    "lastError": "network"
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "telegram.message",
                "payload": {
                    "accountId": "ops"
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-runtime-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/telegram")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/mode")
                        .and_then(serde_json::Value::as_str),
                    Some("webhook")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/reconnectAttempts")
                        .and_then(serde_json::Value::as_u64),
                    Some(3)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastError")
                        .and_then(serde_json::Value::as_str),
                    Some("network")
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastInboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert_eq!(
                    payload
                        .pointer("/channels/telegram/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_logout_marks_runtime_offline() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "slack.status",
                "payload": {
                    "channel": "slack",
                    "accountId": "default",
                    "running": true,
                    "connected": true
                }
            }))
            .await;

        let logout = RpcRequestFrame {
            id: "req-channels-logout-runtime".to_owned(),
            method: "channels.logout".to_owned(),
            params: serde_json::json!({
                "channel": "slack",
                "accountId": "default"
            }),
        };
        match dispatcher.handle_request(&logout).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/supported")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/loggedOut")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/cleared")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.logout handled"),
        }

        let status = RpcRequestFrame {
            id: "req-channels-logout-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/slack/0/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/slack/0/running")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/slack/0/lastStopAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_logout_without_runtime_account_does_not_create_account() {
        let dispatcher = RpcDispatcher::new();
        let logout = RpcRequestFrame {
            id: "req-channels-logout-missing-runtime".to_owned(),
            method: "channels.logout".to_owned(),
            params: serde_json::json!({
                "channel": "telegram",
                "accountId": "ops"
            }),
        };
        match dispatcher.handle_request(&logout).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/supported")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/loggedOut")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/cleared")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected channels.logout handled"),
        }

        let status = RpcRequestFrame {
            id: "req-channels-logout-missing-runtime-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/telegram")
                        .and_then(serde_json::Value::as_str),
                    Some("default")
                );
                let telegram_accounts = payload
                    .pointer("/channelAccounts/telegram")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(!telegram_accounts.iter().any(|entry| {
                    entry
                        .pointer("/accountId")
                        .and_then(serde_json::Value::as_str)
                        .is_some_and(|value| value == "ops")
                }));
                assert!(payload
                    .pointer("/channelAccounts/telegram/0/lastStopAt")
                    .is_none());
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_channel_accounts_runtime_map() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "ops": {
                                "running": true,
                                "connected": true,
                                "mode": "webhook",
                                "reconnectAttempts": 2,
                                "lastOutboundAt": 1234,
                                "lastReactionAt": 2345,
                                "lastEditAt": 3456,
                                "lastDeleteAt": 4567,
                                "lastThreadAt": 5678
                            }
                        }
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-runtime-map-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/discord")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/mode")
                        .and_then(serde_json::Value::as_str),
                    Some("webhook")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/reconnectAttempts")
                        .and_then(serde_json::Value::as_u64),
                    Some(2)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/lastOutboundAt")
                        .and_then(serde_json::Value::as_u64),
                    Some(1234)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/lastReactionAt")
                        .and_then(serde_json::Value::as_u64),
                    Some(2345)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/lastEditAt")
                        .and_then(serde_json::Value::as_u64),
                    Some(3456)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/lastDeleteAt")
                        .and_then(serde_json::Value::as_u64),
                    Some(4567)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/lastThreadAt")
                        .and_then(serde_json::Value::as_u64),
                    Some(5678)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_tracks_payload_channel_alias_runtime() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.message",
                "payload": {
                    "channel": "wa",
                    "accountId": "ops"
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-payload-alias-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/whatsapp")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/whatsapp/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/whatsapp/0/running")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_tracks_wave3_payload_channel_alias_runtime() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.message",
                "payload": {
                    "channel": "internet-relay-chat",
                    "accountId": "relay"
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.message",
                "payload": {
                    "channel": "imsg",
                    "accountId": "phone"
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-wave3-payload-alias-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/irc")
                        .and_then(serde_json::Value::as_str),
                    Some("relay")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/irc/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("relay")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/imessage")
                        .and_then(serde_json::Value::as_str),
                    Some("phone")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/imessage/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("phone")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_tracks_wave4_payload_channel_alias_runtime() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.message",
                "payload": {
                    "channel": "lark",
                    "accountId": "enterprise"
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.message",
                "payload": {
                    "channel": "nc-talk",
                    "accountId": "selfhosted"
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.message",
                "payload": {
                    "channel": "urbit",
                    "accountId": "ship"
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-wave4-payload-alias-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/feishu")
                        .and_then(serde_json::Value::as_str),
                    Some("enterprise")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/nextcloud-talk")
                        .and_then(serde_json::Value::as_str),
                    Some("selfhosted")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/tlon")
                        .and_then(serde_json::Value::as_str),
                    Some("ship")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_honors_default_account_hints_from_runtime_payload() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "default": {
                                "running": true,
                                "connected": false,
                                "mode": "polling"
                            },
                            "ops": {
                                "running": true,
                                "connected": true,
                                "mode": "webhook"
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "discord": "ops"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-runtime-default-hint-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/discord")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channels/discord/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channels/discord/running")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                let discord_accounts = payload
                    .pointer("/channelAccounts/discord")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                let ops_account = discord_accounts
                    .iter()
                    .find(|entry| {
                        entry
                            .pointer("/accountId")
                            .and_then(serde_json::Value::as_str)
                            == Some("ops")
                    })
                    .cloned()
                    .unwrap_or(serde_json::Value::Null);
                assert_eq!(
                    ops_account
                        .pointer("/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    ops_account
                        .pointer("/mode")
                        .and_then(serde_json::Value::as_str),
                    Some("webhook")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_nested_default_account_id_from_channels_map() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channels": {
                        "discord": {
                            "defaultAccountId": "ops",
                            "accounts": {
                                "default": {
                                    "running": true,
                                    "connected": false,
                                    "mode": "polling"
                                },
                                "ops": {
                                    "running": true,
                                    "connected": true,
                                    "mode": "webhook"
                                }
                            }
                        }
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-runtime-nested-default-hint-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/discord")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channels/discord/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channels/discord/running")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/1/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("default")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_nested_snake_case_default_account_id_from_channels_map(
    ) {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channels": {
                        "signal-cli": {
                            "default_account_id": "ops",
                            "accounts": {
                                "default": {
                                    "running": true,
                                    "connected": false
                                },
                                "ops": {
                                    "running": true,
                                    "connected": true
                                }
                            }
                        }
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-runtime-nested-snake-default-hint-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/signal")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channels/signal/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channels/signal/running")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_alias_channel_ids_in_runtime_maps() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "wa": {
                            "ops": {
                                "running": true,
                                "connected": true,
                                "mode": "webhook"
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "wa": "ops"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-runtime-alias-map-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/whatsapp")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channels/whatsapp/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/whatsapp/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/whatsapp/0/mode")
                        .and_then(serde_json::Value::as_str),
                    Some("webhook")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_includes_wave2_channel_catalog_entries() {
        let dispatcher = RpcDispatcher::new();
        let status = RpcRequestFrame {
            id: "req-channels-wave2-catalog".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                let order = payload
                    .pointer("/channelOrder")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                let names = order
                    .iter()
                    .filter_map(serde_json::Value::as_str)
                    .collect::<Vec<_>>();
                for expected in [
                    "bluebubbles",
                    "googlechat",
                    "msteams",
                    "matrix",
                    "zalo",
                    "zalouser",
                ] {
                    assert!(names.contains(&expected), "{expected}");
                }
                assert_eq!(
                    payload
                        .pointer("/channelLabels/googlechat")
                        .and_then(serde_json::Value::as_str),
                    Some("Google Chat")
                );
                assert_eq!(
                    payload
                        .pointer("/channelLabels/msteams")
                        .and_then(serde_json::Value::as_str),
                    Some("Microsoft Teams")
                );
                assert_eq!(
                    payload
                        .pointer("/channelSystemImages/bluebubbles")
                        .and_then(serde_json::Value::as_str),
                    Some("bubble.left.and.text.bubble.right")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/zalouser")
                        .and_then(serde_json::Value::as_str),
                    Some("default")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_includes_wave3_channel_catalog_entries() {
        let dispatcher = RpcDispatcher::new();
        let status = RpcRequestFrame {
            id: "req-channels-wave3-catalog".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                let order = payload
                    .pointer("/channelOrder")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                let names = order
                    .iter()
                    .filter_map(serde_json::Value::as_str)
                    .collect::<Vec<_>>();
                for expected in ["irc", "imessage"] {
                    assert!(names.contains(&expected), "{expected}");
                }
                assert_eq!(
                    payload
                        .pointer("/channelLabels/irc")
                        .and_then(serde_json::Value::as_str),
                    Some("IRC")
                );
                assert_eq!(
                    payload
                        .pointer("/channelLabels/imessage")
                        .and_then(serde_json::Value::as_str),
                    Some("iMessage")
                );
                assert_eq!(
                    payload
                        .pointer("/channelSystemImages/irc")
                        .and_then(serde_json::Value::as_str),
                    Some("network")
                );
                assert_eq!(
                    payload
                        .pointer("/channelSystemImages/imessage")
                        .and_then(serde_json::Value::as_str),
                    Some("message.fill")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_includes_wave4_channel_catalog_entries() {
        let dispatcher = RpcDispatcher::new();
        let status = RpcRequestFrame {
            id: "req-channels-wave4-catalog".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                let order = payload
                    .pointer("/channelOrder")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                let names = order
                    .iter()
                    .filter_map(serde_json::Value::as_str)
                    .collect::<Vec<_>>();
                for expected in [
                    "feishu",
                    "mattermost",
                    "line",
                    "nextcloud-talk",
                    "nostr",
                    "tlon",
                ] {
                    assert!(names.contains(&expected), "{expected}");
                }
                assert_eq!(
                    payload
                        .pointer("/channelLabels/line")
                        .and_then(serde_json::Value::as_str),
                    Some("LINE")
                );
                assert_eq!(
                    payload
                        .pointer("/channelLabels/nextcloud-talk")
                        .and_then(serde_json::Value::as_str),
                    Some("Nextcloud Talk")
                );
                assert_eq!(
                    payload
                        .pointer("/channelSystemImages/mattermost")
                        .and_then(serde_json::Value::as_str),
                    Some("bubble.left.and.bubble.right")
                );
                assert_eq!(
                    payload
                        .pointer("/channelSystemImages/nostr")
                        .and_then(serde_json::Value::as_str),
                    Some("antenna.radiowaves.left.and.right")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_wave2_alias_channel_ids_in_runtime_maps() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "google-chat": {
                            "ops": {
                                "running": true,
                                "connected": true,
                                "mode": "webhook"
                            }
                        },
                        "teams": {
                            "work": {
                                "running": true,
                                "connected": true,
                                "mode": "polling"
                            }
                        },
                        "bb": {
                            "default": {
                                "running": true,
                                "connected": true
                            }
                        },
                        "zlu": {
                            "profile1": {
                                "running": true,
                                "connected": true
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "google-chat": "ops",
                        "teams": "work",
                        "bb": "default",
                        "zlu": "profile1"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-wave2-alias-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/googlechat")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/googlechat/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/msteams")
                        .and_then(serde_json::Value::as_str),
                    Some("work")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/msteams/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("work")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/bluebubbles")
                        .and_then(serde_json::Value::as_str),
                    Some("default")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/zalouser")
                        .and_then(serde_json::Value::as_str),
                    Some("profile1")
                );
                assert_eq!(
                    payload
                        .pointer("/channels/zalouser/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_wave3_alias_channel_ids_in_runtime_maps() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "internet-relay-chat": {
                            "relay": {
                                "running": true,
                                "connected": true,
                                "mode": "socket"
                            }
                        },
                        "imsg": {
                            "phone": {
                                "running": true,
                                "connected": true,
                                "mode": "bridge"
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "internet-relay-chat": "relay",
                        "imsg": "phone"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-wave3-alias-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/irc")
                        .and_then(serde_json::Value::as_str),
                    Some("relay")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/irc/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("relay")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/irc/0/mode")
                        .and_then(serde_json::Value::as_str),
                    Some("socket")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/imessage")
                        .and_then(serde_json::Value::as_str),
                    Some("phone")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/imessage/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("phone")
                );
                assert_eq!(
                    payload
                        .pointer("/channels/imessage/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_wave4_alias_channel_ids_in_runtime_maps() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "lark": {
                            "enterprise": {
                                "running": true,
                                "connected": true,
                                "mode": "webhook"
                            }
                        },
                        "nc-talk": {
                            "selfhosted": {
                                "running": true,
                                "connected": true,
                                "mode": "webhook"
                            }
                        },
                        "urbit": {
                            "ship": {
                                "running": true,
                                "connected": true,
                                "mode": "stream"
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "lark": "enterprise",
                        "nc-talk": "selfhosted",
                        "urbit": "ship"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-wave4-alias-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/feishu")
                        .and_then(serde_json::Value::as_str),
                    Some("enterprise")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/feishu/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("enterprise")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/nextcloud-talk")
                        .and_then(serde_json::Value::as_str),
                    Some("selfhosted")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/nextcloud-talk/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("selfhosted")
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/tlon")
                        .and_then(serde_json::Value::as_str),
                    Some("ship")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/tlon/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ship")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_tracks_lifecycle_event_suffixes() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "signal-cli.connected",
                "payload": {
                    "accountId": "ops"
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "signal-cli.reconnecting",
                "payload": {
                    "accountId": "ops",
                    "reason": "socket reset"
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "signal-cli.error",
                "payload": {
                    "accountId": "ops",
                    "error": "link dropped"
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "signal-cli.disconnected",
                "payload": {
                    "accountId": "ops"
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-lifecycle-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/signal")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/signal/0/lastConnectedAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/reconnectAttempts")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/lastError")
                        .and_then(serde_json::Value::as_str),
                    Some("link dropped")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/running")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/signal/0/lastStopAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_tracks_activity_event_suffixes() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "telegram.message.sent",
                "payload": {
                    "accountId": "ops"
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "telegram.message.received",
                "payload": {
                    "accountId": "ops"
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-activity-suffix-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/telegram")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastOutboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastInboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/running")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_tracks_mutation_activity_event_suffixes() {
        let dispatcher = RpcDispatcher::new();
        for event in [
            "telegram.message.reaction-added",
            "telegram.message.reaction.added",
            "telegram.message.edited",
            "telegram.message.deleted",
            "telegram.thread-reply",
            "telegram.message.thread.reply",
        ] {
            dispatcher
                .ingest_event_frame(&serde_json::json!({
                    "type": "event",
                    "event": event,
                    "payload": {
                        "accountId": "ops"
                    }
                }))
                .await;
        }

        let status = RpcRequestFrame {
            id: "req-channels-mutation-activity-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/telegram")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastReactionAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastEditAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastDeleteAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastThreadAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_tracks_activity_suffixes_with_nested_account_aliases() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.outbound",
                "payload": {
                    "channel": "wa",
                    "meta": {
                        "account_id": "sales"
                    }
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.received",
                "payload": {
                    "channel": "wa",
                    "ctx": {
                        "account": "sales"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-activity-nested-account-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/whatsapp")
                        .and_then(serde_json::Value::as_str),
                    Some("sales")
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/whatsapp/0/lastOutboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/whatsapp/0/lastInboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_tracks_nested_channel_alias_activity_events() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.message_sent",
                "payload": {
                    "context": {
                        "channel": "tg",
                        "accountId": "ops"
                    }
                }
            }))
            .await;
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.message-received",
                "payload": {
                    "meta": {
                        "provider": "teams",
                        "account_id": "desk"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-nested-channel-activity-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/telegram")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/telegram/0/lastOutboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/msteams")
                        .and_then(serde_json::Value::as_str),
                    Some("desk")
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/msteams/0/lastInboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channel_acceptance_canary_covers_wave_channels() {
        let scenarios = [
            ("telegram", "tg", "acct-telegram"),
            ("whatsapp", "wa", "acct-whatsapp"),
            ("discord", "discord", "acct-discord"),
            ("slack", "slack", "acct-slack"),
            ("signal", "signal-cli", "acct-signal"),
            ("webchat", "web-chat", "default"),
            ("bluebubbles", "bb", "acct-bluebubbles"),
            ("googlechat", "gchat", "acct-googlechat"),
            ("msteams", "teams", "acct-msteams"),
            ("matrix", "matrix", "acct-matrix"),
            ("zalo", "zl", "acct-zalo"),
            ("zalouser", "zlu", "acct-zalouser"),
            ("irc", "internet-relay-chat", "acct-irc"),
            ("imessage", "imsg", "acct-imessage"),
            ("feishu", "lark", "acct-feishu"),
            ("mattermost", "mattermost", "acct-mattermost"),
            ("line", "line", "acct-line"),
            ("nextcloud-talk", "nc-talk", "acct-nextcloud"),
            ("nostr", "nostr", "acct-nostr"),
            ("tlon", "urbit", "acct-tlon"),
        ];

        for (index, (canonical, alias, account_id)) in scenarios.iter().enumerate() {
            let dispatcher = RpcDispatcher::new();
            dispatcher
                .ingest_event_frame(&serde_json::json!({
                    "type": "event",
                    "event": format!("{alias}.connected"),
                    "payload": {
                        "accountId": account_id
                    }
                }))
                .await;

            let status_before_send = RpcRequestFrame {
                id: format!("req-channels-acceptance-status-before-send-{canonical}"),
                method: "channels.status".to_owned(),
                params: serde_json::json!({
                    "probe": false
                }),
            };
            let payload = match dispatcher.handle_request(&status_before_send).await {
                RpcDispatchOutcome::Handled(payload) => payload,
                _ => panic!("expected channels.status handled"),
            };
            assert_eq!(
                payload
                    .pointer(&format!("/channelAccounts/{canonical}/0/accountId"))
                    .and_then(serde_json::Value::as_str),
                Some(*account_id),
                "account id mismatch for channel={canonical} alias={alias}"
            );
            assert_eq!(
                payload
                    .pointer(&format!("/channels/{canonical}/connected"))
                    .and_then(serde_json::Value::as_bool),
                Some(true),
                "connected lifecycle mismatch for channel={canonical} alias={alias}"
            );
            assert_eq!(
                payload
                    .pointer(&format!("/channels/{canonical}/running"))
                    .and_then(serde_json::Value::as_bool),
                Some(true),
                "running lifecycle mismatch for channel={canonical} alias={alias}"
            );

            let send_outcome = if canonical.eq_ignore_ascii_case("webchat") {
                let send = RpcRequestFrame {
                    id: format!("req-channels-acceptance-chat-send-{canonical}"),
                    method: "chat.send".to_owned(),
                    params: serde_json::json!({
                        "sessionKey": "main",
                        "message": format!("cp4 canary {canonical}"),
                        "idempotencyKey": format!("cp4-canary-chat-{index}")
                    }),
                };
                dispatcher.handle_request(&send).await
            } else {
                let send = RpcRequestFrame {
                    id: format!("req-channels-acceptance-send-{canonical}"),
                    method: "send".to_owned(),
                    params: serde_json::json!({
                        "to": format!("peer-{canonical}"),
                        "channel": alias,
                        "accountId": account_id,
                        "message": format!("cp4 canary {canonical}"),
                        "idempotencyKey": format!("cp4-canary-send-{index}")
                    }),
                };
                dispatcher.handle_request(&send).await
            };

            match send_outcome {
                RpcDispatchOutcome::Handled(payload) => {
                    if !canonical.eq_ignore_ascii_case("webchat") {
                        assert_eq!(
                            payload
                                .pointer("/channel")
                                .and_then(serde_json::Value::as_str),
                            Some(*canonical),
                            "send canonical channel mismatch for alias={alias}"
                        );
                    }
                }
                _ => panic!("expected send/chat.send handled"),
            }

            let status_after_send = RpcRequestFrame {
                id: format!("req-channels-acceptance-status-after-send-{canonical}"),
                method: "channels.status".to_owned(),
                params: serde_json::json!({
                    "probe": false
                }),
            };
            let payload = match dispatcher.handle_request(&status_after_send).await {
                RpcDispatchOutcome::Handled(payload) => payload,
                _ => panic!("expected channels.status handled"),
            };
            assert!(
                payload
                    .pointer(&format!("/channelAccounts/{canonical}/0/lastOutboundAt"))
                    .and_then(serde_json::Value::as_u64)
                    .unwrap_or(0)
                    > 0,
                "lastOutboundAt missing for channel={canonical} alias={alias}"
            );

            let logout = RpcRequestFrame {
                id: format!("req-channels-acceptance-logout-{canonical}"),
                method: "channels.logout".to_owned(),
                params: serde_json::json!({
                    "channel": alias,
                    "accountId": account_id
                }),
            };
            match dispatcher.handle_request(&logout).await {
                RpcDispatchOutcome::Handled(payload) => {
                    assert_eq!(
                        payload
                            .pointer("/channel")
                            .and_then(serde_json::Value::as_str),
                        Some(*canonical),
                        "logout canonical channel mismatch for alias={alias}"
                    );
                    assert_eq!(
                        payload
                            .pointer("/loggedOut")
                            .and_then(serde_json::Value::as_bool),
                        Some(true),
                        "logout activity mismatch for channel={canonical}"
                    );
                }
                _ => panic!("expected channels.logout handled"),
            }

            let status_after_logout = RpcRequestFrame {
                id: format!("req-channels-acceptance-status-after-logout-{canonical}"),
                method: "channels.status".to_owned(),
                params: serde_json::json!({
                    "probe": false
                }),
            };
            let payload = match dispatcher.handle_request(&status_after_logout).await {
                RpcDispatchOutcome::Handled(payload) => payload,
                _ => panic!("expected channels.status handled"),
            };
            assert_eq!(
                payload
                    .pointer(&format!("/channels/{canonical}/connected"))
                    .and_then(serde_json::Value::as_bool),
                Some(false),
                "connected after logout mismatch for channel={canonical}"
            );
            assert_eq!(
                payload
                    .pointer(&format!("/channels/{canonical}/running"))
                    .and_then(serde_json::Value::as_bool),
                Some(false),
                "running after logout mismatch for channel={canonical}"
            );
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_snake_case_runtime_maps() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channel_accounts": {
                        "signal-cli": {
                            "ops": {
                                "running": true,
                                "connected": true
                            }
                        }
                    },
                    "channel_default_account_id": {
                        "signal-cli": "ops"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-runtime-snake-map-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/signal")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channels/signal/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_tracks_inbound_when_channel_is_only_in_payload() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.message",
                "payload": {
                    "channel": "signal",
                    "accountId": "ops"
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-payload-channel-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/signal")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/running")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert!(
                    payload
                        .pointer("/channelAccounts/signal/0/lastInboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_chat_send_updates_webchat_runtime_outbound_activity() {
        let dispatcher = RpcDispatcher::new();
        let send = RpcRequestFrame {
            id: "req-chat-runtime-send".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "webchat runtime outbound",
                "idempotencyKey": "chat-runtime-outbound"
            }),
        };
        let out = dispatcher.handle_request(&send).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let status = RpcRequestFrame {
            id: "req-chat-runtime-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(
                    payload
                        .pointer("/channelAccounts/webchat/0/lastOutboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_defaults_to_unconfigured_unlinked_without_runtime() {
        let dispatcher = RpcDispatcher::new();
        let status = RpcRequestFrame {
            id: "req-channels-defaults-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channels/telegram/configured")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/channels/telegram/linked")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/configured")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/telegram/0/linked")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_probe_false_sets_null_account_last_probe_at() {
        let dispatcher = RpcDispatcher::new();
        let status = RpcRequestFrame {
            id: "req-channels-account-probe-false".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(payload
                    .pointer("/channelAccounts/discord/0/lastProbeAt")
                    .is_some_and(|value| value.is_null()));
                assert!(payload
                    .pointer("/channelAccounts/discord/0/probe")
                    .is_none());
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_probe_true_sets_account_last_probe_at() {
        let dispatcher = RpcDispatcher::new();
        let status = RpcRequestFrame {
            id: "req-channels-account-probe-true".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": true,
                "timeoutMs": 2222
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(
                    payload
                        .pointer("/channelAccounts/discord/0/lastProbeAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/probe/ok")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/probe/timeoutMs")
                        .and_then(serde_json::Value::as_u64),
                    Some(2222)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_extended_account_metadata_fields() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "ops": {
                                "running": true,
                                "connected": true,
                                "dmPolicy": "mentions",
                                "allowFrom": ["alice", " bob "],
                                "tokenSource": "env",
                                "botTokenSource": "config",
                                "appTokenSource": "vault",
                                "baseUrl": "https://discord.example",
                                "allowUnmentionedGroups": true,
                                "cliPath": null,
                                "dbPath": "/tmp/discord.db",
                                "port": 4567
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "discord": "ops"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-runtime-metadata-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/dmPolicy")
                        .and_then(serde_json::Value::as_str),
                    Some("mentions")
                );
                assert_eq!(
                    payload.pointer("/channelAccounts/discord/0/allowFrom"),
                    Some(&serde_json::json!(["alice", "bob"]))
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/tokenSource")
                        .and_then(serde_json::Value::as_str),
                    Some("env")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/botTokenSource")
                        .and_then(serde_json::Value::as_str),
                    Some("config")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/appTokenSource")
                        .and_then(serde_json::Value::as_str),
                    Some("vault")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/baseUrl")
                        .and_then(serde_json::Value::as_str),
                    Some("https://discord.example")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/allowUnmentionedGroups")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert!(payload
                    .pointer("/channelAccounts/discord/0/cliPath")
                    .is_some_and(|value| value.is_null()));
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/dbPath")
                        .and_then(serde_json::Value::as_str),
                    Some("/tmp/discord.db")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/port")
                        .and_then(serde_json::Value::as_u64),
                    Some(4567)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_runtime_probe_audit_and_application_payloads() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "signal": {
                            "ops": {
                                "running": true,
                                "connected": true,
                                "lastProbeAt": 999,
                                "probe": {
                                    "ok": false,
                                    "source": "runtime"
                                },
                                "audit": {
                                    "status": "warn"
                                },
                                "application": {
                                    "name": "signal-cli"
                                }
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "signal": "ops"
                    }
                }
            }))
            .await;

        let status = RpcRequestFrame {
            id: "req-channels-runtime-probe-audit-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/lastProbeAt")
                        .and_then(serde_json::Value::as_u64),
                    Some(999)
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/probe/source")
                        .and_then(serde_json::Value::as_str),
                    Some("runtime")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/audit/status")
                        .and_then(serde_json::Value::as_str),
                    Some("warn")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/application/name")
                        .and_then(serde_json::Value::as_str),
                    Some("signal-cli")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_logout_matches_account_id_case_insensitively() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "slack.status",
                "payload": {
                    "channel": "slack",
                    "accountId": "ops",
                    "running": true,
                    "connected": true
                }
            }))
            .await;
        let logout = RpcRequestFrame {
            id: "req-channels-logout-case-insensitive".to_owned(),
            method: "channels.logout".to_owned(),
            params: serde_json::json!({
                "channel": "slack",
                "accountId": "OPS"
            }),
        };
        match dispatcher.handle_request(&logout).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/loggedOut")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/cleared")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.logout handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_logout_blank_account_id_defaults_default() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "telegram.status",
                "payload": {
                    "accountId": "default",
                    "running": true,
                    "connected": true
                }
            }))
            .await;
        let logout = RpcRequestFrame {
            id: "req-channels-logout-blank-account".to_owned(),
            method: "channels.logout".to_owned(),
            params: serde_json::json!({
                "channel": "telegram",
                "accountId": "   "
            }),
        };
        match dispatcher.handle_request(&logout).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("default")
                );
                assert_eq!(
                    payload
                        .pointer("/loggedOut")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected channels.logout handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_canonicalizes_default_account_id_casing() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "ops": {
                                "running": true,
                                "connected": true
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "discord": "OPS"
                    }
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-canonical-default-case".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/discord")
                        .and_then(serde_json::Value::as_str),
                    Some("ops")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_orders_default_account_first() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "zeta": {
                                "running": true,
                                "connected": true
                            },
                            "alpha": {
                                "running": true,
                                "connected": false
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "discord": "zeta"
                    }
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-default-account-order".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("zeta")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/1/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("alpha")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_runtime_account_name() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "ops": {
                                "name": "Ops Bot",
                                "running": true,
                                "connected": true
                            }
                        }
                    }
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-runtime-name".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/name")
                        .and_then(serde_json::Value::as_str),
                    Some("Ops Bot")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_runtime_display_name_alias() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "ops": {
                                "display_name": "Ops Display",
                                "running": true,
                                "connected": true
                            }
                        }
                    }
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-runtime-display-name".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/name")
                        .and_then(serde_json::Value::as_str),
                    Some("Ops Display")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_ingests_snake_case_extended_metadata_fields() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channel_accounts": {
                        "signal-cli": {
                            "ops": {
                                "running": true,
                                "connected": true,
                                "dm_policy": "allow",
                                "allow_from": ["alice", " bob "],
                                "token_source": "env",
                                "bot_token_source": "config",
                                "app_token_source": "vault",
                                "base_url": "https://signal.example",
                                "allow_unmentioned_groups": true,
                                "cli_path": null,
                                "db_path": "/tmp/signal.db",
                                "port": "7788"
                            }
                        }
                    },
                    "channel_default_account_id": {
                        "signal-cli": "ops"
                    }
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-snake-runtime-metadata".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/dmPolicy")
                        .and_then(serde_json::Value::as_str),
                    Some("allow")
                );
                assert_eq!(
                    payload.pointer("/channelAccounts/signal/0/allowFrom"),
                    Some(&serde_json::json!(["alice", "bob"]))
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/tokenSource")
                        .and_then(serde_json::Value::as_str),
                    Some("env")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/botTokenSource")
                        .and_then(serde_json::Value::as_str),
                    Some("config")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/appTokenSource")
                        .and_then(serde_json::Value::as_str),
                    Some("vault")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/baseUrl")
                        .and_then(serde_json::Value::as_str),
                    Some("https://signal.example")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/allowUnmentionedGroups")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert!(payload
                    .pointer("/channelAccounts/signal/0/cliPath")
                    .is_some_and(|value| value.is_null()));
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/dbPath")
                        .and_then(serde_json::Value::as_str),
                    Some("/tmp/signal.db")
                );
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/signal/0/port")
                        .and_then(serde_json::Value::as_u64),
                    Some(7788)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_parses_allow_from_string_list() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "ops": {
                                "running": true,
                                "connected": true,
                                "allowFrom": "alice, bob\ncarol; dave"
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "discord": "ops"
                    }
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-allow-from-string".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/channelAccounts/discord/0/allowFrom"),
                    Some(&serde_json::json!(["alice", "bob", "carol", "dave"]))
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_accepts_numeric_channel_default_account_id_map_values() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "123": {
                                "running": true,
                                "connected": true
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "discord": 123
                    }
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-numeric-default-map".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/discord")
                        .and_then(serde_json::Value::as_str),
                    Some("123")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_accepts_numeric_payload_default_account_id() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.runtime",
                "payload": {
                    "channel": "discord",
                    "accountId": "777",
                    "defaultAccountId": 777,
                    "running": true,
                    "connected": true
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-numeric-default-payload".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/discord")
                        .and_then(serde_json::Value::as_str),
                    Some("777")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_accepts_numeric_nested_default_account_id() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channels": {
                        "discord": {
                            "defaultAccountId": 42,
                            "accounts": {
                                "42": {
                                    "running": true,
                                    "connected": true
                                }
                            }
                        }
                    }
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-numeric-default-nested".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelDefaultAccountId/discord")
                        .and_then(serde_json::Value::as_str),
                    Some("42")
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_channels_status_parses_last_probe_at_from_string_number() {
        let dispatcher = RpcDispatcher::new();
        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "type": "event",
                "event": "gateway.channels.runtime",
                "payload": {
                    "channelAccounts": {
                        "discord": {
                            "ops": {
                                "running": true,
                                "connected": true,
                                "lastProbeAt": "1234"
                            }
                        }
                    },
                    "channelDefaultAccountId": {
                        "discord": "ops"
                    }
                }
            }))
            .await;
        let status = RpcRequestFrame {
            id: "req-channels-status-last-probe-string".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/channelAccounts/discord/0/lastProbeAt")
                        .and_then(serde_json::Value::as_u64),
                    Some(1234)
                );
            }
            _ => panic!("expected channels.status handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_config_methods_enforce_base_hash_and_apply_updates() {
        let dispatcher = RpcDispatcher::new();

        let get = RpcRequestFrame {
            id: "req-config-get".to_owned(),
            method: "config.get".to_owned(),
            params: serde_json::json!({}),
        };
        let initial_hash = match dispatcher.handle_request(&get).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/hash")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("hash"),
            _ => panic!("expected config.get handled"),
        };

        let set_missing_hash = RpcRequestFrame {
            id: "req-config-set-missing-hash".to_owned(),
            method: "config.set".to_owned(),
            params: serde_json::json!({
                "raw": "{\"session\":{\"mainKey\":\"main2\"}}"
            }),
        };
        let out = dispatcher.handle_request(&set_missing_hash).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let set = RpcRequestFrame {
            id: "req-config-set".to_owned(),
            method: "config.set".to_owned(),
            params: serde_json::json!({
                "baseHash": initial_hash,
                "raw": "{\"session\":{\"mainKey\":\"primary\"},\"talk\":{\"outputFormat\":\"pcm16\"}}"
            }),
        };
        let set_hash = match dispatcher.handle_request(&set).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/config/session/mainKey")
                        .and_then(serde_json::Value::as_str),
                    Some("primary")
                );
                payload
                    .pointer("/hash")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("set hash")
            }
            _ => panic!("expected config.set handled"),
        };

        let patch = RpcRequestFrame {
            id: "req-config-patch".to_owned(),
            method: "config.patch".to_owned(),
            params: serde_json::json!({
                "baseHash": set_hash,
                "raw": "{\"talk\":{\"interruptOnSpeech\":false}}"
            }),
        };
        let patch_hash = match dispatcher.handle_request(&patch).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/config/talk/interruptOnSpeech")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                payload
                    .pointer("/hash")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("patch hash")
            }
            _ => panic!("expected config.patch handled"),
        };

        let apply = RpcRequestFrame {
            id: "req-config-apply".to_owned(),
            method: "config.apply".to_owned(),
            params: serde_json::json!({
                "baseHash": patch_hash,
                "raw": "{\"ui\":{\"seamColor\":\"#111111\"}}",
                "sessionKey": "agent:main:main",
                "note": "apply-now",
                "restartDelayMs": 0
            }),
        };
        match dispatcher.handle_request(&apply).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/config/ui/seamColor")
                        .and_then(serde_json::Value::as_str),
                    Some("#111111")
                );
                assert_eq!(
                    payload
                        .pointer("/restart/requested")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/restart/sessionKey")
                        .and_then(serde_json::Value::as_str),
                    Some("agent:main:main")
                );
            }
            _ => panic!("expected config.apply handled"),
        }

        let schema = RpcRequestFrame {
            id: "req-config-schema".to_owned(),
            method: "config.schema".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&schema).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));
    }

    #[tokio::test]
    async fn dispatcher_config_store_path_persists_and_recovers_across_dispatchers() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-config-store-{}", now_ms()));
        fs::create_dir_all(&root).expect("create temp config root");
        let store_path = root.join("config").join("runtime.json");
        let store_path_text = store_path.to_string_lossy().to_string();

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "config": {
                    "storePath": store_path_text
                },
                "session": {
                    "mainKey": "persisted-main"
                },
                "ui": {
                    "seamColor": "#123456"
                }
            }),
        )
        .await;

        let get = RpcRequestFrame {
            id: "req-config-store-get".to_owned(),
            method: "config.get".to_owned(),
            params: json!({}),
        };
        match dispatcher.handle_request(&get).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/path").and_then(Value::as_str),
                    Some(store_path.to_string_lossy().as_ref())
                );
                assert_eq!(
                    payload
                        .pointer("/config/session/mainKey")
                        .and_then(Value::as_str),
                    Some("persisted-main")
                );
            }
            _ => panic!("expected config.get handled"),
        }
        assert!(store_path.exists(), "config store should be persisted");

        let disk_raw = fs::read_to_string(&store_path).expect("read config store");
        let disk_json: Value = serde_json::from_str(&disk_raw).expect("parse config store JSON");
        assert_eq!(
            disk_json
                .pointer("/config/session/mainKey")
                .and_then(Value::as_str),
            Some("persisted-main")
        );

        let restarted = RpcDispatcher::new();
        patch_config(
            &restarted,
            json!({
                "config": {
                    "storePath": store_path.to_string_lossy().to_string()
                }
            }),
        )
        .await;
        match restarted.handle_request(&get).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/config/session/mainKey")
                        .and_then(Value::as_str),
                    Some("persisted-main")
                );
                assert_eq!(
                    payload
                        .pointer("/config/ui/seamColor")
                        .and_then(Value::as_str),
                    Some("#123456")
                );
            }
            _ => panic!("expected config.get handled"),
        }

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_logs_tail_returns_bounded_lines_and_cursor() {
        let dispatcher = RpcDispatcher::new();
        let first = RpcRequestFrame {
            id: "req-system-event-log-1".to_owned(),
            method: "system-event".to_owned(),
            params: serde_json::json!({
                "text": "first event"
            }),
        };
        let second = RpcRequestFrame {
            id: "req-system-event-log-2".to_owned(),
            method: "system-event".to_owned(),
            params: serde_json::json!({
                "text": "second event"
            }),
        };
        let _ = dispatcher.handle_request(&first).await;
        let _ = dispatcher.handle_request(&second).await;

        let tail = RpcRequestFrame {
            id: "req-logs-tail".to_owned(),
            method: "logs.tail".to_owned(),
            params: serde_json::json!({
                "limit": 2,
                "maxBytes": 2048
            }),
        };
        let cursor = match dispatcher.handle_request(&tail).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/file").and_then(serde_json::Value::as_str),
                    Some(super::SYSTEM_LOG_PATH)
                );
                let lines = payload
                    .pointer("/lines")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(!lines.is_empty());
                payload
                    .pointer("/cursor")
                    .and_then(serde_json::Value::as_u64)
                    .expect("cursor")
            }
            _ => panic!("expected logs.tail handled"),
        };

        let next_event = RpcRequestFrame {
            id: "req-talk-mode-log".to_owned(),
            method: "talk.mode".to_owned(),
            params: serde_json::json!({
                "enabled": true,
                "phase": "listen"
            }),
        };
        let _ = dispatcher.handle_request(&next_event).await;

        let tail_from_cursor = RpcRequestFrame {
            id: "req-logs-tail-cursor".to_owned(),
            method: "logs.tail".to_owned(),
            params: serde_json::json!({
                "cursor": cursor,
                "limit": 5
            }),
        };
        match dispatcher.handle_request(&tail_from_cursor).await {
            RpcDispatchOutcome::Handled(payload) => {
                let lines = payload
                    .pointer("/lines")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(!lines.is_empty());
                assert!(lines.iter().any(|line| {
                    line.as_str()
                        .map(|text| text.contains("talk.mode enabled=true"))
                        .unwrap_or(false)
                }));
            }
            _ => panic!("expected logs.tail cursor handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_models_list_returns_catalog_and_rejects_unknown_params() {
        let dispatcher = RpcDispatcher::new();

        let invalid = RpcRequestFrame {
            id: "req-models-list-invalid".to_owned(),
            method: "models.list".to_owned(),
            params: serde_json::json!({
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&invalid).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let valid = RpcRequestFrame {
            id: "req-models-list".to_owned(),
            method: "models.list".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&valid).await {
            RpcDispatchOutcome::Handled(payload) => {
                let models = payload
                    .pointer("/models")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(!models.is_empty());
                assert!(models.iter().all(|entry| {
                    entry
                        .get("id")
                        .and_then(serde_json::Value::as_str)
                        .is_some()
                        && entry
                            .get("name")
                            .and_then(serde_json::Value::as_str)
                            .is_some()
                        && entry
                            .get("provider")
                            .and_then(serde_json::Value::as_str)
                            .is_some()
                }));
                let providers = models
                    .iter()
                    .filter_map(|entry| {
                        entry
                            .get("provider")
                            .and_then(serde_json::Value::as_str)
                            .map(ToOwned::to_owned)
                    })
                    .collect::<Vec<_>>();
                let mut sorted = providers.clone();
                sorted.sort();
                assert_eq!(providers, sorted);
            }
            _ => panic!("expected models.list handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_models_list_prefers_config_catalog_when_present() {
        let dispatcher = RpcDispatcher::new();

        let config_get = RpcRequestFrame {
            id: "req-models-config-get".to_owned(),
            method: "config.get".to_owned(),
            params: serde_json::json!({}),
        };
        let hash = match dispatcher.handle_request(&config_get).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/hash")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("config hash"),
            _ => panic!("expected config.get handled"),
        };

        let patch = RpcRequestFrame {
            id: "req-models-config-patch".to_owned(),
            method: "config.patch".to_owned(),
            params: serde_json::json!({
                "baseHash": hash,
                "raw": serde_json::json!({
                    "models": {
                        "catalog": [
                            {
                                "id": "ops-custom-1",
                                "name": "Ops Custom 1",
                                "provider": "zai",
                                "contextWindow": 65536,
                                "reasoning": true
                            }
                        ]
                    }
                }).to_string()
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&patch).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let list = RpcRequestFrame {
            id: "req-models-list-custom".to_owned(),
            method: "models.list".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                let models = payload
                    .pointer("/models")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert_eq!(models.len(), 1);
                assert_eq!(
                    models[0].get("id").and_then(serde_json::Value::as_str),
                    Some("ops-custom-1")
                );
                assert_eq!(
                    models[0]
                        .get("provider")
                        .and_then(serde_json::Value::as_str),
                    Some("zai")
                );
                assert!(models[0]
                    .get("fallbackProviders")
                    .and_then(serde_json::Value::as_array)
                    .is_some());
            }
            _ => panic!("expected models.list handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_agents_methods_manage_agents_and_workspace_files() {
        let dispatcher = RpcDispatcher::new();

        let invalid_list = RpcRequestFrame {
            id: "req-agents-list-invalid".to_owned(),
            method: "agents.list".to_owned(),
            params: serde_json::json!({
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&invalid_list).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let list = RpcRequestFrame {
            id: "req-agents-list".to_owned(),
            method: "agents.list".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/defaultId")
                        .and_then(serde_json::Value::as_str),
                    Some(super::DEFAULT_AGENT_ID)
                );
                assert_eq!(
                    payload
                        .pointer("/mainKey")
                        .and_then(serde_json::Value::as_str),
                    Some(super::DEFAULT_MAIN_KEY)
                );
                let agents = payload
                    .pointer("/agents")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(agents.iter().any(|agent| {
                    agent.get("id").and_then(serde_json::Value::as_str)
                        == Some(super::DEFAULT_AGENT_ID)
                }));
            }
            _ => panic!("expected agents.list handled"),
        }

        let create = RpcRequestFrame {
            id: "req-agents-create".to_owned(),
            method: "agents.create".to_owned(),
            params: serde_json::json!({
                "name": "Ops Bot",
                "workspace": "memory://agents/ops",
                "emoji": "ops"
            }),
        };
        let created_agent_id = match dispatcher.handle_request(&create).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                payload
                    .pointer("/agentId")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("agentId")
            }
            _ => panic!("expected agents.create handled"),
        };
        assert_eq!(created_agent_id, "ops-bot");

        let duplicate = RpcRequestFrame {
            id: "req-agents-create-duplicate".to_owned(),
            method: "agents.create".to_owned(),
            params: serde_json::json!({
                "name": "Ops Bot",
                "workspace": "memory://agents/ops-2"
            }),
        };
        let out = dispatcher.handle_request(&duplicate).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let update = RpcRequestFrame {
            id: "req-agents-update".to_owned(),
            method: "agents.update".to_owned(),
            params: serde_json::json!({
                "agentId": "ops-bot",
                "name": "Ops Prime",
                "model": "gpt-5.3",
                "avatar": "ops.png"
            }),
        };
        let out = dispatcher.handle_request(&update).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let files_list = RpcRequestFrame {
            id: "req-agents-files-list".to_owned(),
            method: "agents.files.list".to_owned(),
            params: serde_json::json!({
                "agentId": "ops-bot"
            }),
        };
        match dispatcher.handle_request(&files_list).await {
            RpcDispatchOutcome::Handled(payload) => {
                let files = payload
                    .pointer("/files")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(files.iter().any(|file| {
                    file.get("name").and_then(serde_json::Value::as_str) == Some("AGENTS.md")
                }));
            }
            _ => panic!("expected agents.files.list handled"),
        }

        let unsupported_file = RpcRequestFrame {
            id: "req-agents-files-get-unsupported".to_owned(),
            method: "agents.files.get".to_owned(),
            params: serde_json::json!({
                "agentId": "ops-bot",
                "name": "README.md"
            }),
        };
        let out = dispatcher.handle_request(&unsupported_file).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let set_file = RpcRequestFrame {
            id: "req-agents-files-set".to_owned(),
            method: "agents.files.set".to_owned(),
            params: serde_json::json!({
                "agentId": "ops-bot",
                "name": "AGENTS.md",
                "content": "# Ops"
            }),
        };
        match dispatcher.handle_request(&set_file).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/file/missing")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/file/content")
                        .and_then(serde_json::Value::as_str),
                    Some("# Ops")
                );
            }
            _ => panic!("expected agents.files.set handled"),
        }

        let get_file = RpcRequestFrame {
            id: "req-agents-files-get".to_owned(),
            method: "agents.files.get".to_owned(),
            params: serde_json::json!({
                "agentId": "ops-bot",
                "name": "AGENTS.md"
            }),
        };
        match dispatcher.handle_request(&get_file).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/file/missing")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/file/content")
                        .and_then(serde_json::Value::as_str),
                    Some("# Ops")
                );
            }
            _ => panic!("expected agents.files.get handled"),
        }

        let delete_main = RpcRequestFrame {
            id: "req-agents-delete-main".to_owned(),
            method: "agents.delete".to_owned(),
            params: serde_json::json!({
                "agentId": "main"
            }),
        };
        let out = dispatcher.handle_request(&delete_main).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let delete = RpcRequestFrame {
            id: "req-agents-delete".to_owned(),
            method: "agents.delete".to_owned(),
            params: serde_json::json!({
                "agentId": "ops-bot",
                "deleteFiles": true
            }),
        };
        match dispatcher.handle_request(&delete).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/removedBindings")
                        .and_then(serde_json::Value::as_u64),
                    Some(0)
                );
            }
            _ => panic!("expected agents.delete handled"),
        }

        let list_after_delete = RpcRequestFrame {
            id: "req-agents-list-post-delete".to_owned(),
            method: "agents.list".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&list_after_delete).await {
            RpcDispatchOutcome::Handled(payload) => {
                let agents = payload
                    .pointer("/agents")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(!agents.iter().any(|agent| {
                    agent.get("id").and_then(serde_json::Value::as_str) == Some("ops-bot")
                }));
            }
            _ => panic!("expected agents.list handled after delete"),
        }
    }

    #[tokio::test]
    async fn dispatcher_agents_persist_disk_workspace_and_config_across_restart() {
        let root = std::env::temp_dir().join(format!("openclaw-rust-agents-{}", super::now_ms()));
        fs::create_dir_all(&root).expect("create temp root");
        let store_path = root.join("gateway-config.json");
        let workspace = root.join("workspace-ops");
        let store_path_text = store_path.to_string_lossy().to_string();
        let workspace_text = workspace.to_string_lossy().to_string();

        let dispatcher = RpcDispatcher::new();
        let config_get = RpcRequestFrame {
            id: "req-agent-config-get".to_owned(),
            method: "config.get".to_owned(),
            params: serde_json::json!({}),
        };
        let hash = match dispatcher.handle_request(&config_get).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/hash")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("config hash"),
            _ => panic!("expected config.get handled"),
        };
        let patch_runtime = RpcRequestFrame {
            id: "req-agent-config-runtime".to_owned(),
            method: "config.patch".to_owned(),
            params: serde_json::json!({
                "baseHash": hash,
                "raw": serde_json::json!({
                    "config": { "storePath": store_path_text }
                }).to_string()
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&patch_runtime).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let create = RpcRequestFrame {
            id: "req-agent-create-disk".to_owned(),
            method: "agents.create".to_owned(),
            params: serde_json::json!({
                "name": "Ops Bot",
                "workspace": workspace_text
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&create).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let set_file = RpcRequestFrame {
            id: "req-agent-set-file-disk".to_owned(),
            method: "agents.files.set".to_owned(),
            params: serde_json::json!({
                "agentId": "ops-bot",
                "name": "AGENTS.md",
                "content": "# Ops Disk"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&set_file).await,
            RpcDispatchOutcome::Handled(_)
        ));
        assert_eq!(
            fs::read_to_string(workspace.join("AGENTS.md")).expect("read AGENTS.md"),
            "# Ops Disk"
        );

        let restarted = RpcDispatcher::new();
        let restarted_get = RpcRequestFrame {
            id: "req-agent-config-get-restart".to_owned(),
            method: "config.get".to_owned(),
            params: serde_json::json!({}),
        };
        let restarted_hash = match restarted.handle_request(&restarted_get).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/hash")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("config hash"),
            _ => panic!("expected config.get handled"),
        };
        let restarted_patch = RpcRequestFrame {
            id: "req-agent-config-runtime-restart".to_owned(),
            method: "config.patch".to_owned(),
            params: serde_json::json!({
                "baseHash": restarted_hash,
                "raw": serde_json::json!({
                    "config": { "storePath": store_path.to_string_lossy().to_string() }
                }).to_string()
            }),
        };
        assert!(matches!(
            restarted.handle_request(&restarted_patch).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let list = RpcRequestFrame {
            id: "req-agent-list-restart".to_owned(),
            method: "agents.list".to_owned(),
            params: serde_json::json!({}),
        };
        match restarted.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                let agents = payload
                    .pointer("/agents")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(agents.iter().any(|entry| {
                    entry.get("id").and_then(serde_json::Value::as_str) == Some("ops-bot")
                }));
            }
            _ => panic!("expected agents.list handled"),
        }

        let get_file = RpcRequestFrame {
            id: "req-agent-get-file-restart".to_owned(),
            method: "agents.files.get".to_owned(),
            params: serde_json::json!({
                "agentId": "ops-bot",
                "name": "AGENTS.md"
            }),
        };
        match restarted.handle_request(&get_file).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/file/content")
                        .and_then(serde_json::Value::as_str),
                    Some("# Ops Disk")
                );
            }
            _ => panic!("expected agents.files.get handled"),
        }

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_agent_identity_and_wait_methods_follow_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        let identity_default = RpcRequestFrame {
            id: "req-agent-identity-default".to_owned(),
            method: "agent.identity.get".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&identity_default).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/agentId")
                        .and_then(serde_json::Value::as_str),
                    Some("main")
                );
                assert_eq!(
                    payload
                        .pointer("/emoji")
                        .and_then(serde_json::Value::as_str),
                    Some(super::DEFAULT_AGENT_IDENTITY_EMOJI)
                );
            }
            _ => panic!("expected agent.identity.get handled"),
        }

        let malformed = RpcRequestFrame {
            id: "req-agent-identity-malformed".to_owned(),
            method: "agent.identity.get".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:"
            }),
        };
        let out = dispatcher.handle_request(&malformed).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let mismatch = RpcRequestFrame {
            id: "req-agent-identity-mismatch".to_owned(),
            method: "agent.identity.get".to_owned(),
            params: serde_json::json!({
                "agentId": "ops",
                "sessionKey": "agent:main:discord:group:g1"
            }),
        };
        let out = dispatcher.handle_request(&mismatch).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let invalid_agent = RpcRequestFrame {
            id: "req-agent-invalid".to_owned(),
            method: "agent".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-agent-wait",
                "message": "hello"
            }),
        };
        let out = dispatcher.handle_request(&invalid_agent).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let agent = RpcRequestFrame {
            id: "req-agent".to_owned(),
            method: "agent".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-agent-wait",
                "message": "hello",
                "idempotencyKey": "run-agent-123"
            }),
        };
        match dispatcher.handle_request(&agent).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/runId")
                        .and_then(serde_json::Value::as_str),
                    Some("run-agent-123")
                );
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("started")
                );
            }
            _ => panic!("expected agent handled"),
        }

        match dispatcher.handle_request(&agent).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(matches!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("in_flight" | "ok")
                ));
            }
            _ => panic!("expected idempotent agent replay"),
        }

        let mut completed = false;
        for _ in 0..10 {
            tokio::time::sleep(std::time::Duration::from_millis(10)).await;
            match dispatcher.handle_request(&agent).await {
                RpcDispatchOutcome::Handled(payload) => {
                    let status = payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str)
                        .unwrap_or_default();
                    if status == "ok" {
                        completed = true;
                        break;
                    }
                    assert_eq!(status, "in_flight");
                }
                _ => panic!("expected completed agent replay"),
            }
        }
        assert!(completed, "expected agent replay status to become ok");

        let wait_ok = RpcRequestFrame {
            id: "req-agent-wait-ok".to_owned(),
            method: "agent.wait".to_owned(),
            params: serde_json::json!({
                "runId": "run-agent-123",
                "timeoutMs": 0
            }),
        };
        match dispatcher.handle_request(&wait_ok).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("ok")
                );
            }
            _ => panic!("expected agent.wait handled"),
        }

        let wait_timeout = RpcRequestFrame {
            id: "req-agent-wait-timeout".to_owned(),
            method: "agent.wait".to_owned(),
            params: serde_json::json!({
                "runId": "run-missing",
                "timeoutMs": 0
            }),
        };
        match dispatcher.handle_request(&wait_timeout).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("timeout")
                );
            }
            _ => panic!("expected agent.wait handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_agent_runtime_executes_openai_tool_loop_for_cerebras_format() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-agent-runtime-{}", now_ms()));
        fs::create_dir_all(&root).expect("create runtime root");
        fs::write(root.join("README.md"), "openclaw rust parity").expect("write fixture file");
        let workspace = root.to_string_lossy().to_string();

        let listener = std::net::TcpListener::bind("127.0.0.1:0").expect("bind provider listener");
        let provider_addr = listener.local_addr().expect("provider addr");
        let captured_requests: Arc<Mutex<Vec<Value>>> = Arc::new(Mutex::new(Vec::new()));
        let captured_requests_server = Arc::clone(&captured_requests);
        let server = std::thread::spawn(move || {
            for turn in 0..2 {
                let (mut stream, _) = listener.accept().expect("accept provider request");
                let mut buffer = vec![0_u8; 128 * 1024];
                let read = stream.read(&mut buffer).expect("read provider request");
                let request_text = String::from_utf8_lossy(&buffer[..read]).to_string();
                let body = request_text
                    .split("\r\n\r\n")
                    .nth(1)
                    .unwrap_or_default()
                    .to_owned();
                if let Ok(parsed) = serde_json::from_str::<Value>(&body) {
                    if let Ok(mut guard) = captured_requests_server.lock() {
                        guard.push(parsed);
                    }
                }

                let payload = if turn == 0 {
                    json!({
                        "id": "cmpl-tool-1",
                        "object": "chat.completion",
                        "choices": [
                            {
                                "index": 0,
                                "message": {
                                    "role": "assistant",
                                    "tool_calls": [
                                        {
                                            "id": "call_read_1",
                                            "type": "function",
                                            "function": {
                                                "name": "read",
                                                "arguments": "{\"path\":\"README.md\"}"
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    })
                } else {
                    json!({
                        "id": "cmpl-tool-2",
                        "object": "chat.completion",
                        "choices": [
                            {
                                "index": 0,
                                "message": {
                                    "role": "assistant",
                                    "content": "tool-read-ok"
                                }
                            }
                        ]
                    })
                };
                let body = payload.to_string();
                let response = format!(
                    "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: {}\r\nConnection: close\r\n\r\n{}",
                    body.len(),
                    body
                );
                stream
                    .write_all(response.as_bytes())
                    .expect("write provider response");
            }
        });

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "agents": {
                    "list": [
                        {
                            "id": "main",
                            "workspace": workspace
                        }
                    ]
                },
                "models": {
                    "providers": {
                        "cerebras": {
                            "api": "openai-completions",
                            "baseUrl": format!("http://{provider_addr}/v1"),
                            "apiKey": "cerebras-test-key",
                            "models": [
                                {
                                    "id": "cerebras-free",
                                    "name": "Cerebras Free Promo"
                                }
                            ]
                        }
                    }
                }
            }),
        )
        .await;

        let session_key = "agent:main:discord:group:g-agent-runtime-tool-loop";
        let patch_model = RpcRequestFrame {
            id: "req-agent-runtime-tool-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: json!({
                "key": session_key,
                "model": "cerebras/cerebras-free"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&patch_model).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let run_agent = RpcRequestFrame {
            id: "req-agent-runtime-tool-run".to_owned(),
            method: "agent".to_owned(),
            params: json!({
                "sessionKey": session_key,
                "idempotencyKey": "agent-runtime-tool-run",
                "message": "Read README.md and reply with tool-read-ok"
            }),
        };
        match dispatcher.handle_request(&run_agent).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/status").and_then(Value::as_str),
                    Some("started")
                );
                assert_eq!(
                    payload
                        .pointer("/resolved/modelProvider")
                        .and_then(Value::as_str),
                    Some("cerebras")
                );
                assert_eq!(
                    payload
                        .pointer("/runtime/executed")
                        .and_then(Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected runtime agent request to be handled"),
        }

        let wait = RpcRequestFrame {
            id: "req-agent-runtime-tool-wait".to_owned(),
            method: "agent.wait".to_owned(),
            params: json!({
                "runId": "agent-runtime-tool-run",
                "timeoutMs": 0
            }),
        };
        match dispatcher.handle_request(&wait).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/status").and_then(Value::as_str),
                    Some("ok")
                );
            }
            _ => panic!("expected agent.wait handled"),
        }

        let history = RpcRequestFrame {
            id: "req-agent-runtime-tool-history".to_owned(),
            method: "sessions.history".to_owned(),
            params: json!({
                "sessionKey": session_key,
                "limit": 20
            }),
        };
        match dispatcher.handle_request(&history).await {
            RpcDispatchOutcome::Handled(payload) => {
                let items = payload
                    .pointer("/history")
                    .and_then(Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(items.iter().any(|item| {
                    item.pointer("/source")
                        .and_then(Value::as_str)
                        .map(|source| source == "agent.assistant")
                        .unwrap_or(false)
                        && item
                            .pointer("/text")
                            .and_then(Value::as_str)
                            .map(|text| text.contains("tool-read-ok"))
                            .unwrap_or(false)
                }));
                assert!(items.iter().any(|item| {
                    item.pointer("/source")
                        .and_then(Value::as_str)
                        .map(|source| source == "agent.tool.read")
                        .unwrap_or(false)
                }));
            }
            _ => panic!("expected sessions.history handled"),
        }

        server.join().expect("join provider server");
        let captured = captured_requests
            .lock()
            .expect("lock captured requests")
            .clone();
        assert_eq!(captured.len(), 2);
        assert!(captured[0]
            .pointer("/tools")
            .and_then(Value::as_array)
            .map(|items| !items.is_empty())
            .unwrap_or(false));
        assert!(captured[1]
            .pointer("/messages")
            .and_then(Value::as_array)
            .map(|items| {
                items.iter().any(|entry| {
                    entry
                        .pointer("/role")
                        .and_then(Value::as_str)
                        .map(|role| role == "tool")
                        .unwrap_or(false)
                })
            })
            .unwrap_or(false));

        let _ = fs::remove_dir_all(root);
    }

    #[tokio::test]
    async fn dispatcher_agent_runtime_executes_opencode_without_api_key_when_enabled() {
        let listener = std::net::TcpListener::bind("127.0.0.1:0").expect("bind provider listener");
        let provider_addr = listener.local_addr().expect("provider addr");
        let captured_request: Arc<Mutex<Option<String>>> = Arc::new(Mutex::new(None));
        let captured_request_server = Arc::clone(&captured_request);
        let server = std::thread::spawn(move || {
            let (mut stream, _) = listener.accept().expect("accept provider request");
            let mut buffer = vec![0_u8; 64 * 1024];
            let read = stream.read(&mut buffer).expect("read provider request");
            let request_text = String::from_utf8_lossy(&buffer[..read]).to_string();
            if let Ok(mut guard) = captured_request_server.lock() {
                *guard = Some(request_text);
            }
            let payload = json!({
                "id": "cmpl-opencode-keyless-1",
                "object": "chat.completion",
                "choices": [
                    {
                        "index": 0,
                        "message": {
                            "role": "assistant",
                            "content": "ok"
                        }
                    }
                ]
            });
            let body = payload.to_string();
            let response = format!(
                "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: {}\r\nConnection: close\r\n\r\n{}",
                body.len(),
                body
            );
            stream
                .write_all(response.as_bytes())
                .expect("write provider response");
        });

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "models": {
                    "providers": {
                        "opencode": {
                            "api": "openai-completions",
                            "baseUrl": format!("http://{provider_addr}/zen/v1"),
                            "websiteUrl": format!("http://{provider_addr}"),
                            "bridgeBaseUrls": [
                                format!("http://{provider_addr}/zen/v1")
                            ],
                            "allowUnauthenticated": true,
                            "models": [
                                { "id": "glm-5-free", "name": "GLM-5-Free" }
                            ]
                        }
                    }
                }
            }),
        )
        .await;

        let session_key = "agent:main:discord:group:g-agent-runtime-opencode-keyless";
        let patch_model = RpcRequestFrame {
            id: "req-agent-opencode-keyless-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: json!({
                "key": session_key,
                "model": "opencode/glm-5-free"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&patch_model).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let run_agent = RpcRequestFrame {
            id: "req-agent-opencode-keyless-run".to_owned(),
            method: "agent".to_owned(),
            params: json!({
                "sessionKey": session_key,
                "idempotencyKey": "agent-opencode-keyless-run",
                "message": "Reply with ok"
            }),
        };
        match dispatcher.handle_request(&run_agent).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/status").and_then(Value::as_str),
                    Some("started")
                );
                assert_eq!(
                    payload
                        .pointer("/resolved/modelProvider")
                        .and_then(Value::as_str),
                    Some("opencode")
                );
                assert_eq!(
                    payload
                        .pointer("/runtime/executed")
                        .and_then(Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected runtime agent request to be handled"),
        }

        let wait = RpcRequestFrame {
            id: "req-agent-opencode-keyless-wait".to_owned(),
            method: "agent.wait".to_owned(),
            params: json!({
                "runId": "agent-opencode-keyless-run",
                "timeoutMs": 0
            }),
        };
        match dispatcher.handle_request(&wait).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/status").and_then(Value::as_str),
                    Some("ok")
                );
            }
            _ => panic!("expected agent.wait handled"),
        }

        server.join().expect("join provider server");
        let request_text = captured_request
            .lock()
            .expect("lock captured request")
            .clone()
            .expect("captured request text");
        let request_lower = request_text.to_ascii_lowercase();
        assert!(
            !request_lower.contains("\r\nauthorization:"),
            "keyless opencode path must not send authorization header"
        );
    }

    #[tokio::test]
    async fn dispatcher_agent_reset_command_rotates_session_and_keeps_followup() {
        let dispatcher = RpcDispatcher::new();
        let session_key = "agent:main:discord:group:g-agent-reset";

        let seed = RpcRequestFrame {
            id: "req-agent-reset-seed".to_owned(),
            method: "sessions.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "message": "before reset"
            }),
        };
        let _ = dispatcher.handle_request(&seed).await;

        let status_before = RpcRequestFrame {
            id: "req-agent-reset-status-before".to_owned(),
            method: "session.status".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key
            }),
        };
        let previous_session_id = match dispatcher.handle_request(&status_before).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/session/sessionId")
                .and_then(serde_json::Value::as_str)
                .map(str::to_owned)
                .expect("missing previous session id"),
            _ => panic!("expected session.status before reset"),
        };

        let reset = RpcRequestFrame {
            id: "req-agent-reset".to_owned(),
            method: "agent".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "message": "/new hello after reset",
                "idempotencyKey": "run-agent-reset-1"
            }),
        };
        let reset_session_id = match dispatcher.handle_request(&reset).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("started")
                );
                assert_eq!(
                    payload
                        .pointer("/reset/reason")
                        .and_then(serde_json::Value::as_str),
                    Some("new")
                );
                assert_eq!(
                    payload
                        .pointer("/reset/key")
                        .and_then(serde_json::Value::as_str),
                    Some(session_key)
                );
                payload
                    .pointer("/reset/sessionId")
                    .and_then(serde_json::Value::as_str)
                    .map(str::to_owned)
                    .expect("missing reset session id")
            }
            _ => panic!("expected agent reset command handled"),
        };

        assert_ne!(previous_session_id, reset_session_id);

        let history = RpcRequestFrame {
            id: "req-agent-reset-history".to_owned(),
            method: "sessions.history".to_owned(),
            params: serde_json::json!({
                "sessionKey": session_key,
                "limit": 10
            }),
        };
        match dispatcher.handle_request(&history).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/count")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/history/0/text")
                        .and_then(serde_json::Value::as_str),
                    Some("hello after reset")
                );
                assert_eq!(
                    payload
                        .pointer("/history/0/source")
                        .and_then(serde_json::Value::as_str),
                    Some("agent")
                );
            }
            _ => panic!("expected reset history snapshot"),
        }
    }

    #[tokio::test]
    async fn dispatcher_skills_methods_report_status_update_and_install() {
        let dispatcher = RpcDispatcher::new();

        let invalid_status = RpcRequestFrame {
            id: "req-skills-status-invalid".to_owned(),
            method: "skills.status".to_owned(),
            params: serde_json::json!({
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&invalid_status).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let status = RpcRequestFrame {
            id: "req-skills-status".to_owned(),
            method: "skills.status".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/workspaceDir")
                        .and_then(serde_json::Value::as_str),
                    Some(super::DEFAULT_AGENT_WORKSPACE)
                );
                assert!(payload
                    .pointer("/managedSkillsDir")
                    .and_then(serde_json::Value::as_str)
                    .is_some());
            }
            _ => panic!("expected skills.status handled"),
        }

        let update = RpcRequestFrame {
            id: "req-skills-update".to_owned(),
            method: "skills.update".to_owned(),
            params: serde_json::json!({
                "skillKey": "brave-search",
                "enabled": false,
                "apiKey": "abc\r\ndef",
                "env": {
                    " BRAVE_API_KEY ": " secret ",
                    "REMOVE_ME": " ",
                    "": "skip"
                }
            }),
        };
        match dispatcher.handle_request(&update).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/config/apiKey")
                        .and_then(serde_json::Value::as_str),
                    Some("abcdef")
                );
                assert_eq!(
                    payload
                        .pointer("/config/enabled")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/config/env/BRAVE_API_KEY")
                        .and_then(serde_json::Value::as_str),
                    Some("secret")
                );
                assert!(payload.pointer("/config/env/REMOVE_ME").is_none());
            }
            _ => panic!("expected skills.update handled"),
        }

        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                let skills = payload
                    .pointer("/skills")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                let configured = skills
                    .iter()
                    .find(|entry| {
                        entry
                            .pointer("/skillKey")
                            .and_then(serde_json::Value::as_str)
                            == Some("brave-search")
                    })
                    .expect("configured skill present");
                assert_eq!(
                    configured
                        .pointer("/disabled")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected skills.status handled"),
        }

        let invalid_install = RpcRequestFrame {
            id: "req-skills-install-invalid".to_owned(),
            method: "skills.install".to_owned(),
            params: serde_json::json!({
                "name": "Brave Search",
                "installId": "uv:brave-search",
                "timeoutMs": 500
            }),
        };
        let out = dispatcher.handle_request(&invalid_install).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let install = RpcRequestFrame {
            id: "req-skills-install".to_owned(),
            method: "skills.install".to_owned(),
            params: serde_json::json!({
                "name": "Brave Search",
                "installId": "uv:brave-search",
                "timeoutMs": 120000
            }),
        };
        match dispatcher.handle_request(&install).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/installed")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected skills.install handled"),
        }

        let bins = RpcRequestFrame {
            id: "req-skills-bins".to_owned(),
            method: "skills.bins".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&bins).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(payload
                    .pointer("/bins")
                    .and_then(serde_json::Value::as_array)
                    .is_some());
            }
            _ => panic!("expected skills.bins handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_skills_status_rejects_unknown_agent_id() {
        let dispatcher = RpcDispatcher::new();
        let req = RpcRequestFrame {
            id: "req-skills-status-unknown-agent".to_owned(),
            method: "skills.status".to_owned(),
            params: serde_json::json!({
                "agentId": "missing-agent"
            }),
        };
        let out = dispatcher.handle_request(&req).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_update_and_web_login_methods_report_expected_payloads() {
        let dispatcher = RpcDispatcher::new();

        let invalid_update = RpcRequestFrame {
            id: "req-update-invalid".to_owned(),
            method: "update.run".to_owned(),
            params: serde_json::json!({
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&invalid_update).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let update = RpcRequestFrame {
            id: "req-update-run".to_owned(),
            method: "update.run".to_owned(),
            params: serde_json::json!({
                "sessionKey": "agent:main:discord:group:g-upd:topic:42",
                "note": "rollout",
                "restartDelayMs": 2500,
                "timeoutMs": 10
            }),
        };
        match dispatcher.handle_request(&update).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/result/status")
                        .and_then(serde_json::Value::as_str),
                    Some("ok")
                );
                assert_eq!(
                    payload
                        .pointer("/restart/delayMs")
                        .and_then(serde_json::Value::as_u64),
                    Some(2500)
                );
                assert_eq!(
                    payload
                        .pointer("/sentinel/payload/threadId")
                        .and_then(serde_json::Value::as_str),
                    Some("42")
                );
                assert_eq!(
                    payload
                        .pointer("/sentinel/payload/deliveryContext/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("discord")
                );
                assert_eq!(
                    payload
                        .pointer("/sentinel/payload/doctorHint")
                        .and_then(serde_json::Value::as_str),
                    Some("Run `openclaw doctor --non-interactive` after restart.")
                );
            }
            _ => panic!("expected update.run handled"),
        }

        let invalid_web_start = RpcRequestFrame {
            id: "req-web-start-invalid".to_owned(),
            method: "web.login.start".to_owned(),
            params: serde_json::json!({
                "unknown": true
            }),
        };
        let out = dispatcher.handle_request(&invalid_web_start).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let web_start = RpcRequestFrame {
            id: "req-web-start".to_owned(),
            method: "web.login.start".to_owned(),
            params: serde_json::json!({
                "timeoutMs": 6000,
                "verbose": true
            }),
        };
        match dispatcher.handle_request(&web_start).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/providerId")
                        .and_then(serde_json::Value::as_str),
                    Some("whatsapp")
                );
                assert_eq!(
                    payload
                        .pointer("/accountId")
                        .and_then(serde_json::Value::as_str),
                    Some("default")
                );
                let qr = payload
                    .pointer("/qrDataUrl")
                    .and_then(serde_json::Value::as_str)
                    .unwrap_or_default();
                assert!(qr.starts_with("data:image/png;base64,"));
            }
            _ => panic!("expected web.login.start handled"),
        }

        let web_wait = RpcRequestFrame {
            id: "req-web-wait".to_owned(),
            method: "web.login.wait".to_owned(),
            params: serde_json::json!({
                "timeoutMs": 5000
            }),
        };
        match dispatcher.handle_request(&web_wait).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected web.login.wait handled"),
        }

        match dispatcher.handle_request(&web_wait).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected web.login.wait handled"),
        }

        let oauth_start = RpcRequestFrame {
            id: "req-oauth-start".to_owned(),
            method: "auth.oauth.start".to_owned(),
            params: serde_json::json!({
                "provider": "chatgpt",
                "accountId": "default",
                "timeoutMs": 120000
            }),
        };
        let oauth_session_id = match dispatcher.handle_request(&oauth_start).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/providerId")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
                payload
                    .pointer("/sessionId")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("oauth session id")
            }
            _ => panic!("expected auth.oauth.start handled"),
        };

        let oauth_wait_pending = RpcRequestFrame {
            id: "req-oauth-wait-pending".to_owned(),
            method: "auth.oauth.wait".to_owned(),
            params: serde_json::json!({
                "sessionId": oauth_session_id
            }),
        };
        match dispatcher.handle_request(&oauth_wait_pending).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("pending")
                );
            }
            _ => panic!("expected auth.oauth.wait handled"),
        }

        let oauth_complete = RpcRequestFrame {
            id: "req-oauth-complete".to_owned(),
            method: "auth.oauth.complete".to_owned(),
            params: serde_json::json!({
                "sessionId": oauth_session_id,
                "accessToken": "tok_test_openai_access",
                "refreshToken": "tok_test_openai_refresh",
                "expiresAtMs": now_ms() + 60_000
            }),
        };
        match dispatcher.handle_request(&oauth_complete).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/providerId")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
                assert_eq!(
                    payload
                        .pointer("/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected auth.oauth.complete handled"),
        }

        let oauth_wait_connected = RpcRequestFrame {
            id: "req-oauth-wait-connected".to_owned(),
            method: "auth.oauth.wait".to_owned(),
            params: serde_json::json!({
                "provider": "openai",
                "accountId": "default",
                "timeoutMs": 1000
            }),
        };
        match dispatcher.handle_request(&oauth_wait_connected).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected auth.oauth.wait handled"),
        }

        let oauth_logout = RpcRequestFrame {
            id: "req-oauth-logout".to_owned(),
            method: "auth.oauth.logout".to_owned(),
            params: serde_json::json!({
                "provider": "openai",
                "accountId": "default"
            }),
        };
        match dispatcher.handle_request(&oauth_logout).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/providerId")
                        .and_then(serde_json::Value::as_str),
                    Some("openai")
                );
                assert_eq!(
                    payload
                        .pointer("/removed")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
            }
            _ => panic!("expected auth.oauth.logout handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_web_login_store_path_persists_and_recovers_sessions_across_dispatchers() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-web-login-store-{}", now_ms()));
        fs::create_dir_all(&root).expect("create temp web login root");
        let store_path = root.join("web-login").join("sessions.json");
        let store_path_text = store_path.to_string_lossy().to_string();

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "webLogin": {
                    "storePath": store_path_text
                }
            }),
        )
        .await;

        let start = RpcRequestFrame {
            id: "req-web-login-store-start".to_owned(),
            method: "web.login.start".to_owned(),
            params: json!({
                "accountId": "persisted",
                "timeoutMs": 60000
            }),
        };
        let first_session_id = match dispatcher.handle_request(&start).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/sessionId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("web login session id"),
            _ => panic!("expected web.login.start handled"),
        };
        assert!(store_path.exists(), "web login store should be persisted");

        let restarted = RpcDispatcher::new();
        patch_config(
            &restarted,
            json!({
                "webLogin": {
                    "storePath": store_path.to_string_lossy().to_string()
                }
            }),
        )
        .await;

        let recovered_session_id = match restarted.handle_request(&start).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/sessionId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("recovered web login session id"),
            _ => panic!("expected web.login.start handled"),
        };
        assert_eq!(recovered_session_id, first_session_id);

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_oauth_imports_cli_credentials_and_persists_store() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-oauth-import-{}", now_ms()));
        fs::create_dir_all(&root).expect("create temp oauth root");
        let home_dir = root.join("home");
        let codex_home = root.join("codex-home");
        let oauth_store_path = root.join("oauth").join("state.json");

        fs::create_dir_all(home_dir.join(".claude")).expect("create claude dir");
        fs::create_dir_all(home_dir.join(".gemini")).expect("create gemini dir");
        fs::create_dir_all(&codex_home).expect("create codex home");

        fs::write(
            home_dir.join(".claude").join(".credentials.json"),
            serde_json::to_string_pretty(&json!({
                "claudeAiOauth": {
                    "accessToken": "claude-access-token",
                    "refreshToken": "claude-refresh-token",
                    "expiresAt": now_ms() + 120_000
                }
            }))
            .expect("serialize claude credential"),
        )
        .expect("write claude credential");
        fs::write(
            home_dir.join(".gemini").join("oauth_creds.json"),
            serde_json::to_string_pretty(&json!({
                "access_token": "gemini-access-token",
                "refresh_token": "gemini-refresh-token",
                "expiry_date": now_ms() + 180_000,
                "scope": "profile email"
            }))
            .expect("serialize gemini credential"),
        )
        .expect("write gemini credential");
        fs::write(
            codex_home.join("auth.json"),
            serde_json::to_string_pretty(&json!({
                "tokens": {
                    "access_token": "codex-access-token",
                    "refresh_token": "codex-refresh-token",
                    "account_id": "codex-cli"
                }
            }))
            .expect("serialize codex credential"),
        )
        .expect("write codex credential");

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "auth": {
                    "oauth": {
                        "storePath": oauth_store_path.to_string_lossy().to_string()
                    }
                }
            }),
        )
        .await;

        let import = RpcRequestFrame {
            id: "req-oauth-import-cli".to_owned(),
            method: "auth.oauth.import".to_owned(),
            params: json!({
                "providers": ["codex", "claude", "gemini"],
                "homeDir": home_dir.to_string_lossy().to_string(),
                "codexHome": codex_home.to_string_lossy().to_string(),
                "overwrite": true
            }),
        };
        match dispatcher.handle_request(&import).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/importedCount")
                        .and_then(serde_json::Value::as_u64),
                    Some(3)
                );
            }
            _ => panic!("expected auth.oauth.import handled"),
        }
        assert!(oauth_store_path.exists(), "oauth store should be persisted");

        let providers = RpcRequestFrame {
            id: "req-oauth-providers".to_owned(),
            method: "auth.oauth.providers".to_owned(),
            params: json!({}),
        };
        match dispatcher.handle_request(&providers).await {
            RpcDispatchOutcome::Handled(payload) => {
                let list = payload
                    .pointer("/providers")
                    .and_then(serde_json::Value::as_array)
                    .expect("providers array");
                assert!(list.iter().any(|entry| {
                    entry
                        .pointer("/providerId")
                        .and_then(serde_json::Value::as_str)
                        == Some("opencode")
                }));
                assert!(list.iter().any(|entry| {
                    entry
                        .pointer("/providerId")
                        .and_then(serde_json::Value::as_str)
                        == Some("zhipuai")
                }));
                let codex = list.iter().find(|entry| {
                    entry
                        .pointer("/providerId")
                        .and_then(serde_json::Value::as_str)
                        == Some("openai-codex")
                });
                assert!(
                    codex
                        .and_then(|entry| entry.pointer("/connectedAccounts"))
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        >= 1
                );
            }
            _ => panic!("expected auth.oauth.providers handled"),
        }

        let restarted = RpcDispatcher::new();
        patch_config(
            &restarted,
            json!({
                "auth": {
                    "oauth": {
                        "storePath": oauth_store_path.to_string_lossy().to_string()
                    }
                }
            }),
        )
        .await;

        let wait_after_restart = RpcRequestFrame {
            id: "req-oauth-wait-after-restart".to_owned(),
            method: "auth.oauth.wait".to_owned(),
            params: json!({
                "provider": "codex",
                "accountId": "codex-cli",
                "timeoutMs": 1000
            }),
        };
        match restarted.handle_request(&wait_after_restart).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected auth.oauth.wait handled"),
        }

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_browser_request_validates_and_reports_unavailable_contract() {
        let dispatcher = RpcDispatcher::new();

        let missing = RpcRequestFrame {
            id: "req-browser-missing".to_owned(),
            method: "browser.request".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&missing).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let invalid_method = RpcRequestFrame {
            id: "req-browser-invalid-method".to_owned(),
            method: "browser.request".to_owned(),
            params: serde_json::json!({
                "method": "PATCH",
                "path": "/tabs"
            }),
        };
        let out = dispatcher.handle_request(&invalid_method).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let non_object_params = RpcRequestFrame {
            id: "req-browser-non-object".to_owned(),
            method: "browser.request".to_owned(),
            params: serde_json::json!("raw"),
        };
        let out = dispatcher.handle_request(&non_object_params).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let valid_request = RpcRequestFrame {
            id: "req-browser-valid".to_owned(),
            method: "browser.request".to_owned(),
            params: serde_json::json!({
                "method": "get",
                "path": "/tabs",
                "query": {
                    "profile": "default"
                },
                "timeoutMs": 0
            }),
        };
        match dispatcher.handle_request(&valid_request).await {
            RpcDispatchOutcome::Error {
                code,
                message,
                details,
            } => {
                assert_eq!(code, 503);
                assert_eq!(message, "browser control is disabled");
                assert_eq!(
                    details
                        .as_ref()
                        .and_then(|value| value.pointer("/method"))
                        .and_then(serde_json::Value::as_str),
                    Some("GET")
                );
                assert_eq!(
                    details
                        .as_ref()
                        .and_then(|value| value.pointer("/path"))
                        .and_then(serde_json::Value::as_str),
                    Some("/tabs")
                );
            }
            _ => panic!("expected browser.request unavailable response"),
        }

        let non_numeric_timeout = RpcRequestFrame {
            id: "req-browser-timeout-string".to_owned(),
            method: "browser.request".to_owned(),
            params: serde_json::json!({
                "method": "POST",
                "path": "/navigate",
                "timeoutMs": "1500"
            }),
        };
        let out = dispatcher.handle_request(&non_numeric_timeout).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 503, .. }));
    }

    #[tokio::test]
    async fn dispatcher_browser_request_routes_through_node_proxy_runtime() {
        let dispatcher = Arc::new(RpcDispatcher::new());

        let pair = RpcRequestFrame {
            id: "req-browser-node-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "browser-node-1",
                "displayName": "Browser Node",
                "caps": ["browser"],
                "commands": ["browser.proxy"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-browser-node-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let browser_req = RpcRequestFrame {
            id: "req-browser-node-proxy".to_owned(),
            method: "browser.request".to_owned(),
            params: serde_json::json!({
                "method": "GET",
                "path": "/tabs",
                "query": {
                    "profile": "default"
                },
                "timeoutMs": 500
            }),
        };
        let task_dispatcher = Arc::clone(&dispatcher);
        let browser_task =
            tokio::spawn(async move { task_dispatcher.handle_request(&browser_req).await });

        let mut invoke_id = None;
        for _ in 0..100 {
            if let Some(id) = dispatcher.node_runtime.latest_pending_invoke_id().await {
                invoke_id = Some(id);
                break;
            }
            tokio::time::sleep(Duration::from_millis(5)).await;
        }
        let invoke_id = invoke_id.expect("pending invoke id");
        let invoke_result = RpcRequestFrame {
            id: "req-browser-node-proxy-result".to_owned(),
            method: "node.invoke.result".to_owned(),
            params: serde_json::json!({
                "id": invoke_id,
                "nodeId": "browser-node-1",
                "ok": true,
                "payload": {
                    "result": {
                        "ok": true,
                        "tabs": [
                            {"id": "tab-1"}
                        ]
                    }
                }
            }),
        };
        let out = dispatcher.handle_request(&invoke_result).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        match browser_task.await.expect("browser request task") {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/tabs/0/id")
                        .and_then(serde_json::Value::as_str),
                    Some("tab-1")
                );
            }
            _ => panic!("expected browser.request handled response"),
        }
    }

    #[tokio::test]
    async fn dispatcher_browser_request_enforces_browser_proxy_command_allowlist() {
        let dispatcher = RpcDispatcher::new();

        let pair = RpcRequestFrame {
            id: "req-browser-disallowed-node-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "browser-node-2",
                "displayName": "Camera Node",
                "caps": ["browser"],
                "commands": ["camera.capture"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-browser-disallowed-node-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let browser_req = RpcRequestFrame {
            id: "req-browser-disallowed-node-proxy".to_owned(),
            method: "browser.request".to_owned(),
            params: serde_json::json!({
                "method": "GET",
                "path": "/tabs",
                "timeoutMs": 250
            }),
        };
        match dispatcher.handle_request(&browser_req).await {
            RpcDispatchOutcome::Error {
                code,
                message,
                details,
            } => {
                assert_eq!(code, 400);
                assert_eq!(message, "node command not allowed");
                assert_eq!(
                    details
                        .as_ref()
                        .and_then(|value| value.pointer("/command"))
                        .and_then(serde_json::Value::as_str),
                    Some("browser.proxy")
                );
            }
            _ => panic!("expected browser.request invalid-request response"),
        }
    }

    #[tokio::test]
    async fn dispatcher_browser_open_routes_through_browser_proxy_runtime() {
        let dispatcher = Arc::new(RpcDispatcher::new());

        let pair = RpcRequestFrame {
            id: "req-browser-open-node-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "browser-open-node-1",
                "displayName": "Browser Open Node",
                "caps": ["browser"],
                "commands": ["browser.proxy"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-browser-open-node-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let browser_open = RpcRequestFrame {
            id: "req-browser-open".to_owned(),
            method: "browser.open".to_owned(),
            params: serde_json::json!({
                "url": "https://example.com",
                "timeoutMs": 500
            }),
        };
        let task_dispatcher = Arc::clone(&dispatcher);
        let browser_task =
            tokio::spawn(async move { task_dispatcher.handle_request(&browser_open).await });

        let mut invoke_id = None;
        for _ in 0..100 {
            if let Some(id) = dispatcher.node_runtime.latest_pending_invoke_id().await {
                invoke_id = Some(id);
                break;
            }
            tokio::time::sleep(Duration::from_millis(5)).await;
        }
        let invoke_id = invoke_id.expect("pending invoke id");
        let invoke_result = RpcRequestFrame {
            id: "req-browser-open-result".to_owned(),
            method: "node.invoke.result".to_owned(),
            params: serde_json::json!({
                "id": invoke_id,
                "nodeId": "browser-open-node-1",
                "ok": true,
                "payload": {
                    "result": {
                        "ok": true,
                        "targetId": "tab-open-1",
                        "url": "https://example.com"
                    }
                }
            }),
        };
        let out = dispatcher.handle_request(&invoke_result).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        match browser_task.await.expect("browser open task") {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/targetId")
                        .and_then(serde_json::Value::as_str),
                    Some("tab-open-1")
                );
                assert_eq!(
                    payload.pointer("/url").and_then(serde_json::Value::as_str),
                    Some("https://example.com")
                );
            }
            _ => panic!("expected browser.open handled response"),
        }
    }

    #[tokio::test]
    async fn dispatcher_canvas_present_routes_through_node_runtime() {
        let dispatcher = Arc::new(RpcDispatcher::new());

        let pair = RpcRequestFrame {
            id: "req-canvas-present-node-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "canvas-node-1",
                "displayName": "Canvas Node",
                "commands": ["canvas.present"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-canvas-present-node-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let canvas_present = RpcRequestFrame {
            id: "req-canvas-present".to_owned(),
            method: "canvas.present".to_owned(),
            params: serde_json::json!({
                "nodeId": "canvas-node-1",
                "target": "https://example.com/canvas",
                "x": 10,
                "y": 20,
                "width": 800,
                "height": 480,
                "timeoutMs": 500
            }),
        };
        let task_dispatcher = Arc::clone(&dispatcher);
        let canvas_task =
            tokio::spawn(async move { task_dispatcher.handle_request(&canvas_present).await });

        let mut invoke_id = None;
        for _ in 0..100 {
            if let Some(id) = dispatcher.node_runtime.latest_pending_invoke_id().await {
                invoke_id = Some(id);
                break;
            }
            tokio::time::sleep(Duration::from_millis(5)).await;
        }
        let invoke_id = invoke_id.expect("pending invoke id");
        let invoke_result = RpcRequestFrame {
            id: "req-canvas-present-result".to_owned(),
            method: "node.invoke.result".to_owned(),
            params: serde_json::json!({
                "id": invoke_id,
                "nodeId": "canvas-node-1",
                "ok": true,
                "payload": {
                    "ok": true,
                    "shown": true
                }
            }),
        };
        let out = dispatcher.handle_request(&invoke_result).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        match canvas_task.await.expect("canvas present task") {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/nodeId")
                        .and_then(serde_json::Value::as_str),
                    Some("canvas-node-1")
                );
                assert_eq!(
                    payload
                        .pointer("/command")
                        .and_then(serde_json::Value::as_str),
                    Some("canvas.present")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/shown")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected canvas.present handled response"),
        }
    }

    #[tokio::test]
    async fn dispatcher_local_node_host_runtime_handles_browser_and_canvas_without_external_results(
    ) {
        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "nodeHost": {
                    "localNodeIds": ["local-browser-node-1"]
                }
            }),
        )
        .await;

        let pair = RpcRequestFrame {
            id: "req-local-browser-node-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-browser-node-1",
                "displayName": "Local Browser Node",
                "caps": ["browser", "host.local"],
                "commands": ["browser.proxy", "canvas.present"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-local-browser-node-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let browser_req = RpcRequestFrame {
            id: "req-local-browser-proxy".to_owned(),
            method: "browser.request".to_owned(),
            params: serde_json::json!({
                "method": "GET",
                "path": "/tabs"
            }),
        };
        match dispatcher.handle_request(&browser_req).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
                assert_eq!(
                    payload.pointer("/body/mode").and_then(Value::as_str),
                    Some("rust-parity-local-host")
                );
            }
            _ => panic!("expected browser.request handled"),
        }
        assert!(
            dispatcher
                .node_runtime
                .latest_pending_invoke_id()
                .await
                .is_none(),
            "local browser proxy should not leave pending invokes"
        );

        let canvas_req = RpcRequestFrame {
            id: "req-local-canvas-present".to_owned(),
            method: "canvas.present".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-browser-node-1",
                "target": "https://example.com/canvas"
            }),
        };
        match dispatcher.handle_request(&canvas_req).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
                assert_eq!(
                    payload
                        .pointer("/payload/presented")
                        .and_then(Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected canvas.present handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_canvas_present_rejects_disallowed_command() {
        let dispatcher = RpcDispatcher::new();

        let pair = RpcRequestFrame {
            id: "req-canvas-disallowed-node-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "canvas-node-2",
                "displayName": "Camera-only Node",
                "commands": ["camera.capture"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-canvas-disallowed-node-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let canvas_present = RpcRequestFrame {
            id: "req-canvas-disallowed-present".to_owned(),
            method: "canvas.present".to_owned(),
            params: serde_json::json!({
                "nodeId": "canvas-node-2",
                "target": "https://example.com/canvas"
            }),
        };
        match dispatcher.handle_request(&canvas_present).await {
            RpcDispatchOutcome::Error {
                code,
                message,
                details,
            } => {
                assert_eq!(code, 400);
                assert_eq!(message, "node command not allowed");
                assert_eq!(
                    details
                        .as_ref()
                        .and_then(|value| value.pointer("/command"))
                        .and_then(serde_json::Value::as_str),
                    Some("canvas.present")
                );
            }
            _ => panic!("expected canvas.present invalid-request response"),
        }
    }

    #[tokio::test]
    async fn dispatcher_wizard_methods_manage_session_lifecycle() {
        let dispatcher = RpcDispatcher::new();

        let invalid_start = RpcRequestFrame {
            id: "req-wizard-start-invalid".to_owned(),
            method: "wizard.start".to_owned(),
            params: serde_json::json!({
                "mode": "cluster"
            }),
        };
        let out = dispatcher.handle_request(&invalid_start).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let start = RpcRequestFrame {
            id: "req-wizard-start".to_owned(),
            method: "wizard.start".to_owned(),
            params: serde_json::json!({
                "mode": "remote",
                "workspace": "C:/workspace/openclaw"
            }),
        };
        let session_id = match dispatcher.handle_request(&start).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/done")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("running")
                );
                payload
                    .pointer("/sessionId")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("wizard session id")
            }
            _ => panic!("expected wizard.start handled"),
        };

        let start_again = RpcRequestFrame {
            id: "req-wizard-start-again".to_owned(),
            method: "wizard.start".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&start_again).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 503, .. }));

        let status = RpcRequestFrame {
            id: "req-wizard-status".to_owned(),
            method: "wizard.status".to_owned(),
            params: serde_json::json!({
                "sessionId": session_id.clone()
            }),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("running")
                );
            }
            _ => panic!("expected wizard.status handled"),
        }

        let next = RpcRequestFrame {
            id: "req-wizard-next".to_owned(),
            method: "wizard.next".to_owned(),
            params: serde_json::json!({
                "sessionId": session_id.clone(),
                "answer": {
                    "stepId": "confirm-setup",
                    "value": true
                }
            }),
        };
        match dispatcher.handle_request(&next).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/done")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("done")
                );
            }
            _ => panic!("expected wizard.next handled"),
        }

        let missing_status = RpcRequestFrame {
            id: "req-wizard-status-missing".to_owned(),
            method: "wizard.status".to_owned(),
            params: serde_json::json!({
                "sessionId": session_id
            }),
        };
        let out = dispatcher.handle_request(&missing_status).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_wizard_store_path_persists_and_recovers_running_session() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-wizard-store-{}", now_ms()));
        fs::create_dir_all(&root).expect("create temp wizard root");
        let store_path = root.join("wizard").join("sessions.json");
        let store_path_text = store_path.to_string_lossy().to_string();

        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "wizard": {
                    "storePath": store_path_text
                }
            }),
        )
        .await;

        let start = RpcRequestFrame {
            id: "req-wizard-store-start".to_owned(),
            method: "wizard.start".to_owned(),
            params: serde_json::json!({
                "mode": "remote",
                "workspace": "memory://wizard-persist"
            }),
        };
        let session_id = match dispatcher.handle_request(&start).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/sessionId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("wizard session id"),
            _ => panic!("expected wizard.start handled"),
        };
        assert!(store_path.exists(), "wizard store should be persisted");

        let restarted = RpcDispatcher::new();
        patch_config(
            &restarted,
            json!({
                "wizard": {
                    "storePath": store_path.to_string_lossy().to_string()
                }
            }),
        )
        .await;

        let status = RpcRequestFrame {
            id: "req-wizard-store-status".to_owned(),
            method: "wizard.status".to_owned(),
            params: serde_json::json!({
                "sessionId": session_id
            }),
        };
        match restarted.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/status").and_then(Value::as_str),
                    Some("running")
                );
            }
            _ => panic!("expected wizard.status handled"),
        }

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_device_pair_and_token_methods_follow_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "event": "device.pair.requested",
                "payload": {
                    "requestId": "pair-1",
                    "deviceId": "device-1",
                    "publicKey": "pubkey-1",
                    "displayName": "Primary Tablet",
                    "role": "operator",
                    "roles": ["operator"],
                    "scopes": ["exec:read", "exec:write"],
                    "ts": 123456
                }
            }))
            .await;

        let invalid_list = RpcRequestFrame {
            id: "req-device-list-invalid".to_owned(),
            method: "device.pair.list".to_owned(),
            params: serde_json::json!({
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&invalid_list).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let list = RpcRequestFrame {
            id: "req-device-list".to_owned(),
            method: "device.pair.list".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/pending/0/requestId")
                        .and_then(serde_json::Value::as_str),
                    Some("pair-1")
                );
                assert_eq!(
                    payload
                        .pointer("/pending/0/deviceId")
                        .and_then(serde_json::Value::as_str),
                    Some("device-1")
                );
            }
            _ => panic!("expected device.pair.list handled"),
        }

        let approve = RpcRequestFrame {
            id: "req-device-approve".to_owned(),
            method: "device.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": "pair-1"
            }),
        };
        match dispatcher.handle_request(&approve).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/requestId")
                        .and_then(serde_json::Value::as_str),
                    Some("pair-1")
                );
                assert_eq!(
                    payload
                        .pointer("/device/deviceId")
                        .and_then(serde_json::Value::as_str),
                    Some("device-1")
                );
                assert_eq!(
                    payload
                        .pointer("/device/tokens/0/role")
                        .and_then(serde_json::Value::as_str),
                    Some("operator")
                );
                assert!(payload.pointer("/device/tokens/0/token").is_none());
            }
            _ => panic!("expected device.pair.approve handled"),
        }

        let rotate = RpcRequestFrame {
            id: "req-device-rotate".to_owned(),
            method: "device.token.rotate".to_owned(),
            params: serde_json::json!({
                "deviceId": "device-1",
                "role": "operator",
                "scopes": ["exec:read"]
            }),
        };
        match dispatcher.handle_request(&rotate).await {
            RpcDispatchOutcome::Handled(payload) => {
                let token = payload
                    .pointer("/token")
                    .and_then(serde_json::Value::as_str)
                    .unwrap_or_default();
                assert!(token.starts_with("dtk_"));
                assert_eq!(
                    payload
                        .pointer("/scopes/0")
                        .and_then(serde_json::Value::as_str),
                    Some("exec:read")
                );
                assert!(payload
                    .pointer("/rotatedAtMs")
                    .and_then(serde_json::Value::as_u64)
                    .is_some());
            }
            _ => panic!("expected device.token.rotate handled"),
        }

        let revoke = RpcRequestFrame {
            id: "req-device-revoke".to_owned(),
            method: "device.token.revoke".to_owned(),
            params: serde_json::json!({
                "deviceId": "device-1",
                "role": "operator"
            }),
        };
        match dispatcher.handle_request(&revoke).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/deviceId")
                        .and_then(serde_json::Value::as_str),
                    Some("device-1")
                );
                assert!(payload
                    .pointer("/revokedAtMs")
                    .and_then(serde_json::Value::as_u64)
                    .is_some());
            }
            _ => panic!("expected device.token.revoke handled"),
        }

        let remove = RpcRequestFrame {
            id: "req-device-remove".to_owned(),
            method: "device.pair.remove".to_owned(),
            params: serde_json::json!({
                "deviceId": "device-1"
            }),
        };
        match dispatcher.handle_request(&remove).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/deviceId")
                        .and_then(serde_json::Value::as_str),
                    Some("device-1")
                );
            }
            _ => panic!("expected device.pair.remove handled"),
        }

        let rotate_missing = RpcRequestFrame {
            id: "req-device-rotate-missing".to_owned(),
            method: "device.token.rotate".to_owned(),
            params: serde_json::json!({
                "deviceId": "device-1",
                "role": "operator"
            }),
        };
        let out = dispatcher.handle_request(&rotate_missing).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "event": "device.pair.requested",
                "payload": {
                    "requestId": "pair-2",
                    "deviceId": "device-2",
                    "publicKey": "pubkey-2",
                    "ts": 654321
                }
            }))
            .await;

        let reject = RpcRequestFrame {
            id: "req-device-reject".to_owned(),
            method: "device.pair.reject".to_owned(),
            params: serde_json::json!({
                "requestId": "pair-2"
            }),
        };
        match dispatcher.handle_request(&reject).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/requestId")
                        .and_then(serde_json::Value::as_str),
                    Some("pair-2")
                );
                assert_eq!(
                    payload
                        .pointer("/deviceId")
                        .and_then(serde_json::Value::as_str),
                    Some("device-2")
                );
            }
            _ => panic!("expected device.pair.reject handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_device_pair_store_path_persists_and_recovers_devices_across_dispatchers() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-device-pair-store-{}", now_ms()));
        std::fs::create_dir_all(&root).expect("creating device pair temp root");
        let store_path = root.join("devices").join("pairs.json");
        let store_path_text = store_path.to_string_lossy().to_string();

        let dispatcher = RpcDispatcher::new();
        let get_primary_hash = RpcRequestFrame {
            id: "req-device-pair-store-config-hash".to_owned(),
            method: "config.get".to_owned(),
            params: serde_json::json!({}),
        };
        let primary_hash = match dispatcher.handle_request(&get_primary_hash).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/hash")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("config hash"),
            _ => panic!("expected config.get handled"),
        };
        let patch_primary = RpcRequestFrame {
            id: "req-device-pair-store-config".to_owned(),
            method: "config.patch".to_owned(),
            params: serde_json::json!({
                "baseHash": primary_hash,
                "raw": serde_json::json!({
                    "devicePair": {
                        "storePath": store_path_text
                    }
                })
                .to_string()
            }),
        };
        match dispatcher.handle_request(&patch_primary).await {
            RpcDispatchOutcome::Handled(_) => {}
            other => panic!("expected config.patch handled, got {other:?}"),
        }

        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "event": "device.pair.requested",
                "payload": {
                    "requestId": "pair-store-1",
                    "deviceId": "device-store-1",
                    "publicKey": "pub-store-1",
                    "displayName": "Store Device",
                    "role": "operator",
                    "roles": ["operator"],
                    "scopes": ["exec:read", "exec:write"],
                    "ts": 111222333
                }
            }))
            .await;

        let approve = RpcRequestFrame {
            id: "req-device-pair-store-approve".to_owned(),
            method: "device.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": "pair-store-1"
            }),
        };
        match dispatcher.handle_request(&approve).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/device/deviceId")
                        .and_then(serde_json::Value::as_str),
                    Some("device-store-1")
                );
            }
            _ => panic!("expected device.pair.approve handled"),
        }

        let rotate = RpcRequestFrame {
            id: "req-device-pair-store-rotate".to_owned(),
            method: "device.token.rotate".to_owned(),
            params: serde_json::json!({
                "deviceId": "device-store-1",
                "role": "operator",
                "scopes": ["exec:read"]
            }),
        };
        match dispatcher.handle_request(&rotate).await {
            RpcDispatchOutcome::Handled(payload) => {
                let token = payload
                    .pointer("/token")
                    .and_then(serde_json::Value::as_str)
                    .unwrap_or_default();
                assert!(token.starts_with("dtk_"));
            }
            _ => panic!("expected device.token.rotate handled"),
        }

        assert!(store_path.exists(), "device pair store should exist");
        let persisted =
            std::fs::read_to_string(&store_path).expect("reading persisted device pair store");
        assert!(
            persisted.contains("device-store-1"),
            "persisted device pair store should contain device id"
        );
        assert!(
            persisted.contains("operator"),
            "persisted device pair store should contain role metadata"
        );

        let dispatcher_restarted = RpcDispatcher::new();
        let get_secondary_hash = RpcRequestFrame {
            id: "req-device-pair-store-config-hash-restart".to_owned(),
            method: "config.get".to_owned(),
            params: serde_json::json!({}),
        };
        let secondary_hash = match dispatcher_restarted
            .handle_request(&get_secondary_hash)
            .await
        {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/hash")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("config hash"),
            _ => panic!("expected config.get handled"),
        };
        let patch_secondary = RpcRequestFrame {
            id: "req-device-pair-store-config-restart".to_owned(),
            method: "config.patch".to_owned(),
            params: serde_json::json!({
                "baseHash": secondary_hash,
                "raw": serde_json::json!({
                    "device": {
                        "pair": {
                            "storePath": store_path.to_string_lossy().to_string()
                        }
                    }
                })
                .to_string()
            }),
        };
        match dispatcher_restarted.handle_request(&patch_secondary).await {
            RpcDispatchOutcome::Handled(_) => {}
            other => panic!("expected config.patch handled, got {other:?}"),
        }

        let list = RpcRequestFrame {
            id: "req-device-pair-store-list".to_owned(),
            method: "device.pair.list".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher_restarted.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/paired/0/deviceId")
                        .and_then(serde_json::Value::as_str),
                    Some("device-store-1")
                );
                assert_eq!(
                    payload
                        .pointer("/paired/0/tokens/0/role")
                        .and_then(serde_json::Value::as_str),
                    Some("operator")
                );
            }
            _ => panic!("expected device.pair.list handled"),
        }

        let revoke = RpcRequestFrame {
            id: "req-device-pair-store-revoke".to_owned(),
            method: "device.token.revoke".to_owned(),
            params: serde_json::json!({
                "deviceId": "device-store-1",
                "role": "operator"
            }),
        };
        match dispatcher_restarted.handle_request(&revoke).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/deviceId")
                        .and_then(serde_json::Value::as_str),
                    Some("device-store-1")
                );
                assert!(payload
                    .pointer("/revokedAtMs")
                    .and_then(serde_json::Value::as_u64)
                    .is_some());
            }
            _ => panic!("expected device.token.revoke handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_pairing_methods_follow_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        let invalid_list = RpcRequestFrame {
            id: "req-node-list-invalid".to_owned(),
            method: "node.pair.list".to_owned(),
            params: serde_json::json!({
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&invalid_list).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let request = RpcRequestFrame {
            id: "req-node-request".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-1",
                "displayName": "Mac Mini",
                "platform": "darwin",
                "caps": ["browser", "camera"],
                "commands": ["browser.proxy"]
            }),
        };
        let request_id = match dispatcher.handle_request(&request).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("pending")
                );
                assert_eq!(
                    payload
                        .pointer("/created")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                payload
                    .pointer("/request/requestId")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("node pair request id")
            }
            _ => panic!("expected node.pair.request handled"),
        };

        match dispatcher.handle_request(&request).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/created")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/request/requestId")
                        .and_then(serde_json::Value::as_str),
                    Some(request_id.as_str())
                );
            }
            _ => panic!("expected duplicate node.pair.request handled"),
        }

        let list = RpcRequestFrame {
            id: "req-node-list".to_owned(),
            method: "node.pair.list".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/pending/0/requestId")
                        .and_then(serde_json::Value::as_str),
                    Some(request_id.as_str())
                );
            }
            _ => panic!("expected node.pair.list handled"),
        }

        let approve = RpcRequestFrame {
            id: "req-node-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id.clone()
            }),
        };
        let token = match dispatcher.handle_request(&approve).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/requestId")
                        .and_then(serde_json::Value::as_str),
                    Some(request_id.as_str())
                );
                let token = payload
                    .pointer("/node/token")
                    .and_then(serde_json::Value::as_str)
                    .unwrap_or_default();
                assert!(token.starts_with("ntk_"));
                token.to_owned()
            }
            _ => panic!("expected node.pair.approve handled"),
        };

        let verify_bad = RpcRequestFrame {
            id: "req-node-verify-bad".to_owned(),
            method: "node.pair.verify".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-1",
                "token": "bad-token"
            }),
        };
        match dispatcher.handle_request(&verify_bad).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected node.pair.verify handled"),
        }

        let verify_ok = RpcRequestFrame {
            id: "req-node-verify-ok".to_owned(),
            method: "node.pair.verify".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-1",
                "token": token
            }),
        };
        match dispatcher.handle_request(&verify_ok).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/node/nodeId")
                        .and_then(serde_json::Value::as_str),
                    Some("node-1")
                );
            }
            _ => panic!("expected node.pair.verify handled"),
        }

        let rename = RpcRequestFrame {
            id: "req-node-rename".to_owned(),
            method: "node.rename".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-1",
                "displayName": "Ops Node"
            }),
        };
        match dispatcher.handle_request(&rename).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/displayName")
                        .and_then(serde_json::Value::as_str),
                    Some("Ops Node")
                );
            }
            _ => panic!("expected node.rename handled"),
        }

        let node_list_invalid = RpcRequestFrame {
            id: "req-node-list-params-invalid".to_owned(),
            method: "node.list".to_owned(),
            params: serde_json::json!({
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&node_list_invalid).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let node_list = RpcRequestFrame {
            id: "req-node-list-live".to_owned(),
            method: "node.list".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&node_list).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/nodes/0/nodeId")
                        .and_then(serde_json::Value::as_str),
                    Some("node-1")
                );
                assert_eq!(
                    payload
                        .pointer("/nodes/0/paired")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/nodes/0/connected")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected node.list handled"),
        }

        let describe = RpcRequestFrame {
            id: "req-node-describe".to_owned(),
            method: "node.describe".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-1"
            }),
        };
        match dispatcher.handle_request(&describe).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/displayName")
                        .and_then(serde_json::Value::as_str),
                    Some("Ops Node")
                );
                assert_eq!(
                    payload
                        .pointer("/paired")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected node.describe handled"),
        }

        let describe_unknown = RpcRequestFrame {
            id: "req-node-describe-unknown".to_owned(),
            method: "node.describe".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-missing"
            }),
        };
        let out = dispatcher.handle_request(&describe_unknown).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        dispatcher
            .ingest_event_frame(&serde_json::json!({
                "event": "node.pair.requested",
                "payload": {
                    "requestId": "req-node-2",
                    "nodeId": "node-2",
                    "displayName": "Aux Node",
                    "ts": 11
                }
            }))
            .await;

        let reject = RpcRequestFrame {
            id: "req-node-reject".to_owned(),
            method: "node.pair.reject".to_owned(),
            params: serde_json::json!({
                "requestId": "req-node-2"
            }),
        };
        match dispatcher.handle_request(&reject).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/requestId")
                        .and_then(serde_json::Value::as_str),
                    Some("req-node-2")
                );
                assert_eq!(
                    payload
                        .pointer("/nodeId")
                        .and_then(serde_json::Value::as_str),
                    Some("node-2")
                );
            }
            _ => panic!("expected node.pair.reject handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_pair_store_path_persists_and_recovers_pairs_across_dispatchers() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-node-pair-store-{}", now_ms()));
        std::fs::create_dir_all(&root).expect("creating node pair temp root");
        let store_path = root.join("nodes").join("pairs.json");
        let store_path_text = store_path.to_string_lossy().to_string();

        let dispatcher = RpcDispatcher::new();
        let get_primary_hash = RpcRequestFrame {
            id: "req-node-pair-store-config-hash".to_owned(),
            method: "config.get".to_owned(),
            params: serde_json::json!({}),
        };
        let primary_hash = match dispatcher.handle_request(&get_primary_hash).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/hash")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("config hash"),
            _ => panic!("expected config.get handled"),
        };
        let patch_primary = RpcRequestFrame {
            id: "req-node-pair-store-config".to_owned(),
            method: "config.patch".to_owned(),
            params: serde_json::json!({
                "baseHash": primary_hash,
                "raw": serde_json::json!({
                    "nodePair": {
                        "storePath": store_path_text
                    }
                })
                .to_string()
            }),
        };
        match dispatcher.handle_request(&patch_primary).await {
            RpcDispatchOutcome::Handled(_) => {}
            other => panic!("expected config.patch handled, got {other:?}"),
        }

        let request = RpcRequestFrame {
            id: "req-node-pair-store-request".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-store-1",
                "displayName": "Store Node",
                "commands": ["browser.proxy"]
            }),
        };
        let request_id = match dispatcher.handle_request(&request).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("node pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };

        let approve = RpcRequestFrame {
            id: "req-node-pair-store-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let token = match dispatcher.handle_request(&approve).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/node/token")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("paired node token"),
            _ => panic!("expected node.pair.approve handled"),
        };

        assert!(store_path.exists(), "node pair store should exist");
        let persisted =
            std::fs::read_to_string(&store_path).expect("reading persisted node pair store");
        assert!(
            persisted.contains("node-store-1"),
            "persisted node pair store should contain node id"
        );

        let dispatcher_restarted = RpcDispatcher::new();
        let get_secondary_hash = RpcRequestFrame {
            id: "req-node-pair-store-config-hash-restart".to_owned(),
            method: "config.get".to_owned(),
            params: serde_json::json!({}),
        };
        let secondary_hash = match dispatcher_restarted
            .handle_request(&get_secondary_hash)
            .await
        {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/hash")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("config hash"),
            _ => panic!("expected config.get handled"),
        };
        let patch_secondary = RpcRequestFrame {
            id: "req-node-pair-store-config-restart".to_owned(),
            method: "config.patch".to_owned(),
            params: serde_json::json!({
                "baseHash": secondary_hash,
                "raw": serde_json::json!({
                    "node": {
                        "pair": {
                            "storePath": store_path.to_string_lossy().to_string()
                        }
                    }
                })
                .to_string()
            }),
        };
        match dispatcher_restarted.handle_request(&patch_secondary).await {
            RpcDispatchOutcome::Handled(_) => {}
            other => panic!("expected config.patch handled, got {other:?}"),
        }

        let list = RpcRequestFrame {
            id: "req-node-pair-store-list".to_owned(),
            method: "node.pair.list".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher_restarted.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/paired/0/nodeId")
                        .and_then(serde_json::Value::as_str),
                    Some("node-store-1")
                );
                assert_eq!(
                    payload
                        .pointer("/paired/0/token")
                        .and_then(serde_json::Value::as_str),
                    Some(token.as_str())
                );
            }
            _ => panic!("expected node.pair.list handled"),
        }

        let verify = RpcRequestFrame {
            id: "req-node-pair-store-verify".to_owned(),
            method: "node.pair.verify".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-store-1",
                "token": token
            }),
        };
        match dispatcher_restarted.handle_request(&verify).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected node.pair.verify handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_invoke_and_event_methods_follow_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        let pair_request = RpcRequestFrame {
            id: "req-node-invoke-pair-request".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-invoke-1",
                "commands": ["browser.proxy"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair_request).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let pair_approve = RpcRequestFrame {
            id: "req-node-invoke-pair-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&pair_approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let invoke_invalid = RpcRequestFrame {
            id: "req-node-invoke-invalid".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-invoke-1",
                "command": "browser.proxy"
            }),
        };
        let out = dispatcher.handle_request(&invoke_invalid).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let invoke_restricted = RpcRequestFrame {
            id: "req-node-invoke-restricted".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-invoke-1",
                "command": "system.execApprovals.get",
                "idempotencyKey": "idem-1"
            }),
        };
        let out = dispatcher.handle_request(&invoke_restricted).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let invoke_unknown = RpcRequestFrame {
            id: "req-node-invoke-unknown".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-missing",
                "command": "browser.proxy",
                "idempotencyKey": "idem-2"
            }),
        };
        match dispatcher.handle_request(&invoke_unknown).await {
            RpcDispatchOutcome::Error { code, details, .. } => {
                assert_eq!(code, 503);
                assert_eq!(
                    details
                        .as_ref()
                        .and_then(|value| value.pointer("/code"))
                        .and_then(serde_json::Value::as_str),
                    Some("NOT_CONNECTED")
                );
            }
            _ => panic!("expected node.invoke unavailable"),
        }

        let invoke_disallowed = RpcRequestFrame {
            id: "req-node-invoke-disallowed".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-invoke-1",
                "command": "camera.capture",
                "idempotencyKey": "idem-3"
            }),
        };
        let out = dispatcher.handle_request(&invoke_disallowed).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let invoke = RpcRequestFrame {
            id: "req-node-invoke".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-invoke-1",
                "command": "browser.proxy",
                "params": { "path": "/tabs" },
                "timeoutMs": 1500,
                "idempotencyKey": "idem-4"
            }),
        };
        let invoke_id = match dispatcher.handle_request(&invoke).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                payload
                    .pointer("/payload/invokeId")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("invoke id")
            }
            _ => panic!("expected node.invoke handled"),
        };

        let invoke_result_unknown = RpcRequestFrame {
            id: "req-node-invoke-result-unknown".to_owned(),
            method: "node.invoke.result".to_owned(),
            params: serde_json::json!({
                "id": "node-invoke-missing",
                "nodeId": "node-invoke-1",
                "ok": true
            }),
        };
        match dispatcher.handle_request(&invoke_result_unknown).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/ignored")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected ignored node.invoke.result"),
        }

        let invoke_result_mismatch = RpcRequestFrame {
            id: "req-node-invoke-result-mismatch".to_owned(),
            method: "node.invoke.result".to_owned(),
            params: serde_json::json!({
                "id": invoke_id.clone(),
                "nodeId": "node-other",
                "ok": true
            }),
        };
        let out = dispatcher.handle_request(&invoke_result_mismatch).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let invoke_result = RpcRequestFrame {
            id: "req-node-invoke-result".to_owned(),
            method: "node.invoke.result".to_owned(),
            params: serde_json::json!({
                "id": invoke_id,
                "nodeId": "node-invoke-1",
                "ok": true,
                "payloadJSON": { "status": "ok" }
            }),
        };
        match dispatcher.handle_request(&invoke_result).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert!(payload.pointer("/ignored").is_none());
            }
            _ => panic!("expected node.invoke.result handled"),
        }

        let node_event_invalid = RpcRequestFrame {
            id: "req-node-event-invalid".to_owned(),
            method: "node.event".to_owned(),
            params: serde_json::json!({
                "event": "node.heartbeat",
                "payloadJSON": { "bad": true }
            }),
        };
        let out = dispatcher.handle_request(&node_event_invalid).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let node_event = RpcRequestFrame {
            id: "req-node-event".to_owned(),
            method: "node.event".to_owned(),
            params: serde_json::json!({
                "event": "node.heartbeat",
                "payload": { "ok": true }
            }),
        };
        match dispatcher.handle_request(&node_event).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected node.event handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_policy_blocks_dangerous_commands_without_allowlist_override() {
        let dispatcher = RpcDispatcher::new();

        let pair = RpcRequestFrame {
            id: "req-node-policy-dangerous-block-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-policy-1",
                "platform": "macos",
                "commands": ["camera.snap"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-node-policy-dangerous-block-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&approve).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let invoke = RpcRequestFrame {
            id: "req-node-policy-dangerous-block-invoke".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-policy-1",
                "command": "camera.snap",
                "idempotencyKey": "node-policy-dangerous-block"
            }),
        };
        match dispatcher.handle_request(&invoke).await {
            RpcDispatchOutcome::Error {
                code,
                message,
                details,
            } => {
                assert_eq!(code, 400);
                assert_eq!(message, "node command not allowed");
                assert_eq!(
                    details
                        .as_ref()
                        .and_then(|value| value.pointer("/reason"))
                        .and_then(Value::as_str),
                    Some("command not allowlisted")
                );
            }
            _ => panic!("expected node.invoke rejection"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_event_push_apns_register_updates_registry() {
        let dispatcher = RpcDispatcher::new();
        let req = RpcRequestFrame {
            id: "req-node-event-push-register".to_owned(),
            method: "node.event".to_owned(),
            params: serde_json::json!({
                "event": "push.apns.register",
                "payload": {
                    "nodeId": "ios-node-1",
                    "token": "AABBCCDDEEFF00112233445566778899",
                    "topic": "ai.openclaw.ios",
                    "environment": "sandbox"
                }
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&req).await,
            RpcDispatchOutcome::Handled(_)
        ));
        let registration = dispatcher
            .apns
            .get("ios-node-1")
            .await
            .expect("registration");
        assert_eq!(registration.node_id, "ios-node-1");
        assert_eq!(registration.environment, "sandbox");
        assert_eq!(registration.topic, "ai.openclaw.ios");
        assert_eq!(registration.token, "aabbccddeeff00112233445566778899");
        assert_eq!(dispatcher.apns.count().await, 1);
    }

    #[tokio::test]
    async fn dispatcher_push_test_validates_and_requires_registration() {
        let dispatcher = RpcDispatcher::new();

        let invalid_shape = RpcRequestFrame {
            id: "req-push-test-invalid-shape".to_owned(),
            method: "push.test".to_owned(),
            params: serde_json::json!({
                "node": "ios-node-1"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&invalid_shape).await,
            RpcDispatchOutcome::Error { code: 400, .. }
        ));

        let invalid_environment = RpcRequestFrame {
            id: "req-push-test-invalid-env".to_owned(),
            method: "push.test".to_owned(),
            params: serde_json::json!({
                "nodeId": "ios-node-1",
                "environment": "staging"
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&invalid_environment).await,
            RpcDispatchOutcome::Error { code: 400, .. }
        ));

        let missing_registration = RpcRequestFrame {
            id: "req-push-test-missing-registration".to_owned(),
            method: "push.test".to_owned(),
            params: serde_json::json!({
                "nodeId": "ios-node-1"
            }),
        };
        match dispatcher.handle_request(&missing_registration).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 400);
                assert!(message.contains("has no APNs registration"));
            }
            _ => panic!("expected push.test missing-registration error"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_policy_allows_dangerous_commands_with_allowlist_override() {
        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "gateway": {
                    "nodes": {
                        "allowCommands": ["camera.snap"]
                    }
                }
            }),
        )
        .await;

        let pair = RpcRequestFrame {
            id: "req-node-policy-allow-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-policy-allow-1",
                "platform": "macos",
                "commands": ["camera.snap"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-node-policy-allow-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&approve).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let invoke = RpcRequestFrame {
            id: "req-node-policy-allow-invoke".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-policy-allow-1",
                "command": "camera.snap",
                "idempotencyKey": "node-policy-allow"
            }),
        };
        match dispatcher.handle_request(&invoke).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
            }
            _ => panic!("expected node.invoke handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_policy_deny_commands_override_allow_commands() {
        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "gateway": {
                    "nodes": {
                        "allowCommands": ["camera.snap"],
                        "denyCommands": ["camera.snap"]
                    }
                }
            }),
        )
        .await;

        let pair = RpcRequestFrame {
            id: "req-node-policy-deny-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-policy-deny-1",
                "platform": "macos",
                "commands": ["camera.snap"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-node-policy-deny-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&approve).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let invoke = RpcRequestFrame {
            id: "req-node-policy-deny-invoke".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-policy-deny-1",
                "command": "camera.snap",
                "idempotencyKey": "node-policy-deny"
            }),
        };
        match dispatcher.handle_request(&invoke).await {
            RpcDispatchOutcome::Error {
                code,
                message,
                details,
            } => {
                assert_eq!(code, 400);
                assert_eq!(message, "node command not allowed");
                assert_eq!(
                    details
                        .as_ref()
                        .and_then(|value| value.pointer("/reason"))
                        .and_then(Value::as_str),
                    Some("command not allowlisted")
                );
            }
            _ => panic!("expected node.invoke rejection"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_pair_request_infers_safe_default_commands_when_missing() {
        let dispatcher = RpcDispatcher::new();

        let pair = RpcRequestFrame {
            id: "req-node-default-commands-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-default-commands-1",
                "platform": "linux"
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-node-default-commands-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&approve).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let describe = RpcRequestFrame {
            id: "req-node-default-commands-describe".to_owned(),
            method: "node.describe".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-default-commands-1"
            }),
        };
        match dispatcher.handle_request(&describe).await {
            RpcDispatchOutcome::Handled(payload) => {
                let commands = payload
                    .pointer("/commands")
                    .and_then(Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(commands
                    .iter()
                    .any(|value| value.as_str() == Some("system.which")));
                assert!(commands
                    .iter()
                    .any(|value| value.as_str() == Some("browser.proxy")));
                assert!(!commands
                    .iter()
                    .any(|value| value.as_str() == Some("camera.snap")));
            }
            _ => panic!("expected node.describe handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_pair_capability_inference_scopes_declared_commands() {
        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "nodeHost": {
                    "localNodeIds": ["node-capability-commands-1"]
                }
            }),
        )
        .await;

        let pair = RpcRequestFrame {
            id: "req-node-capability-commands-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-capability-commands-1",
                "platform": "macos",
                "caps": ["location"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-node-capability-commands-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        assert!(matches!(
            dispatcher.handle_request(&approve).await,
            RpcDispatchOutcome::Handled(_)
        ));

        let describe = RpcRequestFrame {
            id: "req-node-capability-commands-describe".to_owned(),
            method: "node.describe".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-capability-commands-1"
            }),
        };
        match dispatcher.handle_request(&describe).await {
            RpcDispatchOutcome::Handled(payload) => {
                let commands = payload
                    .pointer("/commands")
                    .and_then(Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(commands
                    .iter()
                    .any(|value| value.as_str() == Some("location.get")));
                assert!(!commands
                    .iter()
                    .any(|value| value.as_str() == Some("system.run")));
                assert!(!commands
                    .iter()
                    .any(|value| value.as_str() == Some("browser.proxy")));
            }
            _ => panic!("expected node.describe handled"),
        }

        let invoke_location = RpcRequestFrame {
            id: "req-node-capability-commands-invoke-location".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-capability-commands-1",
                "command": "location.get",
                "idempotencyKey": "node-capability-location"
            }),
        };
        match dispatcher.handle_request(&invoke_location).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
            }
            _ => panic!("expected location.get invoke handled"),
        }

        let invoke_system = RpcRequestFrame {
            id: "req-node-capability-commands-invoke-system".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-capability-commands-1",
                "command": "system.run",
                "params": { "command": "echo should-block" },
                "idempotencyKey": "node-capability-system"
            }),
        };
        match dispatcher.handle_request(&invoke_system).await {
            RpcDispatchOutcome::Error {
                code,
                message,
                details,
            } => {
                assert_eq!(code, 400);
                assert_eq!(message, "node command not allowed");
                assert_eq!(
                    details
                        .as_ref()
                        .and_then(|value| value.pointer("/reason"))
                        .and_then(Value::as_str),
                    Some("command not declared by node")
                );
            }
            _ => panic!("expected system.run invoke rejection"),
        }
    }

    #[tokio::test]
    async fn dispatcher_node_invoke_supports_camera_screen_location_and_system_commands_when_declared(
    ) {
        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "gateway": {
                    "nodes": {
                        "allowCommands": [
                            "camera.snap",
                            "camera.clip",
                            "screen.record",
                            "contacts.add",
                            "calendar.add",
                            "reminders.add",
                            "sms.send"
                        ]
                    }
                }
            }),
        )
        .await;

        let pair_request = RpcRequestFrame {
            id: "req-node-sensors-pair-request".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-sensors-1",
                "platform": "macos",
                "commands": [
                    "camera.list",
                    "camera.snap",
                    "camera.clip",
                    "screen.record",
                    "location.get",
                    "device.info",
                    "device.status",
                    "contacts.search",
                    "contacts.add",
                    "calendar.events",
                    "calendar.add",
                    "reminders.list",
                    "reminders.add",
                    "photos.latest",
                    "motion.activity",
                    "motion.pedometer",
                    "sms.send",
                    "canvas.hide",
                    "canvas.navigate",
                    "canvas.eval",
                    "canvas.snapshot",
                    "canvas.a2ui.push",
                    "canvas.a2ui.pushJSONL",
                    "canvas.a2ui.reset",
                    "system.run",
                    "system.which",
                    "system.notify"
                ]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair_request).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let pair_approve = RpcRequestFrame {
            id: "req-node-sensors-pair-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&pair_approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        for (idx, (command, params)) in [
            ("camera.list", serde_json::json!({})),
            ("camera.snap", serde_json::json!({ "quality": "high" })),
            (
                "camera.clip",
                serde_json::json!({ "durationMs": 1200, "includeAudio": false }),
            ),
            ("screen.record", serde_json::json!({ "seconds": 1 })),
            ("location.get", serde_json::json!({})),
            ("device.info", serde_json::json!({})),
            ("device.status", serde_json::json!({})),
            ("contacts.search", serde_json::json!({ "query": "ops" })),
            (
                "contacts.add",
                serde_json::json!({ "name": "Ops Contact", "phone": "+15550002222" }),
            ),
            ("calendar.events", serde_json::json!({})),
            (
                "calendar.add",
                serde_json::json!({
                    "title": "Ops Review",
                    "startTime": "2026-02-21T21:00:00Z"
                }),
            ),
            ("reminders.list", serde_json::json!({})),
            (
                "reminders.add",
                serde_json::json!({
                    "title": "Ship parity",
                    "dueTime": "2026-02-22T09:00:00Z"
                }),
            ),
            ("photos.latest", serde_json::json!({ "limit": 2 })),
            ("motion.activity", serde_json::json!({})),
            ("motion.pedometer", serde_json::json!({})),
            (
                "sms.send",
                serde_json::json!({
                    "to": "+15550003333",
                    "message": "parity gate notification"
                }),
            ),
            ("canvas.hide", serde_json::json!({})),
            (
                "canvas.navigate",
                serde_json::json!({ "url": "https://example.com/node" }),
            ),
            ("canvas.eval", serde_json::json!({ "script": "return 1" })),
            ("canvas.snapshot", serde_json::json!({})),
            (
                "canvas.a2ui.push",
                serde_json::json!({ "items": [{ "id": "card-1" }] }),
            ),
            (
                "canvas.a2ui.pushJSONL",
                serde_json::json!({ "jsonl": "{\"id\":\"card-1\"}\n{\"id\":\"card-2\"}\n" }),
            ),
            ("canvas.a2ui.reset", serde_json::json!({})),
            (
                "system.run",
                serde_json::json!({
                    "command": "echo cp5"
                }),
            ),
            (
                "system.which",
                serde_json::json!({
                    "bins": [if cfg!(windows) { "cmd" } else { "sh" }]
                }),
            ),
            (
                "system.notify",
                serde_json::json!({
                    "title": "cp5",
                    "body": "notify path"
                }),
            ),
        ]
        .into_iter()
        .enumerate()
        {
            let invoke = RpcRequestFrame {
                id: format!("req-node-sensors-invoke-{idx}"),
                method: "node.invoke".to_owned(),
                params: serde_json::json!({
                    "nodeId": "node-sensors-1",
                    "command": command,
                    "params": params,
                    "idempotencyKey": format!("idem-node-sensors-{idx}")
                }),
            };
            match dispatcher.handle_request(&invoke).await {
                RpcDispatchOutcome::Handled(payload) => {
                    assert_eq!(
                        payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                        Some(true)
                    );
                    assert_eq!(
                        payload
                            .pointer("/command")
                            .and_then(serde_json::Value::as_str),
                        Some(command)
                    );
                    assert!(payload
                        .pointer("/payload/invokeId")
                        .and_then(serde_json::Value::as_str)
                        .is_some());
                }
                _ => panic!("expected node.invoke handled for {command}"),
            }
        }
    }

    #[tokio::test]
    async fn dispatcher_local_node_host_runtime_completes_node_invoke_commands_in_process() {
        let dispatcher = RpcDispatcher::new();
        patch_config(
            &dispatcher,
            json!({
                "gateway": {
                    "nodes": {
                        "allowCommands": [
                            "camera.snap",
                            "camera.clip",
                            "contacts.add",
                            "calendar.add",
                            "reminders.add",
                            "sms.send"
                        ]
                    }
                },
                "nodeHost": {
                    "localNodeIds": ["local-node-runtime-1"],
                    "allowSystemRun": true
                }
            }),
        )
        .await;

        let pair = RpcRequestFrame {
            id: "req-local-node-runtime-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "platform": "macos",
                "displayName": "Local Host Runtime Node",
                "caps": ["host.local"],
                "commands": [
                    "camera.list",
                    "camera.snap",
                    "camera.clip",
                    "location.get",
                    "device.info",
                    "device.status",
                    "contacts.search",
                    "contacts.add",
                    "calendar.events",
                    "calendar.add",
                    "reminders.list",
                    "reminders.add",
                    "photos.latest",
                    "motion.activity",
                    "motion.pedometer",
                    "sms.send",
                    "canvas.hide",
                    "canvas.navigate",
                    "canvas.eval",
                    "canvas.snapshot",
                    "canvas.a2ui.push",
                    "canvas.a2ui.pushJSONL",
                    "canvas.a2ui.reset",
                    "system.run",
                    "system.which",
                    "system.notify"
                ]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-local-node-runtime-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let invoke_system = RpcRequestFrame {
            id: "req-local-node-runtime-system-run".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "system.run",
                "params": {
                    "command": "echo local-host-runtime"
                },
                "idempotencyKey": "local-node-system-run"
            }),
        };
        match dispatcher.handle_request(&invoke_system).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
                assert_eq!(
                    payload.pointer("/payload/status").and_then(Value::as_str),
                    Some("completed")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/exitCode")
                        .and_then(Value::as_i64),
                    Some(0)
                );
            }
            _ => panic!("expected node.invoke handled"),
        }
        assert!(
            dispatcher
                .node_runtime
                .latest_pending_invoke_id()
                .await
                .is_none(),
            "local node invoke should not leave pending invokes"
        );

        let invoke_camera = RpcRequestFrame {
            id: "req-local-node-runtime-camera".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "camera.snap",
                "params": {
                    "quality": "high"
                },
                "idempotencyKey": "local-node-camera"
            }),
        };
        match dispatcher.handle_request(&invoke_camera).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
                assert_eq!(
                    payload
                        .pointer("/payload/result/source")
                        .and_then(Value::as_str),
                    Some("local-host-runtime")
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_camera_clip = RpcRequestFrame {
            id: "req-local-node-runtime-camera-clip".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "camera.clip",
                "params": {
                    "durationMs": 1500,
                    "includeAudio": false
                },
                "idempotencyKey": "local-node-camera-clip"
            }),
        };
        match dispatcher.handle_request(&invoke_camera_clip).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/format")
                        .and_then(Value::as_str),
                    Some("mp4")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/hasAudio")
                        .and_then(Value::as_bool),
                    Some(false)
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/durationMs")
                        .and_then(Value::as_u64),
                    Some(1500)
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_camera_list = RpcRequestFrame {
            id: "req-local-node-runtime-camera-list".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "camera.list",
                "params": {},
                "idempotencyKey": "local-node-camera-list"
            }),
        };
        match dispatcher.handle_request(&invoke_camera_list).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/count")
                        .and_then(Value::as_u64),
                    Some(2)
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/cameras/0/id")
                        .and_then(Value::as_str),
                    Some("camera-front")
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_device_status = RpcRequestFrame {
            id: "req-local-node-runtime-device-status".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "device.status",
                "params": {},
                "idempotencyKey": "local-node-device-status"
            }),
        };
        match dispatcher.handle_request(&invoke_device_status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/online")
                        .and_then(Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/batteryPercent")
                        .and_then(Value::as_u64),
                    Some(100)
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_contacts_add = RpcRequestFrame {
            id: "req-local-node-runtime-contacts-add".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "contacts.add",
                "params": {
                    "name": "Ops Contact",
                    "phone": "+15550002222"
                },
                "idempotencyKey": "local-node-contacts-add"
            }),
        };
        match dispatcher.handle_request(&invoke_contacts_add).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/contact/name")
                        .and_then(Value::as_str),
                    Some("Ops Contact")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/contact/phone")
                        .and_then(Value::as_str),
                    Some("+15550002222")
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_calendar_add = RpcRequestFrame {
            id: "req-local-node-runtime-calendar-add".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "calendar.add",
                "params": {
                    "title": "Ops Review",
                    "startTime": "2026-02-21T21:00:00Z"
                },
                "idempotencyKey": "local-node-calendar-add"
            }),
        };
        match dispatcher.handle_request(&invoke_calendar_add).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/event/title")
                        .and_then(Value::as_str),
                    Some("Ops Review")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/event/startTime")
                        .and_then(Value::as_str),
                    Some("2026-02-21T21:00:00Z")
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_reminders_add = RpcRequestFrame {
            id: "req-local-node-runtime-reminders-add".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "reminders.add",
                "params": {
                    "title": "Ship parity",
                    "dueTime": "2026-02-22T09:00:00Z"
                },
                "idempotencyKey": "local-node-reminders-add"
            }),
        };
        match dispatcher.handle_request(&invoke_reminders_add).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/reminder/title")
                        .and_then(Value::as_str),
                    Some("Ship parity")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/reminder/dueTime")
                        .and_then(Value::as_str),
                    Some("2026-02-22T09:00:00Z")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/reminder/completed")
                        .and_then(Value::as_bool),
                    Some(false)
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_photos_latest = RpcRequestFrame {
            id: "req-local-node-runtime-photos-latest".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "photos.latest",
                "params": {
                    "limit": 2
                },
                "idempotencyKey": "local-node-photos-latest"
            }),
        };
        match dispatcher.handle_request(&invoke_photos_latest).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/count")
                        .and_then(Value::as_u64),
                    Some(2)
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/photos/1/id")
                        .and_then(Value::as_str),
                    Some("photo-1")
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_sms_send = RpcRequestFrame {
            id: "req-local-node-runtime-sms-send".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "sms.send",
                "params": {
                    "to": "+15550003333",
                    "message": "parity gate notification"
                },
                "idempotencyKey": "local-node-sms-send"
            }),
        };
        match dispatcher.handle_request(&invoke_sms_send).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/to")
                        .and_then(Value::as_str),
                    Some("+15550003333")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/message")
                        .and_then(Value::as_str),
                    Some("parity gate notification")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/queued")
                        .and_then(Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_canvas_snapshot = RpcRequestFrame {
            id: "req-local-node-runtime-canvas-snapshot".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "canvas.snapshot",
                "params": {},
                "idempotencyKey": "local-node-canvas-snapshot"
            }),
        };
        match dispatcher.handle_request(&invoke_canvas_snapshot).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/mimeType")
                        .and_then(Value::as_str),
                    Some("image/png")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/bytes")
                        .and_then(Value::as_u64),
                    Some(0)
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_which = RpcRequestFrame {
            id: "req-local-node-runtime-system-which".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "system.which",
                "params": {
                    "bins": [if cfg!(windows) { "cmd" } else { "sh" }]
                },
                "idempotencyKey": "local-node-system-which"
            }),
        };
        match dispatcher.handle_request(&invoke_which).await {
            RpcDispatchOutcome::Handled(payload) => {
                let resolved = if cfg!(windows) {
                    payload.pointer("/payload/result/bins/cmd")
                } else {
                    payload.pointer("/payload/result/bins/sh")
                };
                assert!(
                    resolved.and_then(Value::as_str).is_some(),
                    "system.which should resolve a shell binary"
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_notify = RpcRequestFrame {
            id: "req-local-node-runtime-system-notify".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-runtime-1",
                "command": "system.notify",
                "params": {
                    "title": "Local Host Runtime",
                    "body": "notification parity",
                    "priority": "timeSensitive",
                    "delivery": "overlay"
                },
                "idempotencyKey": "local-node-system-notify"
            }),
        };
        match dispatcher.handle_request(&invoke_notify).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(payload
                    .pointer("/payload/result/notificationId")
                    .and_then(Value::as_str)
                    .is_some());
                assert_eq!(
                    payload
                        .pointer("/payload/result/title")
                        .and_then(Value::as_str),
                    Some("Local Host Runtime")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/priority")
                        .and_then(Value::as_str),
                    Some("timeSensitive")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/delivery")
                        .and_then(Value::as_str),
                    Some("overlay")
                );
            }
            _ => panic!("expected node.invoke handled"),
        }

        let invoke_system_argv = RpcRequestFrame {
            id: "req-local-node-runtime-system-run-argv".to_owned(),
            method: "node.invoke".to_owned(),
            params: if cfg!(windows) {
                serde_json::json!({
                    "nodeId": "local-node-runtime-1",
                    "command": "system.run",
                    "params": {
                        "command": ["cmd", "/C", "echo local-host-argv"],
                        "rawCommand": "echo local-host-argv",
                        "env": {
                            "OPENCLAW_RS_TEST_ENV": "true",
                            "PATH": "ignored"
                        },
                        "timeoutMs": 5000
                    },
                    "idempotencyKey": "local-node-system-run-argv"
                })
            } else {
                serde_json::json!({
                    "nodeId": "local-node-runtime-1",
                    "command": "system.run",
                    "params": {
                        "command": ["sh", "-lc", "echo local-host-argv"],
                        "rawCommand": "echo local-host-argv",
                        "env": {
                            "OPENCLAW_RS_TEST_ENV": "true",
                            "PATH": "ignored"
                        },
                        "timeoutMs": 5000
                    },
                    "idempotencyKey": "local-node-system-run-argv"
                })
            },
        };
        match dispatcher.handle_request(&invoke_system_argv).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/payload/result/command")
                        .and_then(Value::as_str),
                    Some("echo local-host-argv")
                );
                let stdout = payload
                    .pointer("/payload/result/stdout")
                    .and_then(Value::as_str)
                    .unwrap_or_default()
                    .to_ascii_lowercase();
                assert!(stdout.contains("local-host-argv"));
                assert_eq!(
                    payload
                        .pointer("/payload/result/ignoredEnvKeys/0")
                        .and_then(Value::as_str),
                    Some("PATH")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/timeoutMs")
                        .and_then(Value::as_u64),
                    Some(5000)
                );
            }
            other => panic!("expected node.invoke handled, got {other:?}"),
        }
    }

    #[tokio::test]
    async fn dispatcher_local_node_host_runtime_can_delegate_to_external_process() {
        let dispatcher = RpcDispatcher::new();
        let (external_command, external_args): (&str, Vec<&str>) = if cfg!(windows) {
            ("cmd", vec!["/C", "echo %OPENCLAW_NODE_HOST_REQUEST%"])
        } else {
            (
                "sh",
                vec!["-lc", "printf '%s' \"$OPENCLAW_NODE_HOST_REQUEST\""],
            )
        };
        patch_config(
            &dispatcher,
            json!({
                "nodeHost": {
                    "localNodeIds": ["local-node-external-1"],
                    "externalCommand": external_command,
                    "externalArgs": external_args
                }
            }),
        )
        .await;

        let pair = RpcRequestFrame {
            id: "req-local-node-external-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-external-1",
                "displayName": "Local External Runtime Node",
                "caps": ["host.local"],
                "commands": ["location.get"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-local-node-external-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let invoke = RpcRequestFrame {
            id: "req-local-node-external-invoke".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-external-1",
                "command": "location.get",
                "params": {},
                "idempotencyKey": "local-node-external-location"
            }),
        };
        match dispatcher.handle_request(&invoke).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
                assert_eq!(
                    payload
                        .pointer("/payload/result/command")
                        .and_then(Value::as_str),
                    Some("location.get")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/nodeId")
                        .and_then(Value::as_str),
                    Some("local-node-external-1")
                );
            }
            _ => panic!("expected node.invoke handled"),
        }
        assert!(
            dispatcher
                .node_runtime
                .latest_pending_invoke_id()
                .await
                .is_none(),
            "external local runtime should not leave pending invokes"
        );
    }

    #[tokio::test]
    async fn dispatcher_local_node_host_runtime_command_override_map_routes_by_command() {
        let dispatcher = RpcDispatcher::new();
        let (global_command, global_args, mapped_command, mapped_args): (
            &str,
            Vec<&str>,
            &str,
            Vec<&str>,
        ) = if cfg!(windows) {
            (
                "cmd",
                vec!["/C", "exit 1"],
                "cmd",
                vec!["/C", "echo %OPENCLAW_NODE_HOST_REQUEST%"],
            )
        } else {
            (
                "sh",
                vec!["-lc", "exit 1"],
                "sh",
                vec!["-lc", "printf '%s' \"$OPENCLAW_NODE_HOST_REQUEST\""],
            )
        };
        patch_config(
            &dispatcher,
            json!({
                "nodeHost": {
                    "localNodeIds": ["local-node-external-map-1"],
                    "externalCommand": global_command,
                    "externalArgs": global_args,
                    "externalCommands": {
                        "location.get": {
                            "command": mapped_command,
                            "args": mapped_args
                        }
                    }
                }
            }),
        )
        .await;

        let pair = RpcRequestFrame {
            id: "req-local-node-external-map-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-external-map-1",
                "displayName": "Local External Runtime Map Node",
                "caps": ["host.local"],
                "commands": ["location.get"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-local-node-external-map-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let invoke = RpcRequestFrame {
            id: "req-local-node-external-map-invoke".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-external-map-1",
                "command": "location.get",
                "params": {},
                "idempotencyKey": "local-node-external-map-location"
            }),
        };
        match dispatcher.handle_request(&invoke).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
                assert_eq!(
                    payload
                        .pointer("/payload/result/command")
                        .and_then(Value::as_str),
                    Some("location.get")
                );
            }
            _ => panic!("expected node.invoke handled"),
        }
        assert!(
            dispatcher
                .node_runtime
                .latest_pending_invoke_id()
                .await
                .is_none(),
            "external-map local runtime should not leave pending invokes"
        );
    }

    #[tokio::test]
    async fn dispatcher_local_node_host_runtime_platform_override_routes_by_node_platform() {
        let dispatcher = RpcDispatcher::new();
        let (fallback_command, fallback_args, ios_command, ios_args): (
            &str,
            Vec<&str>,
            &str,
            Vec<&str>,
        ) = if cfg!(windows) {
            (
                "cmd",
                vec!["/C", "exit 1"],
                "cmd",
                vec!["/C", "echo %OPENCLAW_NODE_HOST_REQUEST%"],
            )
        } else {
            (
                "sh",
                vec!["-lc", "exit 1"],
                "sh",
                vec!["-lc", "printf '%s' \"$OPENCLAW_NODE_HOST_REQUEST\""],
            )
        };
        patch_config(
            &dispatcher,
            json!({
                "nodeHost": {
                    "localNodeIds": ["local-node-platform-ios-1", "local-node-platform-android-1"],
                    "externalCommand": fallback_command,
                    "externalArgs": fallback_args,
                    "externalPlatforms": {
                        "ios": {
                            "command": ios_command,
                            "args": ios_args
                        }
                    }
                }
            }),
        )
        .await;

        for (node_id, platform) in [
            ("local-node-platform-ios-1", "ios"),
            ("local-node-platform-android-1", "android"),
        ] {
            let pair = RpcRequestFrame {
                id: format!("req-local-node-platform-pair-{platform}"),
                method: "node.pair.request".to_owned(),
                params: serde_json::json!({
                    "nodeId": node_id,
                    "platform": platform,
                    "displayName": format!("Local Platform Runtime Node {platform}"),
                    "caps": ["host.local"],
                    "commands": ["location.get"]
                }),
            };
            let request_id = match dispatcher.handle_request(&pair).await {
                RpcDispatchOutcome::Handled(payload) => payload
                    .pointer("/request/requestId")
                    .and_then(Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("pair request id"),
                _ => panic!("expected node.pair.request handled"),
            };
            let approve = RpcRequestFrame {
                id: format!("req-local-node-platform-approve-{platform}"),
                method: "node.pair.approve".to_owned(),
                params: serde_json::json!({
                    "requestId": request_id
                }),
            };
            assert!(matches!(
                dispatcher.handle_request(&approve).await,
                RpcDispatchOutcome::Handled(_)
            ));
        }

        let invoke_ios = RpcRequestFrame {
            id: "req-local-node-platform-invoke-ios".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-platform-ios-1",
                "command": "location.get",
                "params": {},
                "idempotencyKey": "local-node-platform-ios-location"
            }),
        };
        match dispatcher.handle_request(&invoke_ios).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
                assert_eq!(
                    payload
                        .pointer("/payload/result/nodeId")
                        .and_then(Value::as_str),
                    Some("local-node-platform-ios-1")
                );
            }
            _ => panic!("expected ios node.invoke handled"),
        }

        let invoke_android = RpcRequestFrame {
            id: "req-local-node-platform-invoke-android".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-platform-android-1",
                "command": "location.get",
                "params": {},
                "idempotencyKey": "local-node-platform-android-location"
            }),
        };
        match dispatcher.handle_request(&invoke_android).await {
            RpcDispatchOutcome::Error { code, message, .. } => {
                assert_eq!(code, 503);
                assert!(
                    message.contains("external host runtime")
                        || message.contains("external-host")
                        || message.contains("failed"),
                    "{message}"
                );
            }
            _ => panic!("expected android node.invoke failure from fallback external command"),
        }
    }

    #[tokio::test]
    async fn dispatcher_local_node_host_runtime_command_override_can_run_without_global_command() {
        let dispatcher = RpcDispatcher::new();
        let (mapped_command, mapped_args): (&str, Vec<&str>) = if cfg!(windows) {
            ("cmd", vec!["/C", "echo %OPENCLAW_NODE_HOST_REQUEST%"])
        } else {
            (
                "sh",
                vec!["-lc", "printf '%s' \"$OPENCLAW_NODE_HOST_REQUEST\""],
            )
        };
        patch_config(
            &dispatcher,
            json!({
                "nodeHost": {
                    "localNodeIds": ["local-node-external-map-only-1"],
                    "externalCommands": {
                        "location.get": {
                            "command": mapped_command,
                            "args": mapped_args
                        }
                    }
                }
            }),
        )
        .await;

        let pair = RpcRequestFrame {
            id: "req-local-node-external-map-only-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-external-map-only-1",
                "displayName": "Local External Runtime Map Only Node",
                "caps": ["host.local"],
                "commands": ["location.get"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-local-node-external-map-only-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let invoke = RpcRequestFrame {
            id: "req-local-node-external-map-only-invoke".to_owned(),
            method: "node.invoke".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-external-map-only-1",
                "command": "location.get",
                "params": {},
                "idempotencyKey": "local-node-external-map-only-location"
            }),
        };
        match dispatcher.handle_request(&invoke).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
                assert_eq!(
                    payload
                        .pointer("/payload/result/command")
                        .and_then(Value::as_str),
                    Some("location.get")
                );
                assert_eq!(
                    payload
                        .pointer("/payload/result/nodeId")
                        .and_then(Value::as_str),
                    Some("local-node-external-map-only-1")
                );
            }
            _ => panic!("expected node.invoke handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_local_node_host_runtime_persistent_external_process_reuses_session() {
        let dispatcher = RpcDispatcher::new();
        let (external_command, external_args): (&str, Vec<&str>) = if cfg!(windows) {
            (
                "powershell",
                vec![
                    "-NoProfile",
                    "-Command",
                    "$reader=[Console]::In; while(($line=$reader.ReadLine()) -ne $null){ [Console]::Out.WriteLine($line) }",
                ],
            )
        } else {
            (
                "sh",
                vec![
                    "-lc",
                    "while IFS= read -r line; do printf '%s\\n' \"$line\"; done",
                ],
            )
        };
        patch_config(
            &dispatcher,
            json!({
                "nodeHost": {
                    "localNodeIds": ["local-node-external-persistent-1"],
                    "externalCommand": external_command,
                    "externalArgs": external_args,
                    "externalPersistent": true,
                    "externalQueueCapacity": 8,
                    "externalIdleTimeoutMs": 60000
                }
            }),
        )
        .await;

        let pair = RpcRequestFrame {
            id: "req-local-node-external-persistent-pair".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "local-node-external-persistent-1",
                "displayName": "Local External Persistent Runtime Node",
                "caps": ["host.local"],
                "commands": ["location.get"]
            }),
        };
        let request_id = match dispatcher.handle_request(&pair).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let approve = RpcRequestFrame {
            id: "req-local-node-external-persistent-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        for idx in 0..2 {
            let invoke = RpcRequestFrame {
                id: format!("req-local-node-external-persistent-invoke-{idx}"),
                method: "node.invoke".to_owned(),
                params: serde_json::json!({
                    "nodeId": "local-node-external-persistent-1",
                    "command": "location.get",
                    "params": {
                        "index": idx
                    },
                    "idempotencyKey": format!("local-node-external-persistent-location-{idx}")
                }),
            };
            match dispatcher.handle_request(&invoke).await {
                RpcDispatchOutcome::Handled(payload) => {
                    assert_eq!(payload.pointer("/ok").and_then(Value::as_bool), Some(true));
                    assert_eq!(
                        payload
                            .pointer("/payload/result/command")
                            .and_then(Value::as_str),
                        Some("location.get")
                    );
                    assert_eq!(
                        payload
                            .pointer("/payload/result/nodeId")
                            .and_then(Value::as_str),
                        Some("local-node-external-persistent-1")
                    );
                }
                _ => panic!("expected node.invoke handled"),
            }
        }

        assert_eq!(dispatcher.node_host_runtime.active_session_count().await, 1);
    }

    #[tokio::test]
    async fn dispatcher_exec_approvals_methods_follow_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        let invalid_get = RpcRequestFrame {
            id: "req-exec-approvals-get-invalid".to_owned(),
            method: "exec.approvals.get".to_owned(),
            params: serde_json::json!({
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&invalid_get).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let get = RpcRequestFrame {
            id: "req-exec-approvals-get".to_owned(),
            method: "exec.approvals.get".to_owned(),
            params: serde_json::json!({}),
        };
        let global_hash = match dispatcher.handle_request(&get).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/path").and_then(serde_json::Value::as_str),
                    Some(super::EXEC_APPROVALS_GLOBAL_PATH)
                );
                assert_eq!(
                    payload
                        .pointer("/exists")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/file/version")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert!(payload.pointer("/file/socket/token").is_none());
                payload
                    .pointer("/hash")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("exec approvals hash")
            }
            _ => panic!("expected exec.approvals.get handled"),
        };

        let set_missing_base_hash = RpcRequestFrame {
            id: "req-exec-approvals-set-no-base".to_owned(),
            method: "exec.approvals.set".to_owned(),
            params: serde_json::json!({
                "file": {
                    "version": 1,
                    "agents": {}
                }
            }),
        };
        let out = dispatcher.handle_request(&set_missing_base_hash).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let set_stale_hash = RpcRequestFrame {
            id: "req-exec-approvals-set-stale".to_owned(),
            method: "exec.approvals.set".to_owned(),
            params: serde_json::json!({
                "baseHash": "stale",
                "file": {
                    "version": 1,
                    "agents": {}
                }
            }),
        };
        let out = dispatcher.handle_request(&set_stale_hash).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let set = RpcRequestFrame {
            id: "req-exec-approvals-set".to_owned(),
            method: "exec.approvals.set".to_owned(),
            params: serde_json::json!({
                "baseHash": global_hash,
                "file": {
                    "version": 1,
                    "defaults": {
                        "security": "allowlist",
                        "ask": "on-miss"
                    },
                    "agents": {
                        "main": {
                            "allowlist": [
                                { "pattern": "git status" }
                            ]
                        }
                    }
                }
            }),
        };
        let updated_global_hash = match dispatcher.handle_request(&set).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/file/defaults/security")
                        .and_then(serde_json::Value::as_str),
                    Some("allowlist")
                );
                assert_eq!(
                    payload
                        .pointer("/file/agents/main/allowlist/0/pattern")
                        .and_then(serde_json::Value::as_str),
                    Some("git status")
                );
                assert!(payload.pointer("/file/socket/token").is_none());
                payload
                    .pointer("/hash")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("updated exec approvals hash")
            }
            _ => panic!("expected exec.approvals.set handled"),
        };

        let disconnected_node_get = RpcRequestFrame {
            id: "req-exec-approvals-node-get-disconnected".to_owned(),
            method: "exec.approvals.node.get".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-exec-missing"
            }),
        };
        match dispatcher.handle_request(&disconnected_node_get).await {
            RpcDispatchOutcome::Error { code, details, .. } => {
                assert_eq!(code, 503);
                assert_eq!(
                    details
                        .as_ref()
                        .and_then(|value| value.pointer("/code"))
                        .and_then(serde_json::Value::as_str),
                    Some("NOT_CONNECTED")
                );
            }
            _ => panic!("expected exec.approvals.node.get unavailable"),
        }

        let pair_request = RpcRequestFrame {
            id: "req-exec-approvals-node-pair-request".to_owned(),
            method: "node.pair.request".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-exec-1"
            }),
        };
        let request_id = match dispatcher.handle_request(&pair_request).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/request/requestId")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("node pair request id"),
            _ => panic!("expected node.pair.request handled"),
        };
        let pair_approve = RpcRequestFrame {
            id: "req-exec-approvals-node-pair-approve".to_owned(),
            method: "node.pair.approve".to_owned(),
            params: serde_json::json!({
                "requestId": request_id
            }),
        };
        let out = dispatcher.handle_request(&pair_approve).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let node_get = RpcRequestFrame {
            id: "req-exec-approvals-node-get".to_owned(),
            method: "exec.approvals.node.get".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-exec-1"
            }),
        };
        let node_hash = match dispatcher.handle_request(&node_get).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/path").and_then(serde_json::Value::as_str),
                    Some("memory://nodes/node-exec-1/exec-approvals.json")
                );
                assert_eq!(
                    payload
                        .pointer("/file/version")
                        .and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert!(payload.pointer("/file/socket/token").is_none());
                payload
                    .pointer("/hash")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("node exec approvals hash")
            }
            _ => panic!("expected exec.approvals.node.get handled"),
        };

        let node_set_missing_base_hash = RpcRequestFrame {
            id: "req-exec-approvals-node-set-no-base".to_owned(),
            method: "exec.approvals.node.set".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-exec-1",
                "file": {
                    "version": 1,
                    "agents": {}
                }
            }),
        };
        let out = dispatcher.handle_request(&node_set_missing_base_hash).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let node_set = RpcRequestFrame {
            id: "req-exec-approvals-node-set".to_owned(),
            method: "exec.approvals.node.set".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-exec-1",
                "baseHash": node_hash,
                "file": {
                    "version": 1,
                    "agents": {
                        "main": {
                            "allowlist": [
                                { "pattern": "cargo test" }
                            ]
                        }
                    }
                }
            }),
        };
        let updated_node_hash = match dispatcher.handle_request(&node_set).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/file/agents/main/allowlist/0/pattern")
                        .and_then(serde_json::Value::as_str),
                    Some("cargo test")
                );
                assert!(payload.pointer("/file/socket/token").is_none());
                payload
                    .pointer("/hash")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("updated node exec approvals hash")
            }
            _ => panic!("expected exec.approvals.node.set handled"),
        };

        assert_ne!(updated_global_hash, updated_node_hash);

        let node_set_stale_hash = RpcRequestFrame {
            id: "req-exec-approvals-node-set-stale".to_owned(),
            method: "exec.approvals.node.set".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-exec-1",
                "baseHash": "stale",
                "file": {
                    "version": 1,
                    "agents": {}
                }
            }),
        };
        let out = dispatcher.handle_request(&node_set_stale_hash).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let node_set_non_object = RpcRequestFrame {
            id: "req-exec-approvals-node-set-non-object".to_owned(),
            method: "exec.approvals.node.set".to_owned(),
            params: serde_json::json!({
                "nodeId": "node-exec-1",
                "baseHash": updated_node_hash,
                "file": "invalid"
            }),
        };
        let out = dispatcher.handle_request(&node_set_non_object).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    #[tokio::test]
    async fn dispatcher_exec_approval_methods_follow_parity_contract() {
        let dispatcher = RpcDispatcher::new();

        let invalid_request = RpcRequestFrame {
            id: "req-exec-approval-request-invalid".to_owned(),
            method: "exec.approval.request".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&invalid_request).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let request_two_phase = RpcRequestFrame {
            id: "req-exec-approval-request-two-phase".to_owned(),
            method: "exec.approval.request".to_owned(),
            params: serde_json::json!({
                "id": "approval-1",
                "command": "git status",
                "twoPhase": true,
                "timeoutMs": 1_000
            }),
        };
        match dispatcher.handle_request(&request_two_phase).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("accepted")
                );
                assert_eq!(
                    payload.pointer("/id").and_then(serde_json::Value::as_str),
                    Some("approval-1")
                );
            }
            _ => panic!("expected exec.approval.request accepted response"),
        }

        let duplicate_id = RpcRequestFrame {
            id: "req-exec-approval-request-duplicate".to_owned(),
            method: "exec.approval.request".to_owned(),
            params: serde_json::json!({
                "id": "approval-1",
                "command": "ls",
                "twoPhase": true
            }),
        };
        let out = dispatcher.handle_request(&duplicate_id).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let wait_missing_id = RpcRequestFrame {
            id: "req-exec-approval-wait-missing-id".to_owned(),
            method: "exec.approval.waitDecision".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&wait_missing_id).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let wait_unknown = RpcRequestFrame {
            id: "req-exec-approval-wait-unknown".to_owned(),
            method: "exec.approval.waitDecision".to_owned(),
            params: serde_json::json!({
                "id": "approval-missing"
            }),
        };
        let out = dispatcher.handle_request(&wait_unknown).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let resolve_invalid_decision = RpcRequestFrame {
            id: "req-exec-approval-resolve-invalid".to_owned(),
            method: "exec.approval.resolve".to_owned(),
            params: serde_json::json!({
                "id": "approval-1",
                "decision": "approve"
            }),
        };
        let out = dispatcher.handle_request(&resolve_invalid_decision).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let resolve_unknown = RpcRequestFrame {
            id: "req-exec-approval-resolve-unknown".to_owned(),
            method: "exec.approval.resolve".to_owned(),
            params: serde_json::json!({
                "id": "approval-missing",
                "decision": "deny"
            }),
        };
        let out = dispatcher.handle_request(&resolve_unknown).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let wait_pending = RpcRequestFrame {
            id: "req-exec-approval-wait-pending".to_owned(),
            method: "exec.approval.waitDecision".to_owned(),
            params: serde_json::json!({
                "id": "approval-1"
            }),
        };
        let resolve_allow_once = RpcRequestFrame {
            id: "req-exec-approval-resolve".to_owned(),
            method: "exec.approval.resolve".to_owned(),
            params: serde_json::json!({
                "id": "approval-1",
                "decision": "allow-once"
            }),
        };
        let wait_future = dispatcher.handle_request(&wait_pending);
        let resolve_future = async {
            tokio::time::sleep(std::time::Duration::from_millis(5)).await;
            dispatcher.handle_request(&resolve_allow_once).await
        };
        let (wait_out, resolve_out) = tokio::join!(wait_future, resolve_future);

        match resolve_out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected exec.approval.resolve handled"),
        }

        match wait_out {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/decision")
                        .and_then(serde_json::Value::as_str),
                    Some("allow-once")
                );
                assert_eq!(
                    payload.pointer("/id").and_then(serde_json::Value::as_str),
                    Some("approval-1")
                );
            }
            _ => panic!("expected exec.approval.waitDecision handled"),
        }

        let wait_resolved = RpcRequestFrame {
            id: "req-exec-approval-wait-resolved".to_owned(),
            method: "exec.approval.waitDecision".to_owned(),
            params: serde_json::json!({
                "id": "approval-1"
            }),
        };
        match dispatcher.handle_request(&wait_resolved).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/decision")
                        .and_then(serde_json::Value::as_str),
                    Some("allow-once")
                );
            }
            _ => panic!("expected resolved waitDecision handled"),
        }

        let request_single_phase_timeout = RpcRequestFrame {
            id: "req-exec-approval-request-single-phase".to_owned(),
            method: "exec.approval.request".to_owned(),
            params: serde_json::json!({
                "command": "echo hi",
                "timeoutMs": 1
            }),
        };
        match dispatcher
            .handle_request(&request_single_phase_timeout)
            .await
        {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(payload.pointer("/id").is_some());
                assert!(payload.pointer("/decision").is_some());
                assert_eq!(
                    payload
                        .pointer("/decision")
                        .and_then(serde_json::Value::as_str),
                    None
                );
            }
            _ => panic!("expected single-phase timeout response"),
        }
    }

    #[tokio::test]
    async fn dispatcher_chat_methods_follow_parity_contract() {
        let dispatcher = RpcDispatcher::new();
        let expected_session_key = super::canonicalize_session_key("main");

        let invalid_history = RpcRequestFrame {
            id: "req-chat-history-invalid".to_owned(),
            method: "chat.history".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&invalid_history).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let missing_idempotency = RpcRequestFrame {
            id: "req-chat-send-missing-idempotency".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "hello"
            }),
        };
        let out = dispatcher.handle_request(&missing_idempotency).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let empty_message = RpcRequestFrame {
            id: "req-chat-send-empty".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "   ",
                "idempotencyKey": "chat-empty"
            }),
        };
        let out = dispatcher.handle_request(&empty_message).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let null_byte_message = RpcRequestFrame {
            id: "req-chat-send-null-byte".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "bad\u{0000}message",
                "idempotencyKey": "chat-null-byte"
            }),
        };
        let out = dispatcher.handle_request(&null_byte_message).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let send = RpcRequestFrame {
            id: "req-chat-send".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "hello from chat",
                "idempotencyKey": "chat-run-1"
            }),
        };
        match dispatcher.handle_request(&send).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/runId")
                        .and_then(serde_json::Value::as_str),
                    Some("chat-run-1")
                );
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("started")
                );
            }
            _ => panic!("expected chat.send started response"),
        }

        match dispatcher.handle_request(&send).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("in_flight")
                );
            }
            _ => panic!("expected chat.send in_flight response"),
        }

        let mut completed = false;
        for _ in 0..10 {
            tokio::time::sleep(std::time::Duration::from_millis(10)).await;
            match dispatcher.handle_request(&send).await {
                RpcDispatchOutcome::Handled(payload) => {
                    let status = payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str)
                        .unwrap_or_default();
                    if status == "ok" {
                        completed = true;
                        break;
                    }
                    assert_eq!(status, "in_flight");
                }
                _ => panic!("expected chat.send replay response"),
            }
        }
        assert!(completed, "expected ok chat.send replay status");

        let patch = RpcRequestFrame {
            id: "req-chat-session-patch".to_owned(),
            method: "sessions.patch".to_owned(),
            params: serde_json::json!({
                "key": "main",
                "thinkingLevel": "high",
                "verboseLevel": "on"
            }),
        };
        let out = dispatcher.handle_request(&patch).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let send_abortable = RpcRequestFrame {
            id: "req-chat-send-abortable".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "abort this run",
                "idempotencyKey": "chat-run-abort"
            }),
        };
        let out = dispatcher.handle_request(&send_abortable).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let abort_mismatch = RpcRequestFrame {
            id: "req-chat-abort-mismatch".to_owned(),
            method: "chat.abort".to_owned(),
            params: serde_json::json!({
                "sessionKey": "other",
                "runId": "chat-run-abort"
            }),
        };
        let out = dispatcher.handle_request(&abort_mismatch).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let abort_not_found = RpcRequestFrame {
            id: "req-chat-abort-not-found".to_owned(),
            method: "chat.abort".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "runId": "chat-run-missing"
            }),
        };
        match dispatcher.handle_request(&abort_not_found).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/aborted")
                        .and_then(serde_json::Value::as_bool),
                    Some(false)
                );
                let run_ids = payload
                    .pointer("/runIds")
                    .and_then(serde_json::Value::as_array)
                    .expect("run ids");
                assert!(run_ids.is_empty());
            }
            _ => panic!("expected chat.abort not found response"),
        }

        let abort = RpcRequestFrame {
            id: "req-chat-abort".to_owned(),
            method: "chat.abort".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "runId": "chat-run-abort"
            }),
        };
        match dispatcher.handle_request(&abort).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/aborted")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/runIds/0")
                        .and_then(serde_json::Value::as_str),
                    Some("chat-run-abort")
                );
            }
            _ => panic!("expected chat.abort aborted response"),
        }

        match dispatcher.handle_request(&send_abortable).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("aborted")
                );
            }
            _ => panic!("expected chat.send aborted replay response"),
        }

        let send_stop_target = RpcRequestFrame {
            id: "req-chat-send-stop-target".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "stop target",
                "idempotencyKey": "chat-run-stop-target"
            }),
        };
        let out = dispatcher.handle_request(&send_stop_target).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let send_stop = RpcRequestFrame {
            id: "req-chat-send-stop".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "/stop",
                "idempotencyKey": "chat-stop"
            }),
        };
        match dispatcher.handle_request(&send_stop).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/aborted")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                let run_ids = payload
                    .pointer("/runIds")
                    .and_then(serde_json::Value::as_array)
                    .expect("run ids");
                let ids = run_ids
                    .iter()
                    .filter_map(serde_json::Value::as_str)
                    .collect::<Vec<_>>();
                assert!(ids.contains(&"chat-run-stop-target"));
            }
            _ => panic!("expected chat.send stop-command abort response"),
        }

        let send_batch_a = RpcRequestFrame {
            id: "req-chat-send-batch-a".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "batch-a",
                "idempotencyKey": "chat-run-a"
            }),
        };
        let send_batch_b = RpcRequestFrame {
            id: "req-chat-send-batch-b".to_owned(),
            method: "chat.send".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "batch-b",
                "idempotencyKey": "chat-run-b"
            }),
        };
        let out = dispatcher.handle_request(&send_batch_a).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));
        let out = dispatcher.handle_request(&send_batch_b).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let abort_session = RpcRequestFrame {
            id: "req-chat-abort-session".to_owned(),
            method: "chat.abort".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main"
            }),
        };
        match dispatcher.handle_request(&abort_session).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/aborted")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                let run_ids = payload
                    .pointer("/runIds")
                    .and_then(serde_json::Value::as_array)
                    .expect("run ids");
                let ids = run_ids
                    .iter()
                    .filter_map(serde_json::Value::as_str)
                    .collect::<Vec<_>>();
                assert_eq!(ids, vec!["chat-run-a", "chat-run-b"]);
            }
            _ => panic!("expected chat.abort session response"),
        }

        let inject_missing_session = RpcRequestFrame {
            id: "req-chat-inject-missing-session".to_owned(),
            method: "chat.inject".to_owned(),
            params: serde_json::json!({
                "sessionKey": "missing",
                "message": "note"
            }),
        };
        let out = dispatcher.handle_request(&inject_missing_session).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let inject = RpcRequestFrame {
            id: "req-chat-inject".to_owned(),
            method: "chat.inject".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "message": "operator note",
                "label": "ops"
            }),
        };
        match dispatcher.handle_request(&inject).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert!(payload.pointer("/messageId").is_some());
            }
            _ => panic!("expected chat.inject handled response"),
        }
        let chat_event = dispatcher
            .node_runtime
            .last_event()
            .await
            .expect("chat event recorded");
        assert_eq!(
            chat_event
                .pointer("/event")
                .and_then(serde_json::Value::as_str),
            Some("chat")
        );
        let payload_json = chat_event
            .pointer("/payloadJSON")
            .and_then(serde_json::Value::as_str)
            .expect("chat payload json");
        let payload_value: serde_json::Value =
            serde_json::from_str(payload_json).expect("parse chat payload");
        assert_eq!(
            payload_value
                .pointer("/state")
                .and_then(serde_json::Value::as_str),
            Some("final")
        );
        assert_eq!(
            payload_value
                .pointer("/sessionKey")
                .and_then(serde_json::Value::as_str),
            Some(expected_session_key.as_str())
        );
        assert_eq!(
            payload_value
                .pointer("/message/role")
                .and_then(serde_json::Value::as_str),
            Some("assistant")
        );
        assert!(payload_value.pointer("/message/id").is_some());
        assert!(payload_value.pointer("/message/parentId").is_some());

        let history = RpcRequestFrame {
            id: "req-chat-history".to_owned(),
            method: "chat.history".to_owned(),
            params: serde_json::json!({
                "sessionKey": "main",
                "limit": 3
            }),
        };
        match dispatcher.handle_request(&history).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/sessionKey")
                        .and_then(serde_json::Value::as_str),
                    Some(expected_session_key.as_str())
                );
                assert!(payload.pointer("/sessionId").is_some());
                assert_eq!(
                    payload
                        .pointer("/thinkingLevel")
                        .and_then(serde_json::Value::as_str),
                    Some("high")
                );
                assert_eq!(
                    payload
                        .pointer("/verboseLevel")
                        .and_then(serde_json::Value::as_str),
                    Some("on")
                );
                let messages = payload
                    .pointer("/messages")
                    .and_then(serde_json::Value::as_array)
                    .expect("messages array");
                assert_eq!(messages.len(), 3);
                assert!(messages.iter().all(|msg| msg.pointer("/id").is_some()));
                assert!(messages
                    .iter()
                    .all(|msg| msg.pointer("/parentId").is_some()));
                assert!(messages[0]
                    .pointer("/parentId")
                    .is_some_and(|v| v.is_null()));
                assert_eq!(
                    messages[1]
                        .pointer("/parentId")
                        .and_then(serde_json::Value::as_str),
                    messages[0]
                        .pointer("/id")
                        .and_then(serde_json::Value::as_str)
                );
                assert_eq!(
                    messages[2]
                        .pointer("/parentId")
                        .and_then(serde_json::Value::as_str),
                    messages[1]
                        .pointer("/id")
                        .and_then(serde_json::Value::as_str)
                );
                assert_eq!(
                    messages
                        .first()
                        .and_then(|msg| msg.pointer("/role"))
                        .and_then(serde_json::Value::as_str),
                    Some("user")
                );
                assert_eq!(
                    messages
                        .last()
                        .and_then(|msg| msg.pointer("/role"))
                        .and_then(serde_json::Value::as_str),
                    Some("assistant")
                );
                let texts = messages
                    .iter()
                    .filter_map(|msg| msg.pointer("/content"))
                    .filter_map(serde_json::Value::as_str)
                    .collect::<Vec<_>>();
                assert_eq!(texts, vec!["batch-a", "batch-b", "[ops] operator note"]);
            }
            _ => panic!("expected chat.history handled response"),
        }

        let channels_status = RpcRequestFrame {
            id: "req-chat-channels-status".to_owned(),
            method: "channels.status".to_owned(),
            params: serde_json::json!({
                "probe": false
            }),
        };
        match dispatcher.handle_request(&channels_status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert!(
                    payload
                        .pointer("/channelAccounts/webchat/0/lastOutboundAt")
                        .and_then(serde_json::Value::as_u64)
                        .unwrap_or(0)
                        > 0
                );
            }
            _ => panic!("expected channels.status handled response"),
        }
    }

    #[tokio::test]
    async fn dispatcher_cron_methods_manage_jobs_and_runs() {
        let dispatcher = RpcDispatcher::new();

        let invalid_list = RpcRequestFrame {
            id: "req-cron-list-invalid".to_owned(),
            method: "cron.list".to_owned(),
            params: serde_json::json!({
                "extra": true
            }),
        };
        let out = dispatcher.handle_request(&invalid_list).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let add = RpcRequestFrame {
            id: "req-cron-add".to_owned(),
            method: "cron.add".to_owned(),
            params: serde_json::json!({
                "name": "Ops Reminder",
                "enabled": true,
                "schedule": {
                    "kind": "every",
                    "everyMs": 60_000
                },
                "sessionTarget": "isolated",
                "wakeMode": "next-heartbeat",
                "payload": {
                    "kind": "agentTurn",
                    "message": "run periodic check",
                    "deliver": true,
                    "channel": "telegram",
                    "to": "42",
                    "bestEffortDeliver": true
                }
            }),
        };
        let job_id = match dispatcher.handle_request(&add).await {
            RpcDispatchOutcome::Handled(payload) => {
                let id = payload
                    .pointer("/id")
                    .and_then(serde_json::Value::as_str)
                    .map(ToOwned::to_owned)
                    .expect("cron job id");
                assert_eq!(
                    payload
                        .pointer("/delivery/mode")
                        .and_then(serde_json::Value::as_str),
                    Some("announce")
                );
                assert_eq!(
                    payload
                        .pointer("/delivery/channel")
                        .and_then(serde_json::Value::as_str),
                    Some("telegram")
                );
                id
            }
            _ => panic!("expected cron.add handled"),
        };

        let status = RpcRequestFrame {
            id: "req-cron-status".to_owned(),
            method: "cron.status".to_owned(),
            params: serde_json::json!({}),
        };
        match dispatcher.handle_request(&status).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/enabled")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload.pointer("/jobs").and_then(serde_json::Value::as_u64),
                    Some(1)
                );
                assert_eq!(
                    payload
                        .pointer("/storePath")
                        .and_then(serde_json::Value::as_str),
                    Some(super::CRON_STORE_PATH)
                );
            }
            _ => panic!("expected cron.status handled"),
        }

        let update = RpcRequestFrame {
            id: "req-cron-update".to_owned(),
            method: "cron.update".to_owned(),
            params: serde_json::json!({
                "jobId": job_id.clone(),
                "patch": {
                    "enabled": false,
                    "payload": {
                        "model": "anthropic/claude-sonnet-4-5"
                    }
                }
            }),
        };
        let out = dispatcher.handle_request(&update).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let run_disabled = RpcRequestFrame {
            id: "req-cron-run-disabled".to_owned(),
            method: "cron.run".to_owned(),
            params: serde_json::json!({
                "id": job_id.clone(),
                "mode": "due"
            }),
        };
        match dispatcher.handle_request(&run_disabled).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("skipped")
                );
            }
            _ => panic!("expected cron.run handled for disabled job"),
        }

        let enable = RpcRequestFrame {
            id: "req-cron-enable".to_owned(),
            method: "cron.update".to_owned(),
            params: serde_json::json!({
                "id": job_id.clone(),
                "patch": {
                    "enabled": true
                }
            }),
        };
        let out = dispatcher.handle_request(&enable).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        let run = RpcRequestFrame {
            id: "req-cron-run".to_owned(),
            method: "cron.run".to_owned(),
            params: serde_json::json!({
                "id": job_id.clone(),
                "mode": "force"
            }),
        };
        match dispatcher.handle_request(&run).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("ok")
                );
                assert_eq!(
                    payload
                        .pointer("/action")
                        .and_then(serde_json::Value::as_str),
                    Some("finished")
                );
            }
            _ => panic!("expected cron.run handled"),
        }

        let runs = RpcRequestFrame {
            id: "req-cron-runs".to_owned(),
            method: "cron.runs".to_owned(),
            params: serde_json::json!({
                "id": job_id.clone(),
                "limit": 50
            }),
        };
        match dispatcher.handle_request(&runs).await {
            RpcDispatchOutcome::Handled(payload) => {
                let entries = payload
                    .pointer("/entries")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(!entries.is_empty());
                assert_eq!(
                    entries
                        .last()
                        .and_then(|entry| entry.pointer("/jobId"))
                        .and_then(serde_json::Value::as_str),
                    Some(job_id.as_str())
                );
            }
            _ => panic!("expected cron.runs handled"),
        }

        let remove = RpcRequestFrame {
            id: "req-cron-remove".to_owned(),
            method: "cron.remove".to_owned(),
            params: serde_json::json!({
                "id": job_id.clone()
            }),
        };
        match dispatcher.handle_request(&remove).await {
            RpcDispatchOutcome::Handled(payload) => {
                assert_eq!(
                    payload.pointer("/ok").and_then(serde_json::Value::as_bool),
                    Some(true)
                );
                assert_eq!(
                    payload
                        .pointer("/removed")
                        .and_then(serde_json::Value::as_bool),
                    Some(true)
                );
            }
            _ => panic!("expected cron.remove handled"),
        }

        let list_after_remove = RpcRequestFrame {
            id: "req-cron-list-after-remove".to_owned(),
            method: "cron.list".to_owned(),
            params: serde_json::json!({
                "includeDisabled": true
            }),
        };
        match dispatcher.handle_request(&list_after_remove).await {
            RpcDispatchOutcome::Handled(payload) => {
                let jobs = payload
                    .pointer("/jobs")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(jobs.is_empty());
            }
            _ => panic!("expected cron.list handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_cron_update_rejects_payload_kind_change_and_invalid_webhook() {
        let dispatcher = RpcDispatcher::new();

        let add = RpcRequestFrame {
            id: "req-cron-kind-add".to_owned(),
            method: "cron.add".to_owned(),
            params: serde_json::json!({
                "name": "System Event Job",
                "schedule": {
                    "kind": "every",
                    "everyMs": 30_000
                },
                "sessionTarget": "main",
                "wakeMode": "next-heartbeat",
                "payload": {
                    "kind": "systemEvent",
                    "text": "hello"
                }
            }),
        };
        let job_id = match dispatcher.handle_request(&add).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/id")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("cron id"),
            _ => panic!("expected cron.add handled"),
        };

        let kind_change = RpcRequestFrame {
            id: "req-cron-kind-update".to_owned(),
            method: "cron.update".to_owned(),
            params: serde_json::json!({
                "id": job_id.clone(),
                "patch": {
                    "payload": {
                        "kind": "agentTurn",
                        "message": "not allowed"
                    }
                }
            }),
        };
        let out = dispatcher.handle_request(&kind_change).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));

        let invalid_webhook = RpcRequestFrame {
            id: "req-cron-webhook-invalid".to_owned(),
            method: "cron.add".to_owned(),
            params: serde_json::json!({
                "name": "Invalid webhook",
                "schedule": {
                    "kind": "every",
                    "everyMs": 60_000
                },
                "sessionTarget": "main",
                "wakeMode": "next-heartbeat",
                "payload": {
                    "kind": "systemEvent",
                    "text": "x"
                },
                "delivery": {
                    "mode": "webhook",
                    "to": "ftp://example.invalid"
                }
            }),
        };
        let out = dispatcher.handle_request(&invalid_webhook).await;
        assert!(matches!(out, RpcDispatchOutcome::Error { code: 400, .. }));
    }

    async fn patch_config(dispatcher: &RpcDispatcher, patch: Value) {
        let get = RpcRequestFrame {
            id: "req-config-cron-get".to_owned(),
            method: "config.get".to_owned(),
            params: json!({}),
        };
        let hash = match dispatcher.handle_request(&get).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/hash")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("config hash"),
            _ => panic!("expected config.get handled"),
        };
        let patch = RpcRequestFrame {
            id: "req-config-cron-patch".to_owned(),
            method: "config.patch".to_owned(),
            params: json!({
                "baseHash": hash,
                "raw": patch.to_string()
            }),
        };
        let out = dispatcher.handle_request(&patch).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));
    }

    async fn patch_config_cron(dispatcher: &RpcDispatcher, patch: Value) {
        patch_config(dispatcher, patch).await;
    }

    #[tokio::test]
    async fn dispatcher_cron_store_path_persists_and_recovers_jobs_across_dispatchers() {
        let root = std::env::temp_dir().join(format!("openclaw-rs-cron-store-{}", now_ms()));
        fs::create_dir_all(&root).expect("create temp cron root");
        let store_path = root.join("cron").join("jobs.json");
        let store_path_text = store_path.to_string_lossy().to_string();

        let dispatcher = RpcDispatcher::new();
        patch_config_cron(
            &dispatcher,
            json!({
                "cron": {
                    "storePath": store_path_text
                }
            }),
        )
        .await;

        let add = RpcRequestFrame {
            id: "req-cron-persist-add".to_owned(),
            method: "cron.add".to_owned(),
            params: json!({
                "name": "Persisted job",
                "enabled": true,
                "schedule": {
                    "kind": "every",
                    "everyMs": 60_000
                },
                "sessionTarget": "main",
                "wakeMode": "next-heartbeat",
                "payload": {
                    "kind": "systemEvent",
                    "text": "persist me"
                }
            }),
        };
        let job_id = match dispatcher.handle_request(&add).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/id")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned)
                .expect("persisted cron job id"),
            _ => panic!("expected cron.add handled"),
        };

        assert!(store_path.exists(), "cron store should be created on disk");
        let disk_snapshot = fs::read_to_string(&store_path).expect("read cron store");
        let disk_json =
            serde_json::from_str::<Value>(&disk_snapshot).expect("parse cron store JSON");
        let disk_jobs = disk_json
            .pointer("/jobs")
            .and_then(Value::as_array)
            .cloned()
            .unwrap_or_default();
        assert!(
            disk_jobs.iter().any(|job| {
                job.pointer("/id")
                    .and_then(Value::as_str)
                    .map(|value| value == job_id)
                    .unwrap_or(false)
            }),
            "cron store should include newly added job"
        );

        let restarted = RpcDispatcher::new();
        patch_config_cron(
            &restarted,
            json!({
                "cron": {
                    "storePath": store_path.to_string_lossy().to_string()
                }
            }),
        )
        .await;

        let list = RpcRequestFrame {
            id: "req-cron-persist-list".to_owned(),
            method: "cron.list".to_owned(),
            params: json!({
                "includeDisabled": true
            }),
        };
        match restarted.handle_request(&list).await {
            RpcDispatchOutcome::Handled(payload) => {
                let jobs = payload
                    .pointer("/jobs")
                    .and_then(Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(jobs.iter().any(|job| {
                    job.pointer("/id")
                        .and_then(Value::as_str)
                        .map(|value| value == job_id)
                        .unwrap_or(false)
                }));
            }
            _ => panic!("expected cron.list handled"),
        }

        let _ = fs::remove_dir_all(&root);
    }

    #[tokio::test]
    async fn dispatcher_cron_run_webhook_delivery_posts_payload() {
        let listener = std::net::TcpListener::bind("127.0.0.1:0").expect("bind webhook listener");
        let webhook_addr = listener.local_addr().expect("webhook local addr");
        let captured_request: Arc<Mutex<Option<String>>> = Arc::new(Mutex::new(None));
        let captured_request_server = Arc::clone(&captured_request);
        let server = std::thread::spawn(move || {
            let (mut stream, _) = listener.accept().expect("accept webhook request");
            let mut buffer = [0u8; 16 * 1024];
            let bytes_read = stream.read(&mut buffer).expect("read webhook request");
            let request_text = String::from_utf8_lossy(&buffer[..bytes_read]).to_string();
            let mut guard = captured_request_server
                .lock()
                .expect("lock captured webhook request");
            *guard = Some(request_text);
            let response = b"HTTP/1.1 200 OK\r\nContent-Length:2\r\nConnection: close\r\n\r\nok";
            stream.write_all(response).expect("write webhook response");
        });

        let dispatcher = RpcDispatcher::new();
        patch_config_cron(
            &dispatcher,
            json!({
                "cron": {
                    "webhookToken": "cron-webhook-token"
                }
            }),
        )
        .await;

        let add = RpcRequestFrame {
            id: "req-cron-webhook-delivery-add".to_owned(),
            method: "cron.add".to_owned(),
            params: serde_json::json!({
                "name": "Webhook cron delivery",
                "schedule": {
                    "kind": "every",
                    "everyMs": 60_000
                },
                "sessionTarget": "main",
                "wakeMode": "next-heartbeat",
                "payload": {
                    "kind": "systemEvent",
                    "text": "cron webhook payload"
                },
                "delivery": {
                    "mode": "webhook",
                    "to": format!("http://{webhook_addr}/cron")
                }
            }),
        };
        let job_id = match dispatcher.handle_request(&add).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/id")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("cron webhook job id"),
            _ => panic!("expected cron.add handled"),
        };

        let run = RpcRequestFrame {
            id: "req-cron-webhook-delivery-run".to_owned(),
            method: "cron.run".to_owned(),
            params: serde_json::json!({
                "id": job_id.clone(),
                "mode": "force"
            }),
        };
        let out = dispatcher.handle_request(&run).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        server.join().expect("join webhook server thread");
        let request_text = captured_request
            .lock()
            .expect("lock captured webhook request")
            .clone()
            .unwrap_or_default();
        let lowered = request_text.to_ascii_lowercase();
        assert!(lowered.contains("authorization: bearer cron-webhook-token"));
        let body = request_text
            .split("\r\n\r\n")
            .nth(1)
            .unwrap_or_default()
            .to_owned();
        let payload: serde_json::Value =
            serde_json::from_str(&body).expect("parse webhook JSON payload");
        assert_eq!(
            payload
                .pointer("/action")
                .and_then(serde_json::Value::as_str),
            Some("finished")
        );
        assert_eq!(
            payload
                .pointer("/jobId")
                .and_then(serde_json::Value::as_str),
            Some(job_id.as_str())
        );
        assert_eq!(
            payload
                .pointer("/status")
                .and_then(serde_json::Value::as_str),
            Some("ok")
        );
    }

    #[tokio::test]
    async fn dispatcher_cron_run_legacy_notify_webhook_fallback_posts_payload() {
        let listener = std::net::TcpListener::bind("127.0.0.1:0").expect("bind webhook listener");
        let webhook_addr = listener.local_addr().expect("webhook local addr");
        let captured_request: Arc<Mutex<Option<String>>> = Arc::new(Mutex::new(None));
        let captured_request_server = Arc::clone(&captured_request);
        let server = std::thread::spawn(move || {
            let (mut stream, _) = listener.accept().expect("accept webhook request");
            let mut buffer = [0u8; 16 * 1024];
            let bytes_read = stream.read(&mut buffer).expect("read webhook request");
            let request_text = String::from_utf8_lossy(&buffer[..bytes_read]).to_string();
            let mut guard = captured_request_server
                .lock()
                .expect("lock captured webhook request");
            *guard = Some(request_text);
            let response = b"HTTP/1.1 200 OK\r\nContent-Length:2\r\nConnection: close\r\n\r\nok";
            stream.write_all(response).expect("write webhook response");
        });

        let dispatcher = RpcDispatcher::new();
        patch_config_cron(
            &dispatcher,
            json!({
                "cron": {
                    "webhook": format!("http://{webhook_addr}/legacy"),
                    "webhookToken": "cron-webhook-token"
                }
            }),
        )
        .await;

        let add = RpcRequestFrame {
            id: "req-cron-webhook-legacy-add".to_owned(),
            method: "cron.add".to_owned(),
            params: serde_json::json!({
                "name": "Legacy notify webhook",
                "schedule": {
                    "kind": "every",
                    "everyMs": 60_000
                },
                "sessionTarget": "main",
                "wakeMode": "next-heartbeat",
                "notify": true,
                "payload": {
                    "kind": "systemEvent",
                    "text": "legacy cron webhook payload"
                }
            }),
        };
        let job_id = match dispatcher.handle_request(&add).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/id")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("legacy cron webhook job id"),
            _ => panic!("expected cron.add handled"),
        };

        let run = RpcRequestFrame {
            id: "req-cron-webhook-legacy-run".to_owned(),
            method: "cron.run".to_owned(),
            params: serde_json::json!({
                "id": job_id.clone(),
                "mode": "force"
            }),
        };
        let out = dispatcher.handle_request(&run).await;
        assert!(matches!(out, RpcDispatchOutcome::Handled(_)));

        server.join().expect("join webhook server thread");
        let request_text = captured_request
            .lock()
            .expect("lock captured webhook request")
            .clone()
            .unwrap_or_default();
        let lowered = request_text.to_ascii_lowercase();
        assert!(lowered.contains("post /legacy http/1.1"));
        assert!(lowered.contains("authorization: bearer cron-webhook-token"));
        let body = request_text
            .split("\r\n\r\n")
            .nth(1)
            .unwrap_or_default()
            .to_owned();
        let payload: serde_json::Value =
            serde_json::from_str(&body).expect("parse webhook JSON payload");
        assert_eq!(
            payload
                .pointer("/action")
                .and_then(serde_json::Value::as_str),
            Some("finished")
        );
        assert_eq!(
            payload
                .pointer("/jobId")
                .and_then(serde_json::Value::as_str),
            Some(job_id.as_str())
        );
        assert_eq!(
            payload
                .pointer("/summary")
                .and_then(serde_json::Value::as_str),
            Some("legacy cron webhook payload")
        );

        let logs_tail = RpcRequestFrame {
            id: "req-cron-webhook-legacy-logs".to_owned(),
            method: "logs.tail".to_owned(),
            params: json!({
                "limit": 200
            }),
        };
        match dispatcher.handle_request(&logs_tail).await {
            RpcDispatchOutcome::Handled(payload) => {
                let lines = payload
                    .pointer("/lines")
                    .and_then(Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert!(lines.iter().any(|line| {
                    line.as_str().map_or(false, |text| {
                        text.contains(
                            "source=legacy_notify_fallback deprecation=notify+cron.webhook",
                        )
                    })
                }));
            }
            _ => panic!("expected logs.tail handled"),
        }
    }

    #[test]
    fn cron_webhook_dispatch_skips_empty_summary() {
        let job = CronJob {
            id: "cron-empty-summary".to_owned(),
            agent_id: None,
            session_key: None,
            name: "Empty summary".to_owned(),
            description: None,
            enabled: true,
            delete_after_run: None,
            created_at_ms: now_ms(),
            updated_at_ms: now_ms(),
            schedule: CronSchedule::Every {
                every_ms: 60_000,
                anchor_ms: None,
            },
            session_target: "main".to_owned(),
            wake_mode: "next-heartbeat".to_owned(),
            payload: CronPayload::SystemEvent {
                text: "ignored".to_owned(),
            },
            delivery: Some(CronDelivery {
                mode: "webhook".to_owned(),
                channel: None,
                to: Some("https://example.invalid/cron".to_owned()),
                best_effort: None,
            }),
            notify: None,
            state: CronJobState::default(),
        };
        let entry = CronRunLogEntry {
            ts: now_ms(),
            job_id: job.id.clone(),
            action: "finished".to_owned(),
            status: Some(CronRunStatus::Ok),
            error: None,
            summary: Some("   ".to_owned()),
            session_id: None,
            session_key: None,
            run_at_ms: Some(now_ms()),
            duration_ms: Some(0),
            next_run_at_ms: None,
        };
        let defaults = CronWebhookDefaults::default();
        let dispatch = build_cron_webhook_dispatch(&job, &entry, &defaults);
        assert!(dispatch.is_none());
    }

    #[tokio::test]
    async fn dispatcher_runs_due_cron_jobs_without_manual_cron_run_calls() {
        let dispatcher = RpcDispatcher::new();

        let add = RpcRequestFrame {
            id: "req-cron-due-add".to_owned(),
            method: "cron.add".to_owned(),
            params: serde_json::json!({
                "name": "Due system event",
                "enabled": true,
                "schedule": {
                    "kind": "every",
                    "everyMs": 60_000
                },
                "sessionTarget": "main",
                "wakeMode": "next-heartbeat",
                "payload": {
                    "kind": "systemEvent",
                    "text": "cron due event"
                }
            }),
        };

        let job_id = match dispatcher.handle_request(&add).await {
            RpcDispatchOutcome::Handled(payload) => payload
                .pointer("/id")
                .and_then(serde_json::Value::as_str)
                .map(ToOwned::to_owned)
                .expect("cron job id"),
            _ => panic!("expected cron.add handled"),
        };

        assert_eq!(dispatcher.run_due_cron_jobs(4).await, 1);
        assert_eq!(dispatcher.run_due_cron_jobs(4).await, 0);

        let runs = RpcRequestFrame {
            id: "req-cron-due-runs".to_owned(),
            method: "cron.runs".to_owned(),
            params: serde_json::json!({
                "id": job_id,
                "limit": 10
            }),
        };
        let out = dispatcher.handle_request(&runs).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                let entries = payload
                    .pointer("/entries")
                    .and_then(serde_json::Value::as_array)
                    .cloned()
                    .unwrap_or_default();
                assert_eq!(entries.len(), 1);
                assert_eq!(
                    entries[0]
                        .pointer("/status")
                        .and_then(serde_json::Value::as_str),
                    Some("ok")
                );
            }
            _ => panic!("expected cron.runs handled"),
        }

        let presence = RpcRequestFrame {
            id: "req-cron-due-presence".to_owned(),
            method: "system-presence".to_owned(),
            params: serde_json::json!({}),
        };
        let out = dispatcher.handle_request(&presence).await;
        match out {
            RpcDispatchOutcome::Handled(payload) => {
                let entries = payload.as_array().cloned().unwrap_or_default();
                assert!(entries.iter().any(|entry| {
                    entry.pointer("/reason").and_then(serde_json::Value::as_str) == Some("cron")
                        && entry.pointer("/text").and_then(serde_json::Value::as_str)
                            == Some("cron due event")
                }));
            }
            _ => panic!("expected system-presence handled"),
        }
    }

    #[tokio::test]
    async fn dispatcher_status_benchmark_emits_latency_profile() {
        let dispatcher = RpcDispatcher::new();
        let iterations = std::env::var("OPENCLAW_CP8_BENCH_ITERS")
            .ok()
            .and_then(|value| value.parse::<usize>().ok())
            .unwrap_or(512)
            .clamp(64, 10_000);

        let mut samples_us = Vec::with_capacity(iterations);
        let benchmark_start = Instant::now();

        for index in 0..iterations {
            let request = RpcRequestFrame {
                id: format!("cp8-bench-status-{index}"),
                method: "status".to_owned(),
                params: json!({}),
            };
            let started = Instant::now();
            let outcome = dispatcher.handle_request(&request).await;
            assert!(
                matches!(outcome, RpcDispatchOutcome::Handled(_)),
                "status benchmark request should be handled"
            );
            let elapsed_us = started.elapsed().as_micros() as u64;
            samples_us.push(elapsed_us);
        }

        samples_us.sort_unstable();
        let elapsed = benchmark_start.elapsed();
        let elapsed_secs = elapsed.as_secs_f64().max(0.000_001);
        let throughput_ops_per_sec = (iterations as f64) / elapsed_secs;
        let p50_us = percentile_us(&samples_us, 0.50);
        let p95_us = percentile_us(&samples_us, 0.95);
        let p99_us = percentile_us(&samples_us, 0.99);
        let max_us = *samples_us.last().unwrap_or(&0);
        let min_us = *samples_us.first().unwrap_or(&0);
        let rss_kib = current_rss_kib();

        if let Ok(path) = std::env::var("OPENCLAW_CP8_BENCH_OUT") {
            let benchmark = json!({
                "fixture": "gateway::tests::dispatcher_status_benchmark_emits_latency_profile",
                "iterations": iterations,
                "elapsedMs": elapsed.as_millis() as u64,
                "throughputOpsPerSec": throughput_ops_per_sec,
                "latencyUs": {
                    "min": min_us,
                    "p50": p50_us,
                    "p95": p95_us,
                    "p99": p99_us,
                    "max": max_us
                },
                "rssKiB": rss_kib
            });
            let bytes = serde_json::to_vec_pretty(&benchmark).expect("serialize benchmark");
            std::fs::write(path, bytes).expect("write cp8 benchmark metrics");
        }

        // Keep guardrails generous to avoid host-specific flakiness while still catching extreme regressions.
        assert!(
            p99_us <= 150_000,
            "cp8 benchmark regression: p99={}us exceeds 150000us",
            p99_us
        );
        assert!(
            throughput_ops_per_sec >= 10.0,
            "cp8 benchmark regression: throughput={throughput_ops_per_sec:.2} ops/s below 10 ops/s"
        );
    }

    fn percentile_us(samples: &[u64], percentile: f64) -> u64 {
        if samples.is_empty() {
            return 0;
        }
        let bounded = percentile.clamp(0.0, 1.0);
        let index = ((samples.len() - 1) as f64 * bounded).round() as usize;
        samples[index]
    }

    fn current_rss_kib() -> Option<u64> {
        #[cfg(target_os = "linux")]
        {
            let content = std::fs::read_to_string("/proc/self/status").ok()?;
            for line in content.lines() {
                if let Some(rest) = line.strip_prefix("VmRSS:") {
                    let value = rest.split_whitespace().next().unwrap_or("0");
                    return value.parse::<u64>().ok();
                }
            }
            None
        }

        #[cfg(not(target_os = "linux"))]
        {
            None
        }
    }

    #[tokio::test]
    async fn dispatcher_payload_corpus_matches_upstream_fixtures() {
        let suite: PayloadParitySuite =
            serde_json::from_str(include_str!("../tests/parity/gateway-payload-corpus.json"))
                .expect("payload parity fixture");

        for case in suite.cases {
            let dispatcher = RpcDispatcher::new();
            let mut captures: HashMap<String, Value> = HashMap::new();

            for prelude in case.prelude {
                if prelude.method == "__sleep__" {
                    let delay_ms = prelude.sleep_ms.unwrap_or(0);
                    if delay_ms > 0 {
                        tokio::time::sleep(std::time::Duration::from_millis(delay_ms)).await;
                    }
                    continue;
                }
                let prelude_params = resolve_payload_template(&prelude.params, &captures);
                let prelude_req = RpcRequestFrame {
                    id: prelude.id,
                    method: prelude.method,
                    params: prelude_params,
                };
                let prelude_outcome = dispatcher.handle_request(&prelude_req).await;
                let prelude_payload = match prelude_outcome {
                    RpcDispatchOutcome::Handled(payload) => payload,
                    RpcDispatchOutcome::Error {
                        code,
                        message,
                        details,
                    } => {
                        panic!(
                            "case {} prelude request {} failed code={} message={} details={}",
                            case.name,
                            prelude_req.id,
                            code,
                            message,
                            details
                                .map(|value| value.to_string())
                                .unwrap_or_else(|| "null".to_owned())
                        );
                    }
                    RpcDispatchOutcome::NotHandled => {
                        panic!(
                            "case {} prelude request {} was not handled",
                            case.name, prelude_req.id
                        );
                    }
                };
                for capture in prelude.captures {
                    let Some(value) = prelude_payload.pointer(&capture.path).cloned() else {
                        panic!(
                            "case {} prelude request {} missing capture path {}",
                            case.name, prelude_req.id, capture.path
                        );
                    };
                    captures.insert(capture.as_name, value);
                }
            }

            let event_count_before = dispatcher.node_runtime.event_count().await;
            let request_params = resolve_payload_template(&case.request.params, &captures);
            let request = RpcRequestFrame {
                id: case.request.id,
                method: case.request.method,
                params: request_params,
            };

            let outcome = dispatcher.handle_request(&request).await;
            match payload_outcome_name(&case.expect.outcome).as_str() {
                "handled" => {
                    let payload = match outcome {
                        RpcDispatchOutcome::Handled(payload) => payload,
                        RpcDispatchOutcome::Error { code, message, .. } => {
                            panic!(
                                "case {} expected handled but got error code={} message={}",
                                case.name, code, message
                            );
                        }
                        RpcDispatchOutcome::NotHandled => {
                            panic!("case {} expected handled but got not handled", case.name);
                        }
                    };
                    assert_payload_checks(&payload, &case.expect.checks, &case.name, "response");
                }
                "error" => {
                    let (code, message, details) = match outcome {
                        RpcDispatchOutcome::Error {
                            code,
                            message,
                            details,
                        } => (code, message, details),
                        RpcDispatchOutcome::Handled(payload) => {
                            panic!(
                                "case {} expected error but got handled payload={}",
                                case.name, payload
                            );
                        }
                        RpcDispatchOutcome::NotHandled => {
                            panic!("case {} expected error but got not handled", case.name);
                        }
                    };
                    if let Some(expect_error) = case.expect.error.as_ref() {
                        if let Some(expected_code) = expect_error.code {
                            assert_eq!(
                                code, expected_code,
                                "case {} error code mismatch",
                                case.name
                            );
                        }
                        if let Some(fragment) = expect_error.message_contains.as_deref() {
                            assert!(
                                message.contains(fragment),
                                "case {} expected error message to contain {fragment}, got {}",
                                case.name,
                                message
                            );
                        }
                    }
                    if !case.expect.error_checks.is_empty() {
                        let error_payload = json!({
                            "code": code,
                            "message": message,
                            "details": details
                        });
                        assert_payload_checks(
                            &error_payload,
                            &case.expect.error_checks,
                            &case.name,
                            "error payload",
                        );
                    }
                }
                other => panic!("case {} unsupported outcome {}", case.name, other),
            }

            if let Some(expect_event) = case.expect.event.as_ref() {
                let event_count_after = dispatcher.node_runtime.event_count().await;
                assert_eq!(
                    event_count_after,
                    event_count_before + 1,
                    "case {} expected exactly one emitted event",
                    case.name
                );
                let event = dispatcher
                    .node_runtime
                    .last_event()
                    .await
                    .expect("event payload");
                assert_eq!(
                    event.pointer("/event").and_then(serde_json::Value::as_str),
                    Some(expect_event.name.as_str()),
                    "case {} event name mismatch",
                    case.name
                );
                let payload_json = event
                    .pointer("/payloadJSON")
                    .and_then(serde_json::Value::as_str)
                    .expect("event payload json");
                let payload: Value =
                    serde_json::from_str(payload_json).expect("parse event payload");
                assert_payload_checks(&payload, &expect_event.checks, &case.name, "event payload");
            } else {
                let event_count_after = dispatcher.node_runtime.event_count().await;
                assert_eq!(
                    event_count_after, event_count_before,
                    "case {} expected no emitted events",
                    case.name
                );
            }
        }
    }
}
